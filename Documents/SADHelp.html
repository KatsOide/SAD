<head>
<title>
</title>
<style>
eqs img{
  display: inline;
  vertical-align: center;
  white-space:nowrap;
  font-size:0;
}
</style>
</head>
<body>
<center><h2>Welcome to SAD/FFS & SADScript
</h2></center>
<center> SAD/FFS SADScript Version: 1.1.8.6.1k64,      Updated: 07/18/2020</center>

<pre> Please use browser's search to find an item.

 The FFS commands are shown in uppercases. The minimum abbreviated form of each command is enclosed
in (). Each command can be shorten down to that. The optional arguments for the commands are usually
shown in [].
 The notation ===> reads "equivalent to" below.</pre>
<a href="http://acc-physics.kek.jp/SAD/">
<h4>
<img src="SADHelp_img/SAD.jpg" align="middle" alt="SAD" width=90></a>
Back to SAD Home Page</H4>
<a href="example/design_example.html">
<h4>
SAD/FFS Examples</h4></a>
<hr>
<pre>
<a href=#L > </a>
   <a href=#LABORT>ABORT</a>
   <a href=#LAPPEND(APP)>APPEND(APP)</a>
   <a href=#LATTRIBUTE(ATTR)>ATTRIBUTE(ATTR)</a>
   <a href=#Lbeam-line>beam-line</a>
      <a href=#Lbeam-line-functions>beam-line-functions</a>
         <a href=#LBeamLine>BeamLine</a>
         <a href=#LBeamLineName>BeamLineName</a>
         <a href=#LExtractBeamLine>ExtractBeamLine</a>
         <a href=#LPrintBeamLine>PrintBeamLine</a>
         <a href=#LWriteBeamLine>WriteBeamLine</a>
      <a href=#Lorientation-of-an-element>orientation-of-an-element</a>
   <a href=#LBEAMSIZE(BEAM)>BEAMSIZE(BEAM)</a>
   <a href=#LBYE>BYE</a>
   <a href=#Lcharacter-string>character-string</a>
      <a href=#LFromCharacterCode>FromCharacterCode</a>
      <a href=#LStringFill>StringFill</a>
      <a href=#LStringJoin>StringJoin</a>
      <a href=#LStringLength>StringLength</a>
      <a href=#LStringMatchQ>StringMatchQ</a>
      <a href=#LStringPart>StringPart</a>
      <a href=#LStringPosition>StringPosition</a>
      <a href=#LStringReplace>StringReplace</a>
      <a href=#LStringTrim>StringTrim</a>
      <a href=#LSymbol>Symbol</a>
      <a href=#LToCharacterCode>ToCharacterCode</a>
      <a href=#LToExpression>ToExpression</a>
      <a href=#LToString>ToString</a>
   <a href=#Lcommand-syntax>command-syntax</a>
   <a href=#Lcomponents>components</a>
   <a href=#Lconstants>constants</a>
   <a href=#LCALCULATE(CAL)>CALCULATE(CAL)</a>
   <a href=#LCHROMATICITY(CHRO)>CHROMATICITY(CHRO)</a>
   <a href=#LCLOSE(CLO)>CLOSE(CLO)</a>
   <a href=#LCOUPLE(COUP)>COUPLE(COUP)</a>
   <a href=#Ldata-structure>data-structure</a>
      <a href=#LExtract>Extract</a>
      <a href=#LHead>Head</a>
      <a href=#LLength>Length</a>
      <a href=#LList>List</a>
      <a href=#LPart>Part</a>
   <a href=#Ldefining-functions>defining-functions</a>
   <a href=#Ldynamics>dynamics</a>
      <a href=#Lindependent-variable>independent-variable</a>
      <a href=#LLagrangean>Lagrangean</a>
      <a href=#LHamiltonian>Hamiltonian</a>
         <a href=#L2nd-order-Hamiltonian>2nd-order-Hamiltonian</a>
            <a href=#Lsolution-H2>solution-H2</a>
            <a href=#Lsolution-dH>solution-dH</a>
      <a href=#Lremarks-on-dynamics>remarks-on-dynamics</a>
      <a href=#Lx-y-coupling>x-y-coupling</a>
      <a href=#Lextended-Twiss-parameters>extended-Twiss-parameters</a>
         <a href=#Ldefinitions>definitions</a>
      <a href=#Lsynchrotron-radiation>synchrotron-radiation</a>
      <a href=#Lequilibrium-beam-envelope>equilibrium-beam-envelope</a>
   <a href=#LDISPLAY(DISP)>DISPLAY(DISP)</a>
      <a href=#LACCELERATION(A)>ACCELERATION(A)</a>
      <a href=#LALL>ALL</a>
      <a href=#LBEAM(B)>BEAM(B)</a>
      <a href=#LDREFERENCE(DRE)>DREFERENCE(DRE)</a>
      <a href=#LDUMPOPTICS(D)>DUMPOPTICS(D)</a>
      <a href=#LGAMMA(GA)>GAMMA(GA)</a>
      <a href=#LGEOMETRY(G)>GEOMETRY(G)</a>
      <a href=#LOGEOMETRY(OG)>OGEOMETRY(OG)</a>
      <a href=#LORBIT(O)>ORBIT(O)</a>
      <a href=#Lpattern-string>pattern-string</a>
      <a href=#LPHYSICAL(P)>PHYSICAL(P)</a>
      <a href=#Lregion>region</a>
      <a href=#LREFERENCE(RE)>REFERENCE(RE)</a>
      <a href=#LRMATRIX(R)>RMATRIX(R)</a>
      <a href=#LZ>Z</a>
   <a href=#LDRAW>DRAW</a>
      <a href=#LDraw$Option>Draw$Option</a>
   <a href=#LDUMP>DUMP</a>
   <a href=#Lelements>elements</a>
      <a href=#LAPERT>APERT</a>
      <a href=#LBEND>BEND</a>
         <a href=#LAE1>AE1</a>
         <a href=#LAE2>AE2</a>
         <a href=#LANGLE>ANGLE</a>
         <a href=#LDISFRIN>DISFRIN</a>
         <a href=#LDISRAD>DISRAD</a>
         <a href=#LDROTATE>DROTATE</a>
         <a href=#LDX>DX</a>
         <a href=#LDY>DY</a>
         <a href=#LE1>E1</a>
         <a href=#LE2>E2</a>
         <a href=#LF1>F1</a>
         <a href=#LFB1>FB1</a>
         <a href=#LFB2>FB2</a>
         <a href=#LFRINGE>FRINGE</a>
         <a href=#LK0>K0</a>
         <a href=#LK1>K1</a>
         <a href=#LL>L</a>
         <a href=#LROTATE>ROTATE</a>
         <a href=#Ltransformation:BEND>transformation:BEND</a>
      <a href=#LCAVI>CAVI</a>
         <a href=#LDISFRIN>DISFRIN</a>
         <a href=#LDPHI>DPHI</a>
         <a href=#LDVOLT>DVOLT</a>
         <a href=#LDX>DX</a>
         <a href=#LDY>DY</a>
         <a href=#LFREQ>FREQ</a>
         <a href=#LHARM>HARM</a>
         <a href=#LL>L</a>
         <a href=#LPHI>PHI</a>
         <a href=#LROTATE>ROTATE</a>
         <a href=#LV02>V02</a>
         <a href=#LV1>V1</a>
         <a href=#LV11>V11</a>
         <a href=#LVOLT>VOLT</a>
      <a href=#LCOORD>COORD</a>
      <a href=#Ldefault-keyword>default-keyword</a>
      <a href=#LDECA>DECA</a>
         <a href=#LDISFRIN>DISFRIN</a>
         <a href=#LDISRAD>DISRAD</a>
         <a href=#LDX>DX</a>
         <a href=#LDY>DY</a>
         <a href=#LK4>K4</a>
         <a href=#LL>L</a>
         <a href=#LROTATE>ROTATE</a>
         <a href=#Ltransformation:THIN>transformation:THIN</a>
      <a href=#LDODECA>DODECA</a>
         <a href=#LDISFRIN>DISFRIN</a>
         <a href=#LDISRAD>DISRAD</a>
         <a href=#LDX>DX</a>
         <a href=#LDY>DY</a>
         <a href=#LK5>K5</a>
         <a href=#LL>L</a>
         <a href=#LROTATE>ROTATE</a>
         <a href=#Ltransformation:THIN>transformation:THIN</a>
      <a href=#LDRIFT>DRIFT</a>
         <a href=#LL>L</a>
         <a href=#LRADIUS>RADIUS</a>
         <a href=#Ltransformation:DRIFT>transformation:DRIFT</a>
      <a href=#Lkeywords>keywords</a>
      <a href=#LMARK>MARK</a>
         <a href=#LOFFSET>OFFSET</a>
      <a href=#LMULT>MULT</a>
         <a href=#LK0>K0</a>
         <a href=#LSK0>SK0</a>
         <a href=#LK1>K1</a>
         <a href=#LSK1>SK1</a>
         <a href=#LK2>K2</a>
         <a href=#LSK2>SK2</a>
         <a href=#LK3>K3</a>
         <a href=#LSK3>SK3</a>
         <a href=#LK4>K4</a>
         <a href=#LSK4>SK4</a>
         <a href=#LK5>K5</a>
         <a href=#LSK5>SK5</a>
         <a href=#LK6>K6</a>
         <a href=#LSK6>SK6</a>
         <a href=#LK7>K7</a>
         <a href=#LSK7>SK7</a>
         <a href=#LK8>K8</a>
         <a href=#LSK8>SK8</a>
         <a href=#LK9>K9</a>
         <a href=#LSK9>SK9</a>
         <a href=#LK10>K10</a>
         <a href=#LSK10>SK10</a>
         <a href=#LK11>K11</a>
         <a href=#LSK11>SK11</a>
         <a href=#LK12>K12</a>
         <a href=#LSK12>SK12</a>
         <a href=#LK13>K13</a>
         <a href=#LSK13>SK13</a>
         <a href=#LK14>K14</a>
         <a href=#LSK14>SK14</a>
         <a href=#LK15>K15</a>
         <a href=#LSK15>SK15</a>
         <a href=#LK16>K16</a>
         <a href=#LSK16>SK16</a>
         <a href=#LK17>K17</a>
         <a href=#LSK17>SK17</a>
         <a href=#LK18>K18</a>
         <a href=#LSK18>SK18</a>
         <a href=#LK19>K19</a>
         <a href=#LSK19>SK19</a>
         <a href=#LK20>K20</a>
         <a href=#LSK20>SK20</a>
         <a href=#LK21>K21</a>
         <a href=#LSK21>SK21</a>
         <a href=#LAE1>AE1</a>
         <a href=#LAE2>AE2</a>
         <a href=#LANGLE>ANGLE</a>
         <a href=#LDISFRIN>DISFRIN</a>
         <a href=#LDISRAD>DISRAD</a>
         <a href=#LDPHI>DPHI</a>
         <a href=#LDVOLT>DVOLT</a>
         <a href=#LE1>E1</a>
         <a href=#LE2>E2</a>
         <a href=#LF1>F1</a>
         <a href=#LF2>F2</a>
         <a href=#LFB1>FB1</a>
         <a href=#LFB2>FB2</a>
         <a href=#LFREQ>FREQ</a>
         <a href=#LFRINGE>FRINGE</a>
         <a href=#LHARM>HARM</a>
         <a href=#LL>L</a>
         <a href=#Lmisalignments>misalignments</a>
         <a href=#Lmultipole_with_nonzero_ANGLE>multipole_with_nonzero_ANGLE</a>
         <a href=#LPHI>PHI</a>
         <a href=#LRADIUS>RADIUS</a>
         <a href=#LVOLT>VOLT</a>
      <a href=#LOCT>OCT</a>
         <a href=#LDISFRIN>DISFRIN</a>
         <a href=#LDISRAD>DISRAD</a>
         <a href=#LDX>DX</a>
         <a href=#LDY>DY</a>
         <a href=#LK3>K3</a>
         <a href=#LL>L</a>
         <a href=#LROTATE>ROTATE</a>
         <a href=#Ltransformation:THIN>transformation:THIN</a>
      <a href=#LQUAD>QUAD</a>
         <a href=#LDISFRIN>DISFRIN</a>
         <a href=#LDISRAD>DISRAD</a>
         <a href=#LDX>DX</a>
         <a href=#LDY>DY</a>
         <a href=#LF1>F1</a>
         <a href=#LF2>F2</a>
         <a href=#LFRINGE>FRINGE</a>
         <a href=#LK1>K1</a>
         <a href=#LL>L</a>
         <a href=#LROTATE>ROTATE</a>
         <a href=#Ltransformation:QUAD>transformation:QUAD</a>
      <a href=#LSEXT>SEXT</a>
         <a href=#LDISFRIN>DISFRIN</a>
         <a href=#LDISRAD>DISRAD</a>
         <a href=#LDX>DX</a>
         <a href=#LDY>DY</a>
         <a href=#LK2>K2</a>
         <a href=#LL>L</a>
         <a href=#LROTATE>ROTATE</a>
         <a href=#Ltransformation:THIN>transformation:THIN</a>
      <a href=#LSOL>SOL</a>
         <a href=#LBOUND>BOUND</a>
         <a href=#LBZ>BZ</a>
         <a href=#LDISFRIN>DISFRIN</a>
         <a href=#LDPX>DPX</a>
         <a href=#LDPY>DPY</a>
         <a href=#LDX>DX</a>
         <a href=#LDY>DY</a>
         <a href=#LF1>F1</a>
         <a href=#LGEO>GEO</a>
   <a href=#Lexpression>expression</a>
      <a href=#L(-)>(-)</a>
      <a href=#L(/)>(/)</a>
      <a href=#LAddTo(+=)>AddTo(+=)</a>
      <a href=#LAlternatives(|)>Alternatives(|)</a>
      <a href=#LAnd(&&)>And(&&)</a>
      <a href=#LApply (@@)>Apply (@@)</a>
      <a href=#LCompoundExpression(;)>CompoundExpression(;)</a>
      <a href=#LDecrement(--)>Decrement(--)</a>
      <a href=#LDivideBy(/=)>DivideBy(/=)</a>
      <a href=#LDot(.)>Dot(.)</a>
      <a href=#LEqual(==)>Equal(==)</a>
      <a href=#LFunction(&)>Function(&)</a>
      <a href=#LGreater(>)>Greater(>)</a>
      <a href=#LGreaterEqual(>= or =>)>GreaterEqual(>= or =>)</a>
      <a href=#LIncrement(++)>Increment(++)</a>
      <a href=#LLess(<)>Less(<)</a>
      <a href=#LLessEqual(<= or =<)>LessEqual(<= or =<)</a>
      <a href=#LList({})>List({})</a>
      <a href=#LMap (/@)>Map (/@)</a>
      <a href=#LMapAll(//@)>MapAll(//@)</a>
      <a href=#LMember(@)>Member(@)</a>
      <a href=#LMessageName(::)>MessageName(::)</a>
      <a href=#LNot(~)>Not(~)</a>
      <a href=#LOr(||)>Or(||)</a>
      <a href=#LPart([[]])>Part([[]])</a>
      <a href=#LPatternTest(?)>PatternTest(?)</a>
      <a href=#LPlus(+)>Plus(+)</a>
      <a href=#LPower(^)>Power(^)</a>
      <a href=#LRepeated(..)>Repeated(..)</a>
      <a href=#LRepeatedNull(...)>RepeatedNull(...)</a>
      <a href=#LReplaceAll(/.)>ReplaceAll(/.)</a>
      <a href=#LReplaceRepeated(//.)>ReplaceRepeated(//.)</a>
      <a href=#LRule(->)>Rule(->)</a>
      <a href=#LRuleDelayed(:>)>RuleDelayed(:>)</a>
      <a href=#LSameQ(===)>SameQ(===)</a>
      <a href=#LSequence([])>Sequence([])</a>
      <a href=#LSet(=)>Set(=)</a>
      <a href=#LSetDelayed(:=)>SetDelayed(:=)</a>
      <a href=#LStringJoin (//)>StringJoin (//)</a>
      <a href=#LSubtractFrom(-=)>SubtractFrom(-=)</a>
      <a href=#LTagSet(/:)>TagSet(/:)</a>
      <a href=#LTimes(*)>Times(*)</a>
      <a href=#LTimesBy(*=)>TimesBy(*=)</a>
      <a href=#LUnequal(<>)>Unequal(<>)</a>
      <a href=#LUnsameQ(<=>)>UnsameQ(<=>)</a>
      <a href=#LUnset(=.)>Unset(=.)</a>
   <a href=#LELSE>ELSE</a>
   <a href=#LELSEIF>ELSEIF</a>
   <a href=#LEMITTANCE(EMIT)>EMITTANCE(EMIT)</a>
   <a href=#LEND>END</a>
   <a href=#LENDIF>ENDIF</a>
   <a href=#LEXECUTE(EXEC)>EXECUTE(EXEC)</a>
   <a href=#LEXPAND>EXPAND</a>
   <a href=#Lflags>flags</a>
      <a href=#LABSW>ABSW</a>
      <a href=#LBIPOL>BIPOL</a>
      <a href=#LCALC4D>CALC4D</a>
      <a href=#LCALC6D>CALC6D</a>
      <a href=#LCELL>CELL</a>
      <a href=#LCMPLOT>CMPLOT</a>
      <a href=#LCOD>COD</a>
      <a href=#LCODPLOT>CODPLOT</a>
      <a href=#LCONV>CONV</a>
      <a href=#LCONVCASE>CONVCASE</a>
      <a href=#LDAMPONLY>DAMPONLY</a>
      <a href=#LDAPERT>DAPERT</a>
      <a href=#LDIFFRES>DIFFRES</a>
      <a href=#LECHO>ECHO</a>
      <a href=#LEMIOUT>EMIOUT</a>
      <a href=#LFFSPRMPT>FFSPRMPT</a>
      <a href=#LFIXSEED>FIXSEED</a>
      <a href=#LFLUC>FLUC</a>
      <a href=#LGAUSS>GAUSS</a>
      <a href=#LGEOCAL>GEOCAL</a>
      <a href=#LGEOFIX>GEOFIX</a>
      <a href=#LHALFRES>HALFRES</a>
      <a href=#LIDEAL>IDEAL</a>
      <a href=#LINS>INS</a>
      <a href=#LINTRA>INTRA</a>
      <a href=#LINTRES>INTRES</a>
      <a href=#LJITTER>JITTER</a>
      <a href=#LLOG>LOG</a>
      <a href=#LLOSSMAP>LOSSMAP</a>
      <a href=#LLWAKE>LWAKE</a>
      <a href=#LMOVESEED>MOVESEED</a>
      <a href=#LPHOTONS>PHOTONS</a>
      <a href=#LPOL>POL</a>
      <a href=#LPRSVCASE>PRSVCASE</a>
      <a href=#LPSPAC>PSPAC</a>
      <a href=#LQUIET>QUIET</a>
      <a href=#LRAD>RAD</a>
      <a href=#LRADCOD>RADCOD</a>
      <a href=#LRADLIGHT>RADLIGHT</a>
      <a href=#LRADPOL>RADPOL</a>
      <a href=#LRADTAPER>RADTAPER</a>
      <a href=#LREAL>REAL</a>
      <a href=#LRELW>RELW</a>
      <a href=#LRFSW>RFSW</a>
      <a href=#LRING>RING</a>
      <a href=#LSELFCOD>SELFCOD</a>
      <a href=#LSORG>SORG</a>
      <a href=#LSPAC>SPAC</a>
      <a href=#LSTABLE>STABLE</a>
      <a href=#LSUMRES>SUMRES</a>
      <a href=#LSUS>SUS</a>
      <a href=#LTRPT>TRPT</a>
      <a href=#LTWAKE>TWAKE</a>
      <a href=#LUNIFORM>UNIFORM</a>
      <a href=#LUNIPOL>UNIPOL</a>
      <a href=#LUNSTABLE>UNSTABLE</a>
      <a href=#LWSPAC>WSPAC</a>
   <a href=#Lfunctions>functions</a>
      <a href=#LData-Manipulation>Data-Manipulation</a>
         <a href=#LFit>Fit</a>
         <a href=#LFitEmit>FitEmit</a>
         <a href=#LFitGaussian>FitGaussian</a>
         <a href=#LNIntegrate>NIntegrate</a>
         <a href=#LPolynomialFit>PolynomialFit</a>
         <a href=#LSpline>Spline</a>
      <a href=#LDownhillSimplex>DownhillSimplex</a>
      <a href=#Lfunctional-operations>functional-operations</a>
         <a href=#LApply>Apply</a>
         <a href=#LCases>Cases</a>
         <a href=#LDeleteCases>DeleteCases</a>
         <a href=#LDifference>Difference</a>
         <a href=#LFixedPoint>FixedPoint</a>
         <a href=#LFixedPointList>FixedPointList</a>
         <a href=#Llevel-spec>level-spec</a>
         <a href=#LMap>Map</a>
         <a href=#LMapThread>MapThread</a>
         <a href=#LPosition>Position</a>
         <a href=#LScan>Scan</a>
         <a href=#LScanThread>ScanThread</a>
         <a href=#LSelectCases>SelectCases</a>
         <a href=#LSwitchCases>SwitchCases</a>
         <a href=#LThread>Thread</a>
      <a href=#LFFS-dedicated-functions>FFS-dedicated-functions</a>
         <a href=#LAccelerateParticles>AccelerateParticles</a>
         <a href=#LBeamMatrix>BeamMatrix</a>
         <a href=#LDynamicApertureSurvey>DynamicApertureSurvey</a>
         <a href=#LElement>Element</a>
            <a href=#Lkey-strings:Element>key-strings:Element</a>
         <a href=#LEmittance>Emittance</a>
         <a href=#LExternalMap>ExternalMap</a>
         <a href=#LFFS>FFS</a>
         <a href=#LFFS$SHOW>FFS$SHOW</a>
         <a href=#LFitValue>FitValue</a>
         <a href=#LFitWeight>FitWeight</a>
         <a href=#LGaussianCoulomb>GaussianCoulomb</a>
         <a href=#LGeoBase>GeoBase</a>
         <a href=#LLINE>LINE</a>
            <a href=#Lkey-strings:LINE>key-strings:LINE</a>
         <a href=#LOptimizeOptics>OptimizeOptics</a>
         <a href=#LOrbitGeo>OrbitGeo</a>
         <a href=#LRadiationField>RadiationField</a>
         <a href=#LRadiationSpectrum>RadiationSpectrum</a>
         <a href=#LSetElement>SetElement</a>
         <a href=#LSurvivedParticles>SurvivedParticles</a>
         <a href=#LSymplecticJ>SymplecticJ</a>
         <a href=#LSynchroBetaEmittance>SynchroBetaEmittance</a>
         <a href=#LTouschekLifetime>TouschekLifetime</a>
         <a href=#LTrackParticles>TrackParticles</a>
         <a href=#LTwiss>Twiss</a>
         <a href=#LVariableRange>VariableRange</a>
         <a href=#LVariableWeight>VariableWeight</a>
         <a href=#LWakeFunction>WakeFunction</a>
      <a href=#LGraphics>Graphics</a>
         <a href=#LBeamPlot>BeamPlot</a>
         <a href=#LColumnPlot>ColumnPlot</a>
         <a href=#LFitPlot>FitPlot</a>
         <a href=#LGeometryPlot>GeometryPlot</a>
         <a href=#LHistoPlot>HistoPlot</a>
         <a href=#LListContourPlot>ListContourPlot</a>
         <a href=#LListDensityPlot>ListDensityPlot</a>
         <a href=#LListPlot>ListPlot</a>
         <a href=#LOpticsPlot>OpticsPlot</a>
         <a href=#LPlot>Plot</a>
      <a href=#LInput/Output>Input/Output</a>
         <a href=#L$FORM>$FORM</a>
         <a href=#L$Input>$Input</a>
         <a href=#L$Output>$Output</a>
         <a href=#LClose>Close</a>
         <a href=#LOpenAppend>OpenAppend</a>
         <a href=#LOpenRead>OpenRead</a>
         <a href=#LOpenWrite>OpenWrite</a>
         <a href=#LPageWidth>PageWidth</a>
         <a href=#LPrint>Print</a>
         <a href=#LRead>Read</a>
         <a href=#LReadString>ReadString</a>
         <a href=#LStandardForm>StandardForm</a>
         <a href=#LStringToStream>StringToStream</a>
         <a href=#LWrite>Write</a>
         <a href=#LWriteString>WriteString</a>
      <a href=#LMultiprocessing>Multiprocessing</a>
         <a href=#LFork>Fork</a>
         <a href=#LOpenShared>OpenShared</a>
         <a href=#LShared>Shared</a>
         <a href=#LSharedSize>SharedSize</a>
      <a href=#LObject-oriented-programing>Object-oriented-programing</a>
         <a href=#LClass>Class</a>
      <a href=#LRandom-number-functions>Random-number-functions</a>
         <a href=#LRandom>Random</a>
         <a href=#LGaussRandom>GaussRandom</a>
         <a href=#LParabolaRandom>ParabolaRandom</a>
         <a href=#LSeedRandom>SeedRandom</a>
         <a href=#LListRandom>ListRandom</a>
      <a href=#LSystem-interface>System-interface</a>
         <a href=#LSystem>System</a>
         <a href=#LTemporaryName>TemporaryName</a>
      <a href=#LUtilities>Utilities</a>
         <a href=#LDateString>DateString</a>
         <a href=#LMemoryCheck>MemoryCheck</a>
         <a href=#LTimeUsed>TimeUsed</a>
         <a href=#LTiming>Timing</a>
         <a href=#LTracePrint>TracePrint</a>
   <a href=#LFIT>FIT</a>
   <a href=#LFITPOINTS(FITP)>FITPOINTS(FITP)</a>
   <a href=#LFIX>FIX</a>
   <a href=#LFREE>FREE</a>
      <a href=#Ldefault-keyword>default-keyword</a>
   <a href=#Lgeometric-functions>geometric-functions</a>
   <a href=#LGO>GO</a>
   <a href=#LIF>IF</a>
   <a href=#LINPUT(IN)>INPUT(IN)</a>
   <a href=#Lmachine-error-commands>machine-error-commands</a>
   <a href=#Lmatching-function-commands>matching-function-commands</a>
   <a href=#Lmulti-turn-tracking>multi-turn-tracking</a>
   <a href=#LMATRIX(MAT)>MATRIX(MAT)</a>
   <a href=#LMEASURE(MEA)>MEASURE(MEA)</a>
   <a href=#Loff-momentum-matching>off-momentum-matching</a>
   <a href=#Loptical-functions>optical-functions</a>
   <a href=#LORG>ORG</a>
   <a href=#LOUTPUT(OUT)>OUTPUT(OUT)</a>
   <a href=#Lpattern>pattern</a>
      <a href=#LMatchQ>MatchQ</a>
   <a href=#Lphysical-constants>physical-constants</a>
   <a href=#LPRINT(PRI)>PRINT(PRI)</a>
   <a href=#LQUIT>QUIT</a>
   <a href=#LRADINT>RADINT</a>
   <a href=#LREAD>READ</a>
   <a href=#LRECOVER(REC)>RECOVER(REC)</a>
   <a href=#LREFERENCE(REF)>REFERENCE(REF)</a>
      <a href=#Lreference-optics>reference-optics</a>
   <a href=#LREJECT(REJ)>REJECT(REJ)</a>
   <a href=#LRENUMBER(RENUM)>RENUMBER(RENUM)</a>
   <a href=#LREPEAT(REP)>REPEAT(REP)</a>
   <a href=#LRESET>RESET</a>
   <a href=#LRESUME(RES)>RESUME(RES)</a>
   <a href=#LREVERSE(REV)>REVERSE(REV)</a>
   <a href=#Lset-value-of-element>set-value-of-element</a>
      <a href=#Lkeywords>keywords</a>
      <a href=#Ldefault-keyword>default-keyword</a>
   <a href=#Lspecial-variables>special-variables</a>
      <a href=#L$Line>$Line</a>
      <a href=#LCASE>CASE</a>
      <a href=#LCHARGE>CHARGE</a>
      <a href=#LCONVERGENCE>CONVERGENCE</a>
      <a href=#LDAPWIDTH>DAPWIDTH</a>
      <a href=#LDP>DP</a>
      <a href=#LDP0>DP0</a>
      <a href=#LDTSYNCH>DTSYNCH</a>
      <a href=#LEFFRFFREQ>EFFRFFREQ</a>
      <a href=#LEFFVC>EFFVC</a>
      <a href=#LEFFVCRATIO>EFFVCRATIO</a>
      <a href=#LElementValues>ElementValues</a>
      <a href=#LEMITX>EMITX</a>
      <a href=#LEMITXE>EMITXE</a>
      <a href=#LEMITY>EMITY</a>
      <a href=#LEMITYE>EMITYE</a>
      <a href=#LEMITZ>EMITZ</a>
      <a href=#LEMITZE>EMITZE</a>
      <a href=#LExponentOfResidual>ExponentOfResidual</a>
      <a href=#LFFS$NumericalDerivative>FFS$NumericalDerivative</a>
      <a href=#LFitFunction>FitFunction</a>
      <a href=#LFSHIFT>FSHIFT</a>
      <a href=#LGCUT>GCUT</a>
      <a href=#LInitialOrbits>InitialOrbits</a>
      <a href=#LLOSSAMPL>LOSSAMPL</a>
      <a href=#LLOSSDZ>LOSSDZ</a>
      <a href=#LMatchingAmplitude>MatchingAmplitude</a>
      <a href=#LMatchingResidual>MatchingResidual</a>
      <a href=#LMASS>MASS</a>
      <a href=#LMINCOUP>MINCOUP</a>
      <a href=#LMOMENTUM>MOMENTUM</a>
      <a href=#LNBUNCH>NBUNCH</a>
      <a href=#LNetResidual>NetResidual</a>
      <a href=#LNP>NP</a>
      <a href=#LNPARA>NPARA</a>
      <a href=#LOffMomentumWeight>OffMomentumWeight</a>
      <a href=#LOMEGA0>OMEGA0</a>
      <a href=#LOpticsEpilog>OpticsEpilog</a>
      <a href=#LOpticsProlog>OpticsProlog</a>
      <a href=#LPBUNCH>PBUNCH</a>
      <a href=#LPhotonList>PhotonList</a>
      <a href=#LPHICAV>PHICAV</a>
      <a href=#LSIGE>SIGE</a>
      <a href=#LSIGZ>SIGZ</a>
      <a href=#LSpeedOfLight>SpeedOfLight</a>
      <a href=#LStabilityLevel>StabilityLevel</a>
      <a href=#LTITLE>TITLE</a>
   <a href=#LSAVE>SAVE</a>
   <a href=#LSEED>SEED</a>
   <a href=#LSHOW>SHOW</a>
   <a href=#LSPLIT>SPLIT</a>
   <a href=#LSTATUS(STAT)>STATUS(STAT)</a>
   <a href=#LSTOP>STOP</a>
   <a href=#LSUSPEND(SUSP)>SUSPEND(SUSP)</a>
   <a href=#LTERMINATE(TERM)>TERMINATE(TERM)</a>
   <a href=#LTYPE(T)>TYPE(T)</a>
   <a href=#LUNTIL>UNTIL</a>
   <a href=#LUSE>USE</a>
   <a href=#LVARIABLES(VAR)>VARIABLES(VAR)</a>
   <a href=#LVARY>VARY</a>
   <a href=#LVISIT>VISIT</a>
   <a href=#Lwildcards>wildcards</a>
</pre><hr>
<h3><a name=L > </a></h3>
<pre></pre>
<h3><a name=LABORT>ABORT</a></h3>
<pre>Terminates SAD immediately.</pre>
<pre>See also:
 <a href=#LSTOP>STOP</a> <a href=#LQUIT>QUIT</a> <a href=#LSAVE>SAVE</a> <a href=#LUSE>USE</a> <a href=#LVISIT>VISIT</a> <a href=#LBYE>BYE</a></pre>
<h3><a name=LAPPEND(APP)>APPEND(APP)</a></h3>
<pre>APP {filename | file-number} switches the output stream to the specified file or the file number.
The output is appended to the existing file.</pre>
<pre>See also:
 <a href=#LTERMINATE(TERM)>TERMINATE(TERM)</a> <a href=#LCLOSE(CLO)>CLOSE(CLO)</a> <a href=#LINPUT(IN)>INPUT(IN)</a> <a href=#LREAD>READ</a> <a href=#LOUTPUT(OUT)>OUTPUT(OUT)</a>
 <a href=#LEND>END</a></pre>
<h3><a name=LATTRIBUTE(ATTR)>ATTRIBUTE(ATTR)</a></h3>
<pre>Usage: ATTR element-pattern

prints out the current value, minimum and maximum values, COUPLEd element and its coefficient for
elements which match the element-pattern.</pre>
<pre>See also:
 <a href=#LCOUPLE(COUP)>COUPLE(COUP)</a> <a href=#Lset-value-of-element>set-value-of-element</a> <a href=#Lwildcards>wildcards</a></pre>
<h3><a name=Lbeam-line>beam-line</a></h3>
<pre> A beam line is defined in the MAIN level by LINE command as:

   LINE a = ( [n1*][-]l1 [ [n2*]l2 ...] ) [b = ( ... )];

where l1, l2 are either an element or a line. n1, n2 are positive integers to repeat the same element.
An optional negative sign in fromt of element means the negative orientation of the element of the
line. A negative orientation of a line is inherited by its elements.
 The first element of a beam line must be a MARK element, if it is used by FFS, USE, VISIT.
 Please do not confuse the LINE command in the MAIN level with the LINE function in FFS.
 A beam line can be accessed within FFS via beam-line-functions as shown below.</pre>
<pre>See also:
 <a href=#Lelements>elements</a> <a href=#Lorientation-of-an-element>orientation-of-an-element</a> <a href=#LUSE>USE</a> <a href=#LVISIT>VISIT</a></pre>
<ul>
<li><h3><a name=Lbeam-line-functions>beam-line-functions</a></h3>
<pre>Functions/objects to construct/edit beam lines and elements in FFS.</pre>
<ul>
<li><h3><a name=LBeamLine>BeamLine</a></h3>
<pre>Usage: BeamLine[e1, e2, ...];

where e1, e2 has a form of

   [ - ][ n* ] x ,

with x being one of

1) a name (either a symbol or a character string) of an element defined in MAIN.
2) a name (either a symbol or a character string) of a LINE defined in MAIN.
3) a BeamLine object.

An optional negative sign specifies the direction and a number n the repetition number in the same
way as MAIN. A BeamLine object is automatically expanded to the lowest level whenever it is evaluated.
Editing of BeamLine can be done using any List-handling functions such as Join, Insert, Delete, etc.
of FFS.

 A BeamLine object can be used for FFS calculation when it is used as the
argument of USE or VISIT commands:

Examples:
1) USE BeamLine[IP,QF,QD]
2) aaa=ExtractBeamLine[];
   USE Join[aaa,-aaa]

 In these cases the new beam line becomes a new LINE in the MAIN level, with a name which is created
automatically.</pre>
<pre>See also:
 <a href=#LExtractBeamLine>ExtractBeamLine</a> <a href=#LPrintBeamLine>PrintBeamLine</a> <a href=#LWriteBeamLine>WriteBeamLine</a> <a href=#Lorientation-of-an-element>orientation-of-an-element</a>
 <a href=#LUSE>USE</a> <a href=#LVISIT>VISIT</a></pre>
<li><h3><a name=LBeamLineName>BeamLineName</a></h3>
<pre>BeamLineName[] returns the name of the current beam line. If a BeamLine object is used by USE or
VISIT, the new beam line becomes a new LINE in the MAIN level, with a name which is created automatically.</pre>
<li><h3><a name=LExtractBeamLine>ExtractBeamLine</a></h3>
<pre>Usage: ExtractBeamLine[line]

returns a BeamLine object which represents the expanded form of line which has been defined in MAIN.
If line is omitted, the current line is assumed.</pre>
<pre>See also:
 <a href=#LBeamLine>BeamLine</a> <a href=#LPrintBeamLine>PrintBeamLine</a> <a href=#LWriteBeamLine>WriteBeamLine</a> <a href=#LUSE>USE</a> <a href=#LVISIT>VISIT</a></pre>
<li><h3><a name=LPrintBeamLine>PrintBeamLine</a></h3>
<pre>Usage: PrintBeamLine[b1,.. ,option]

writes the BeamLine b1,.. to stdout. If b1.. is omitted the current beam line is assumed. If Format->"MAIN"
is given, it writes in the MAIN-input format. If Name->{name1,..} is given, names of BeamLines are
also written. The number of Name must be not smaller than number of BeamLines.</pre>
<pre>See also:
 <a href=#LBeamLine>BeamLine</a> <a href=#LExtractBeamLine>ExtractBeamLine</a> <a href=#LWriteBeamLine>WriteBeamLine</a> <a href=#LUSE>USE</a> <a href=#LVISIT>VISIT</a></pre>
<li><h3><a name=LWriteBeamLine>WriteBeamLine</a></h3>
<pre>Usage: WriteBeamLine[f, b1,.. ,option]

writes the BeamLine b1,.. to file f. If b1.. is omitted the current beam line is assumed. If Format->"MAIN"
is given, it writes in the MAIN-input format. If Name->{name1,..} is given, names of BeamLines are
also written. The number of Name must be not smaller than number of BeamLines.</pre>
<pre>See also:
 <a href=#LBeamLine>BeamLine</a> <a href=#LExtractBeamLine>ExtractBeamLine</a> <a href=#LPrintBeamLine>PrintBeamLine</a> <a href=#LUSE>USE</a> <a href=#LVISIT>VISIT</a></pre>
</ul>
<li><h3><a name=Lorientation-of-an-element>orientation-of-an-element</a></h3>
<pre> An element with negative orientation means a reversal of the element along the z-axis. Thus all
magnets except for a solenoid does not change the polarity. A solenoid changes the polarity. An RF
cavity should change, however, it does not in the current implementation. The edge angles and fringe
parameters of the entrance and the exit swap.
 AX, AY, AZ, EPX, EPY, ZPX, ZPY, R2, R3 of a MARK element are reversed.
 The orientation is printed out by DISP. It can be accessed by LINE["DIR"] . </pre>
<pre>See also:
 <a href=#Lbeam-line>beam-line</a> <a href=#LBeamLine>BeamLine</a> <a href=#LLINE>LINE</a></pre>
</ul>
<h3><a name=LBEAMSIZE(BEAM)>BEAMSIZE(BEAM)</a></h3>
<pre>Calculate the beam size with the current Twiss parameters. The calculation is in 5D and not correct
if the synchrotron motion is significant. Use EMITTANCE(EMIT) with CODPLOT for a 6D calculation.</pre>
<pre>See also:
 <a href=#LDISPLAY(DISP)>DISPLAY(DISP)</a> <a href=#LEMITTANCE(EMIT)>EMITTANCE(EMIT)</a> <a href=#LCODPLOT>CODPLOT</a></pre>
<h3><a name=LBYE>BYE</a></h3>
<pre>Exits from the current beam line and returns to the original beam line where VISIT command was issued.
All information specific to the beam line, such as matching conditions are restored.
   Note that BYE does neither SAVE the values of elements of the leaving beam line, nor RESET the
values of elements of the returning beam line.</pre>
<pre>See also:
 <a href=#LVISIT>VISIT</a> <a href=#LUSE>USE</a> <a href=#LSAVE>SAVE</a> <a href=#LRESET>RESET</a> <a href=#LSTOP>STOP</a> <a href=#LQUIT>QUIT</a> <a href=#LABORT>ABORT</a></pre>
<h3><a name=Lcharacter-string>character-string</a></h3>
<pre> A character-string is expressed by enclosing in "". Special characters are expressed using \:

\n     new line
\r     carriage return
\t     tab
\"     double quote
\\     backslash
\nnn   a character whose octal code is nnn.

 If a character-string is written over multiple lines, \ must be placed at the end of each line.
 The length of a character-string is limited to 2^31-1.</pre>
<ul>
<li><h3><a name=LFromCharacterCode>FromCharacterCode</a></h3>
<pre> FromCharacterCode[r_Real] returns a character whose character code is r.
 FromCharacterCode[l_List] returns a character-string whose character codes are l.</pre>
<pre>See also:
 <a href=#LToCharacterCode>ToCharacterCode</a></pre>
<li><h3><a name=LStringFill>StringFill</a></h3>
<pre> StringFill[s, sf, n]  with strings s and sf, n > 0, returns (s//sf//sf...)[1,n] .
 StringFill[s, sf, -n] with strings s and sf, n > 0, returns (...sf//sf//s)[-n,-1] .</pre>
<pre>See also:
 <a href=#LStringJoin>StringJoin</a> <a href=#LStringJoin (//)>StringJoin (//)</a> <a href=#LStringPart>StringPart</a></pre>
<li><h3><a name=LStringJoin>StringJoin</a></h3>
<pre> StringJoin[s1, s2, [,s3...]] ===> s1 // s2 [//s3...] concatenates strings s1, s2 [,s3...].</pre>
<pre>See also:
 <a href=#LStringJoin (//)>StringJoin (//)</a></pre>
<li><h3><a name=LStringLength>StringLength</a></h3>
<pre> StringLength[s] returns the length of string s.</pre>
<li><h3><a name=LStringMatchQ>StringMatchQ</a></h3>
<pre> StringMatchQ[s, spat] returns True/False whether string s matches string-patten spat.</pre>
<pre>See also:
 <a href=#Lwildcards>wildcards</a></pre>
<li><h3><a name=LStringPart>StringPart</a></h3>
<pre> s_String[n]      returns the n-th character in s.
 s_String[n1, n2] returns the substring from n1-th through n2-th characters of s.

 If n1, n2 are negative, they count from the end of the string.</pre>
<li><h3><a name=LStringPosition>StringPosition</a></h3>
<pre> StringPosition[s, subs] returns a list of positions of subs in string s.
 StringPosition[s, subs, n] returns a list of first n positions of subs in string s.

Example: StringPosition["abcbcbcbcb","bcb"] returns {{2,4},{4,6},{6,8},{8,10}}.</pre>
<li><h3><a name=LStringReplace>StringReplace</a></h3>
<pre> StringReplace[s, rules] replaces the parts of string s accoding to rules, which is a Rule or a list
of Rules:

   StringReplace["abcbcbcbc","bcb"->"xyx"] ===> "axyxcxyxc"
   StringReplace["abcbcbcbc",{"bcb"->"xy","cbc"->"pqrs"}] ===> "axypqrsbc" .</pre>
<li><h3><a name=LStringTrim>StringTrim</a></h3>
<pre> StringTrim[s] removes the leading and trailing spaces and tabs from s.</pre>
<li><h3><a name=LSymbol>Symbol</a></h3>
<pre> Symbol[s] returns a Symbol whose name is character-string s.</pre>
<li><h3><a name=LToCharacterCode>ToCharacterCode</a></h3>
<pre> ToCharacterCode[s] returns the list of character codes of character-string s.</pre>
<pre>See also:
 <a href=#LFromCharacterCode>FromCharacterCode</a></pre>
<li><h3><a name=LToExpression>ToExpression</a></h3>
<pre> ToExpression[s] converts a character-string s to an expression and evaluate it.</pre>
<pre>See also:
 <a href=#LToString>ToString</a></pre>
<li><h3><a name=LToString>ToString</a></h3>
<pre> ToString[expr] evaluates an expression expr, then converts to a character-string.
 ToString[expr, [FormatType ->] form [, form1...]] converts expr using one or more formats form [,form1...].
Available formats are:

                   
InputForm          special characters are quoted with \.
HoldForm           converts expr without evaluation.
StandardForm       converts with the standard number format and PageWidth.
GenelicSymbolForm  do not display the generation ($nnn) of local symbols for Module.</pre>
<pre>See also:
 <a href=#L$FORM>$FORM</a> <a href=#LPageWidth>PageWidth</a> <a href=#LStandardForm>StandardForm</a> Module <a href=#LToExpression>ToExpression</a></pre>
</ul>
<h3><a name=Lcommand-syntax>command-syntax</a></h3>
<pre>The command syntax in FFS is

     expression1 [param1..] [;] expression2..

     
(1)  The input is first evaluated as an expression. If the expression returns a Symbol with the same
     name as the expression itself, it is interpreted as an FFS command, otherwise the returned value
     is printed out unless it is Null.
(2)  Each command takes succeeding its parameters if necessary. A command with indefinite number
     of parameters can be terminated by semicolon. Most commands terminate itself at the end of line.
(3)  A line can be continued to the next line if a backslash is placed at the end of the line.
(4)  An expression continues to the next line if it is not closed in the line.
(5)  An exclamation mark comments out the rest of the line.

Example: A command line

          QF* .1

means the set-value-of-element command as unless the symbol QF has been defined otherwise. If QF
has been defines as a number, such as QF=2.5, the above command line is interpreted as Times[QF,.1]
then returns .25 .</pre>
<pre>See also:
 <a href=#Lexpression>expression</a> <a href=#Lfunctions>functions</a></pre>
<h3><a name=Lcomponents>components</a></h3>
<pre>Components are the objects which consist the beam line. A component simulates an individual magnet,
drift space, or rf-cavity. The parameters of a component is specified the values in the corresponding
element with the same name as the component, which simulates a power supply. Many components can
be attached to the same element. Parameters of each component may deviate from the corresponding
element if machine errors are given.
   A component is specified with the form name[.order][{+-}offset], where name is the name of the
component. The number order means the order-th component which belongs to name element, counted from
the beginning of the line starting from 1. Offset is a positive or negative number to specify the
downstream or upstream components from the given component. If order is omitted, the first element
is assumed, and if offset is omitted, zero is assumed. The order can be renumbererd by RENUMBER(RENUM).

  The end of line is specified by $$$. The first component can be specified by ^^^.</pre>
<pre>See also:
 <a href=#Lelements>elements</a> <a href=#LRENUMBER(RENUM)>RENUMBER(RENUM)</a></pre>
<h3><a name=Lconstants>constants</a></h3>
<pre>There are pre-defined special symbols for constants in FFS:

symbol         value
True           1
False          0
Infinity       INF
INF            INF
NaN            NaN
Pi             ArcSin[1]*2
E              Exp[1]
I              Complex[0,1]
Degree         Pi/180
GoldenRatio    (1+Sqrt[5])/2
EulerGamma     0.57721566490153286061</pre>
<pre>See also:
 <a href=#Lspecial-variables>special-variables</a> <a href=#Lphysical-constants>physical-constants</a> <a href=#Lflags>flags</a> <a href=#Lexpression>expression</a>
</pre>
<h3><a name=LCALCULATE(CAL)>CALCULATE(CAL)</a></h3>
<pre>Usage: (1) CAL [[NO]EXPAND]]
       (2) CAL matching-function1[-] [matching-function2[-]..]
 
(1) With no argument or with an option [NO]EXPAND, calculates the optics and the matching-functions
using the current values of the components. It prints out the values of the matching-functions specified
either by the matching-function-commands or the second usage of CAL, as described below. If an option
EXPAND is given(default), it expands the beam line before the calculation. If NOEXPAND is given,
it calculates without any expansion.   FFS["CAL"] and FFS["GO"] returns the result as a list, whose
format is

   {dp, kind, reslist, function-values},

where

          
dp:       a list contains dp/p0 .
kind:     a list of kind of the orbit (usually 0, but 1 to 6 for the finite amplitude matching, see
          MatchingAmplitude).
reslist:  a list of {residual, xstab, ystab}, where
       residual: matching residual,
       xstab:    True when the matrix is stable in X,
       ystab:    True when the matrix is stable in Y, for each orbit.

Above are lists with length nf (== number of orbits).

function-values: a list of length nc (== number of calculated items). Each element has the form:

       {component1, component2, function, list-of-values},

       where

       component1, component2: fit locations (see FIT).
       function: name of the function (see matching-function-commands).
       list-of-values: list of the value of the function for each orbit Length nf.
       The central orbit comes at the Floor[(n+1)/2]-th element.

(2) With matching-function names, sets the matching-functions at the current fit point to be printed

out after calculation. If the matching-function is followed by a minus sign, it suppresses the print-out.
\nExample:
CALC BX BY CAL</pre>
<pre>See also:
 <a href=#LGO>GO</a> <a href=#LDISPLAY(DISP)>DISPLAY(DISP)</a> <a href=#LCOUPLE(COUP)>COUPLE(COUP)</a> <a href=#LATTRIBUTE(ATTR)>ATTRIBUTE(ATTR)</a> <a href=#LSHOW>SHOW</a> <a href=#LFIT>FIT</a>
 <a href=#Lmatching-function-commands>matching-function-commands</a> <a href=#LEXPAND>EXPAND</a> <a href=#LCONV>CONV</a> <a href=#LCONVERGENCE>CONVERGENCE</a> <a href=#LMatchingResidual>MatchingResidual</a>
 <a href=#LFFS>FFS</a></pre>
<h3><a name=LCHROMATICITY(CHRO)>CHROMATICITY(CHRO)</a></h3>
<pre>CHRO prints out the chromaticity of QUAD and SEXT in the entire beam line using the simplest formula:


    xi_{x,y}=Integrate[-(K1/L) beta_{x,y}(s) ds] for QUAD,
     xi_{x,y}=Integrate[-(K2/L) eta_x (s) beta_{x,y}(s) ds] for SEXT.

These formula are not valid when there is x-y coupling or vertical dispersion.</pre>
<h3><a name=LCLOSE(CLO)>CLOSE(CLO)</a></h3>
<pre>   CLOSE [INPUT(IN)] closes the current input stream and switches it to the previous input stream.

  CLOSE OUTPUT(OUT) suspends the current output and switches it to the previous output stream.</pre>
<pre>See also:
 <a href=#LTERMINATE(TERM)>TERMINATE(TERM)</a> <a href=#LINPUT(IN)>INPUT(IN)</a> <a href=#LREAD>READ</a> <a href=#LOUTPUT(OUT)>OUTPUT(OUT)</a> <a href=#LAPPEND(APP)>APPEND(APP)</a>
 <a href=#LEND>END</a></pre>
<h3><a name=LCOUPLE(COUP)>COUPLE(COUP)</a></h3>
<pre>   Usage: COUP slave-element master-element coefficient

sets the value of the default-keyword of slave-element to be equal to coefficient times the value
of the default-keyword of master-element. COUPLE(COUP) cannot be cascaded. The master-element cannot
be COUPLEd to any other element. To reset COUPLE, say COUP slave-element slave-element 1.
 Consider ElementValues to define universal coupling for any keywords.</pre>
<pre>See also:
 <a href=#LATTRIBUTE(ATTR)>ATTRIBUTE(ATTR)</a> <a href=#LFREE>FREE</a> <a href=#LElementValues>ElementValues</a></pre>
<h3><a name=Ldata-structure>data-structure</a></h3>
<pre>All data and "programs" in SAD Script are expressed either by an atom or a list-structure:

   head[body1 [,body2...]]

where head and body1... are atom or list-structure. Defined atoms are:


Real     a real number
Symbol   a symbol
String   a character-string
Pattern  a pattern structure for argument matching

Currently the lengths of a list-structure, a character-string, and the name of a symbol are limited
to 2^31-1. A real number has an accuracy of 8 bytes.</pre>
<pre>See also:
 <a href=#Lcharacter-string>character-string</a> <a href=#Lpattern>pattern</a></pre>
<ul>
<li><h3><a name=LExtract>Extract</a></h3>
<pre>   Extract[f, part [,head]]

takes elements specified by part, which is a list of indices or Null. Optional head is applied at
each element before evaluation.

Example: Extract[{a,b,c,d,e},{3}]       returns c
         Extract[{a,b,c,d,e},{3,4}]     is an error
         Extract[{a,b,c,d,e},{{3},{4}}] returns {c,d}
         Extract[Hold[{a,b,c,d,e}],{1,3}, Hold] returns Hold[c]</pre>
<pre>See also:
 <a href=#LPart>Part</a></pre>
<li><h3><a name=LHead>Head</a></h3>
<pre>Head[f] takes the head of an expression f.</pre>
<li><h3><a name=LLength>Length</a></h3>
<pre> Length[f] returns the number of elements in the body of a structure f.</pre>
<li><h3><a name=LList>List</a></h3>
<pre> List is a special symbol to be the head of generic list-structure.
 List[a, b, c, ...] is represented as {a, b, c, ...}.
 A list is also used to represent a mathematical vector and matrices.
 Most of mathematical functions are operated at each element of a list.</pre>
<li><h3><a name=LPart>Part</a></h3>
<pre>  Part[f, a [,b ,...]] ===> f[[a, [,b ...]]]

takes the a-th element of structure f. f[[a, b]] is equivalent to f[[a]][[b]].
 If a is zero, it takes the head of f.
 if a is negative, f[[a]] os equivalent to f[[Length[f] + 1 + a]].
 If a is a list of Reals {a1, a2, ...}, f[[a]] returns {f[[a1]], f[[a2]], ...}.
 If a is Null, f[[,b]] is returns {f[[1,a]], ..., f[[Length[f], b]]}.</pre>
<pre>See also:
 <a href=#LLength>Length</a> <a href=#LHead>Head</a> <a href=#LExtract>Extract</a></pre>
</ul>
<h3><a name=Ldefining-functions>defining-functions</a></h3>
<pre> A function is defined by one of the following forms:

f[pat1 [,pat2...]] (:)= body;
f[pat1 [,pat2...]] ^(:)= body;
g/:f[pat1 [,pat2...]] (:)= body;

where pat1 [,pat2...] are patterns (including expressions).
 If UpSet(^=) or UpSetDelayed (^:=) is used, the definition is associated with the symbol in the
first level of l.h.s.
 If TagSet(/:) is used, the definition is associated with the symbol on the left of /: .

 The patters can be an expression including constants. The definition with constant arguments can
be accessed faster than searching a list, in general, so they are suitable for a data base. Definitions
with constant arguments have higher priorities than with patterns.</pre>
<pre>See also:
 UpSet UpSetDelayed <a href=#LTagSet(/:)>TagSet(/:)</a> <a href=#Lpattern>pattern</a></pre>
<h3><a name=Ldynamics>dynamics</a></h3>
<pre></pre>
<ul>
<li><h3><a name=Lindependent-variable>independent-variable</a></h3>
<pre><img  class="eqs" src="SADHelp_img/equ_1.svg" /></pre>
<pre>See also:
 <a href=#LLagrangean>Lagrangean</a> <a href=#LHamiltonian>Hamiltonian</a></pre>
<li><h3><a name=LLagrangean>Lagrangean</a></h3>
<pre><img  class="eqs" src="SADHelp_img/equ_2.svg" /></pre>
<pre>See also:
 <a href=#LHamiltonian>Hamiltonian</a> <a href=#Lindependent-variable>independent-variable</a></pre>
<li><h3><a name=LHamiltonian>Hamiltonian</a></h3>
<pre><img  class="eqs" src="SADHelp_img/equ_6.svg" /></pre>
<pre>See also:
 <a href=#LLagrangean>Lagrangean</a> <a href=#Lindependent-variable>independent-variable</a></pre>
<ul>
<li><h3><a name=L2nd-order-Hamiltonian>2nd-order-Hamiltonian</a></h3>
<pre><img  class="eqs" src="SADHelp_img/equ_18.svg" /></pre>
<pre>See also:
 <a href=#LHamiltonian>Hamiltonian</a> <a href=#Lremarks-on-dynamics>remarks-on-dynamics</a></pre>
<ul>
<li><h3><a name=Lsolution-H2>solution-H2</a></h3>
<pre><img  class="eqs" src="SADHelp_img/equ_20.svg" /></pre>
<pre>See also:
 <a href=#Lsolution-dH>solution-dH</a></pre>
<li><h3><a name=Lsolution-dH>solution-dH</a></h3>
<pre><img  class="eqs" src="SADHelp_img/equ_47.svg" /></pre>
<pre>See also:
 <a href=#Lsolution-H2>solution-H2</a></pre>
</ul>
</ul>
<li><h3><a name=Lremarks-on-dynamics>remarks-on-dynamics</a></h3>
<pre><img  class="eqs" src="SADHelp_img/equ_59.svg" /></pre>
<pre>See also:
 <a href=#LHamiltonian>Hamiltonian</a> <a href=#L2nd-order-Hamiltonian>2nd-order-Hamiltonian</a></pre>
<li><h3><a name=Lx-y-coupling>x-y-coupling</a></h3>
<pre><img  class="eqs" src="SADHelp_img/equ_60.svg" /></pre>
<pre>See also:
 <a href=#LDISPLAY(DISP)>DISPLAY(DISP)</a> <a href=#Loptical-functions>optical-functions</a> <a href=#Lmatching-function-commands>matching-function-commands</a>
</pre>
<li><h3><a name=Lextended-Twiss-parameters>extended-Twiss-parameters</a></h3>
<pre>A symplectic matrix such as the normal mode matrix can be expressed in terms of the extended Twiss
parameters. In 6 by 6 case, those are

   AX  BX          ZX  EX
     PSIX         ZPX EPX
   R1  R2  AY  BY  ZY  EY
   R3  R4    PSIY ZPY EPY
                   AZ  BZ
                     PSIZ .

A(X,Y,Z), B(X,Y,Z) are alphas and betas in the usual sense, after a diagonalization to 2 by 2 submatrices.
PSI(X,Y,Z) are the rotation angle to set one the coordinate to parallel to the (X,Y,Z) axes. R(1,2,3,4)
are the components of the x-y coupling matrix (see x-y-coupling). E(X,PX,Y,PY) are "dispersions"
which decouples synchro-beta coupling terms together with Z(X,PX,Y,PY). Those parameters should agree
with what FFS calculates in the case of no synchro-beta couplings.</pre>
<pre>See also:
 <a href=#Lx-y-coupling>x-y-coupling</a> <a href=#Loptical-functions>optical-functions</a></pre>
<ul>
<li><h3><a name=Ldefinitions>definitions</a></h3>
<pre><img  class="eqs" src="SADHelp_img/equ_68.svg" /></pre>
</ul>
<li><h3><a name=Lsynchrotron-radiation>synchrotron-radiation</a></h3>
<pre><img  class="eqs" src="SADHelp_img/equ_81.svg" /></pre>
<pre>See also:
 <a href=#LRAD>RAD</a> <a href=#LRADCOD>RADCOD</a> <a href=#LHamiltonian>Hamiltonian</a> <a href=#LBEND>BEND</a> <a href=#LF1>F1</a></pre>
<li><h3><a name=Lequilibrium-beam-envelope>equilibrium-beam-envelope</a></h3>
<pre><img  class="eqs" src="SADHelp_img/equ_85.svg" /></pre>
<pre>See also:
 <a href=#LEMITTANCE(EMIT)>EMITTANCE(EMIT)</a> <a href=#LEmittance>Emittance</a> <a href=#LINTRA>INTRA</a> <a href=#LWSPAC>WSPAC</a> <a href=#LMINCOUP>MINCOUP</a></pre>
</ul>
<h3><a name=LDISPLAY(DISP)>DISPLAY(DISP)</a></h3>
<pre>Usage: DISP_LAY [keywords] [pattern-string] [region]

Displays values of various optical-/geometric-functions at the components given by the pattern-string
in the region (see region) in the current beam line. It has several display modes specified by the
keywords. As the default, it displays AX, BX, NX, EX, EPX, AY, BY, NY, EY, EPY, LENG, the length
and the value of the default-keyword of the component. Each line refers to the entrance of each component
of the line. The end of the beam line has the name "$$$". The first component can be specified by
"^^^".
   DISP suspends the output to the terminal at every 66 lines, asking (q_uit, c_ontinue, a_ll)?.
The further output depends on the first character of the answer from the terminal input. This dialog
is suppressed by specifying ALL.
   DISP does not calculate the functions to be displayed, so CALCULATE(CALC) or GO is necessary whenever
values of components are updated.</pre>
<pre>See also:
 <a href=#LTYPE(T)>TYPE(T)</a> <a href=#Loptical-functions>optical-functions</a> <a href=#Lgeometric-functions>geometric-functions</a></pre>
<ul>
<li><h3><a name=LACCELERATION(A)>ACCELERATION(A)</a></h3>
<pre>DISP A displays the nominal energy, energy deviation(DDP), longitudinal position(z), and emittances
for a transport line with accelerating cavities. The flag TRPT must be on.</pre>
<pre>See also:
 <a href=#LTRPT>TRPT</a> <a href=#LRING>RING</a> <a href=#Lelements>elements</a> <a href=#LCAVI>CAVI</a> <a href=#Lspecial-variables>special-variables</a> <a href=#LEMITX>EMITX</a> <a href=#LEMITY>EMITY</a> <a href=#LDP>DP</a>
</pre>
<li><h3><a name=LALL>ALL</a></h3>
<pre>ALL is a word to choose the entire beam line for the region to be displayed. If ALL is given, a dialog
at every 66 lines to control the output to the terminal is suppressed. Thus "DISP ALL e1 e2" works
to suppress the dialog for the output region e1 from e2.</pre>
<pre>See also:
 <a href=#Lregion>region</a> <a href=#Lpattern-string>pattern-string</a></pre>
<li><h3><a name=LBEAM(B)>BEAM(B)</a></h3>
<pre>DISP B displays the beam sizes and the projected Twiss parameters calculated either by Twiss parameters
or the EMIT command with the CODPLOT flag.

Example: EMITX=...; EMITY=...;DP=...; 
         BEAMSIZE(BEAM)
         DISP B</pre>
<pre>See also:
 <a href=#LBEAMSIZE(BEAM)>BEAMSIZE(BEAM)</a> <a href=#LEMITTANCE(EMIT)>EMITTANCE(EMIT)</a> <a href=#LCODPLOT>CODPLOT</a> <a href=#LGAUSS>GAUSS</a> <a href=#LUNIFORM>UNIFORM</a> <a href=#Lspecial-variables>special-variables</a>
 <a href=#LEMITX>EMITX</a> <a href=#LEMITY>EMITY</a> <a href=#LDP>DP</a></pre>
<li><h3><a name=LDREFERENCE(DRE)>DREFERENCE(DRE)</a></h3>
<pre>Display the difference between the reference optics. (beta - betaR)/betaR are displayed for BX, BY,
BZ.</pre>
<pre>See also:
 <a href=#Lreference-optics>reference-optics</a> <a href=#LREFERENCE(REF)>REFERENCE(REF)</a> <a href=#LDISPLAY(DISP)>DISPLAY(DISP)</a> <a href=#LREFERENCE(RE)>REFERENCE(RE)</a>
 <a href=#LTwiss>Twiss</a> <a href=#LOpticsPlot>OpticsPlot</a></pre>
<li><h3><a name=LDUMPOPTICS(D)>DUMPOPTICS(D)</a></h3>
<pre>DISP D displays all matching-functions in one line suitable to be read by a spread-sheet program.</pre>
<pre>See also:
 <a href=#Loptical-functions>optical-functions</a> <a href=#Lgeometric-functions>geometric-functions</a> <a href=#Lmatching-function-commands>matching-function-commands</a>
</pre>
<li><h3><a name=LGAMMA(GA)>GAMMA(GA)</a></h3>
<pre>DISP GA displays gamma functions for x and y, instead of dispersions, as well as gamma*L, which is
nealry equal to the natural chromaticity.</pre>
<li><h3><a name=LGEOMETRY(G)>GEOMETRY(G)</a></h3>
<pre>DISP G displays geometric information of the beam line. It shows the geometry of the coordinate.</pre>
<pre>See also:
 <a href=#Lgeometric-functions>geometric-functions</a> <a href=#Lmatching-function-commands>matching-function-commands</a> <a href=#LOGEOMETRY(OG)>OGEOMETRY(OG)</a>
</pre>
<li><h3><a name=LOGEOMETRY(OG)>OGEOMETRY(OG)</a></h3>
<pre>DISP OG displays geometric information at the orbit.</pre>
<pre>See also:
 <a href=#Lgeometric-functions>geometric-functions</a> <a href=#Lmatching-function-commands>matching-function-commands</a> <a href=#LGEOMETRY(G)>GEOMETRY(G)</a>
</pre>
<li><h3><a name=LORBIT(O)>ORBIT(O)</a></h3>
<pre>DISP O displays the orbits DX, DPX, DY, DPY together with the other 
optical-functions.</pre>
<pre>See also:
 <a href=#Loptical-functions>optical-functions</a> <a href=#Lmatching-function-commands>matching-function-commands</a></pre>
<li><h3><a name=Lpattern-string>pattern-string</a></h3>
<pre>The components in the current region can be selectively displayed by the DISP command using the pattern-string.
The pattern-string is a character string involving the wildcards to match the name of the components.
Note that the components are chosen in the current region, and the keyword ALL is necessary to extend
it to the entire beam line.</pre>
<pre>See also:
 <a href=#LDISPLAY(DISP)>DISPLAY(DISP)</a> <a href=#Lwildcards>wildcards</a> <a href=#Lcomponents>components</a> <a href=#Lregion>region</a> <a href=#LALL>ALL</a></pre>
<li><h3><a name=LPHYSICAL(P)>PHYSICAL(P)</a></h3>
<pre>DISP P displays the physical dispersions PEX, PEPX, PEY, PEP, together with the 1D optical parameters.</pre>
<pre>See also:
 <a href=#Loptical-functions>optical-functions</a> <a href=#Lmatching-function-commands>matching-function-commands</a></pre>
<li><h3><a name=Lregion>region</a></h3>
<pre>Region for DISPLAY(DISP) is specified as 

        DISP .... begin [end] 

with begin and end having the form name[.order][{+-}offset], or the component number (see components).

Example:
  DISP ... QF.2-10 QD+5
           DISP ... 100 200

displays functions starting at 10 elements upstream from the entrance of the second QF through 5
elements downstream from the entrance of the first QD. The region for DISP is kept after once set.
It is shown in the second part of the prompt when FFSPRMPT is ON, and also seen by the STATUS(STAT)
command.
   If begin points to a component after end, DISP displays from begin to $$$, then from ^^^ to end.

  ALL can be specified before the region. In such a case, the dialog for the output control is suppressed.

  The components which match the pattern-string in DISP are only chosen in the current region.</pre>
<pre>See also:
 <a href=#LALL>ALL</a> <a href=#Lpattern-string>pattern-string</a> <a href=#Lcomponents>components</a> <a href=#LSTATUS(STAT)>STATUS(STAT)</a></pre>
<li><h3><a name=LREFERENCE(RE)>REFERENCE(RE)</a></h3>
<pre>Specify the reference optics to be displayed.</pre>
<pre>See also:
 <a href=#Lreference-optics>reference-optics</a> <a href=#LREFERENCE(REF)>REFERENCE(REF)</a> <a href=#LDISPLAY(DISP)>DISPLAY(DISP)</a> <a href=#LDREFERENCE(DRE)>DREFERENCE(DRE)</a>
 <a href=#LTwiss>Twiss</a> <a href=#LOpticsPlot>OpticsPlot</a></pre>
<li><h3><a name=LRMATRIX(R)>RMATRIX(R)</a></h3>
<pre>DISP R displays the components of the x-y coupling matrix R together with the 1D optical parameters.
See x-y-coupling.</pre>
<pre>See also:
 <a href=#Lx-y-coupling>x-y-coupling</a> <a href=#Loptical-functions>optical-functions</a> <a href=#Lmatching-function-commands>matching-function-commands</a>
</pre>
<li><h3><a name=LZ>Z</a></h3>
<pre>DISP Z displays muatching functions related to the Z plane: AZ BZ NZ DZ DDP ZX ZPX ZY ZPY GMZ , which
are obtained by CAL/GO with CALC6D.</pre>
<pre>See also:
 <a href=#Lextended-Twiss-parameters>extended-Twiss-parameters</a> <a href=#LCALC6D>CALC6D</a> <a href=#LCALC4D>CALC4D</a></pre>
</ul>
<h3><a name=LDRAW>DRAW</a></h3>
<pre>Usage: DRAW [begin end] fun1 [fun2..] [& fun11 [fun12..]] [element-pattern]

draws a plot of optical functions in multi columns. It calls OpticsPlot internally. Available functions
are all matching-functions (except LENG, TRX, TRY, GX, GY, GZ, CHI1, CHI2, CHI3) and additional functions.
If functions are separated by ampersand (&), these are plotted in a separated window.
  Function name preceded by "R" and "D" refer the reference optics and the difference, respectively.

 If begin- and end-components are specified, the plot region is limited between them. If the end-component
comes earlier than the begin-components, it wraps the plot around the beam line.
  If the optional element-pattern is given, it draws the beam-line lattice with the labels for elements
which match element-pattern. If LAT is specified for element-pattern, the lattice is drawn without
label.
 A character string assigned to TITLE is shown as the FrameLabel on the top of the plot.

 Example:
   TITLE="FCCee_t_202_nosol_16_ipac.sad";
   Draw$Option={Thickness->2};
   DRAW BX BY & EX EY Q*;

<img src="SADHelp_img/DRAW.png" align="middle" width=540>
</pre>
<pre>See also:
 <a href=#LOpticsPlot>OpticsPlot</a> <a href=#Lspecial-variables>special-variables</a> <a href=#LTITLE>TITLE</a> <a href=#Lmatching-function-commands>matching-function-commands</a>
 <a href=#LOUTPUT(OUT)>OUTPUT(OUT)</a> <a href=#LTERMINATE(TERM)>TERMINATE(TERM)</a> <a href=#LGEO>GEO</a> <a href=#LDISPLAY(DISP)>DISPLAY(DISP)</a> <a href=#Lwildcards>wildcards</a>
</pre>
<ul>
<li><h3><a name=LDraw$Option>Draw$Option</a></h3>
<pre>
 Draw$Option is a list of rules to specify Graphics options for the entire DRAW. If you need option
for each column, use OpticsPlot</pre>
<pre>See also:
 <a href=#LDRAW>DRAW</a> <a href=#LOpticsPlot>OpticsPlot</a> <a href=#LGraphics>Graphics</a> <a href=#LREFERENCE(REF)>REFERENCE(REF)</a></pre>
</ul>
<h3><a name=LDUMP>DUMP</a></h3>
<pre>Usage: DUMP component-pattern [component-pattern1..]

prints out the current machine errors of components which match component-pattern.</pre>
<pre>See also:
 <a href=#Lmachine-error-commands>machine-error-commands</a> <a href=#Lcomponents>components</a> <a href=#Lwildcards>wildcards</a></pre>
<h3><a name=Lelements>elements</a></h3>
<pre>An element in FFS represents an object which has a unique name and several keywords with values.
This simulates a power supply of a magnet. An element has one or more components, which correspond
to individual magnets in a beam line. Each component may have different values from the values of
the corresponding element. This simulates the machine error which varies magnet to magnet
   The value of an element can be saved to or recovered from the element-save-buffer by SAVE or RESET
commands. Different beam lines can share the same element, and their values can be different to each
other, but they have the common element-save-buffer. Therefore the value of an element can be transferred
between beam lines by SAVE and RESET command through the element-save-buffer.
   An element is created only in SAD MAIN level. In the definition, if a keyword is omitted, the
previous definition is unchanged. All keywords have the default value zero. In FFS, it is only possible
to change their values.</pre>
<pre>See also:
 <a href=#LTYPE(T)>TYPE(T)</a> <a href=#Lset-value-of-element>set-value-of-element</a> <a href=#LElement>Element</a></pre>
<ul>
<li><h3><a name=LAPERT>APERT</a></h3>
<pre>An aperture. Only valid in tracking. A particle with

<img  class="eqs" src="SADHelp_img/equ_87.svg" />

can pass through the aperture, otherwise it is lost and a message is printed out. If AX or AY is
zero (default), they are interpreted as infinity. If AX <=> 0 && AY <=> 0 and (DX1 == DX2 or DY1
== DY2) then the aperture is only determined by AX and AY.</pre>
<li><h3><a name=LBEND>BEND</a></h3>
<pre>A bending magnet.</pre>
<ul>
<li><h3><a name=LAE1>AE1</a></h3>
<pre>The absolute face angle at the entrance. The effective face angle is E1 * ANGLE + AE1, and a positive
angle at the entrance corresponds to a surface with dx/ds > 0.</pre>
<pre>See also:
 <a href=#LE1>E1</a> <a href=#LAE2>AE2</a> <a href=#LANGLE>ANGLE</a></pre>
<li><h3><a name=LAE2>AE2</a></h3>
<pre>The absolute face-angle at the exit to the bending angle. The effective face angle is E2 * ANGLE
+ AE2, and a positive angle at the exit corresponds to a surface with dx/ds < 0.</pre>
<pre>See also:
 <a href=#LE2>E2</a> <a href=#LAE1>AE1</a> <a href=#LANGLE>ANGLE</a></pre>
<li><h3><a name=LANGLE>ANGLE</a></h3>
<pre>The bending angle. If positive, it bends the orbit in x-s plane toward negative-x-direction. ANGLE
determines the geometry of the beam line, while K0 represents a dipole kick on top of the bending
angle given by ANGLE, i.e., the total deflection of the beam is given of ANGLE + K0.</pre>
<pre>See also:
 <a href=#LK0>K0</a></pre>
<li><h3><a name=LDISFRIN>DISFRIN</a></h3>
<pre>If nonzero, the nonlinear Maxwellian fringe is suppressed.</pre>
<li><h3><a name=LDISRAD>DISRAD</a></h3>
<pre>If nonzero, the synchrotron radiation in the particle-tracking is inhibited.</pre>
<pre>See also:
 <a href=#LRAD>RAD</a></pre>
<li><h3><a name=LDROTATE>DROTATE</a></h3>
<pre>Additional rotation in x-y plane to simulate a rotation error. DROTATE does not affect the geometry
of the ring.</pre>
<pre>See also:
 <a href=#LDX>DX</a> <a href=#LDY>DY</a> <a href=#LROTATE>ROTATE</a></pre>
<li><h3><a name=LDX>DX</a></h3>
<pre>Horizontal displacement of magnet. This applied before the rotation by ROTATE.</pre>
<pre>See also:
 <a href=#LDY>DY</a> <a href=#LROTATE>ROTATE</a> <a href=#LDROTATE>DROTATE</a></pre>
<li><h3><a name=LDY>DY</a></h3>
<pre>Vertical displacement of magnet. This applied before the rotation by ROTATE.</pre>
<pre>See also:
 <a href=#LDX>DX</a> <a href=#LROTATE>ROTATE</a> <a href=#LDROTATE>DROTATE</a></pre>
<li><h3><a name=LE1>E1</a></h3>
<pre>The ratio of the face-angle at the entrance to the bending angle. The effective face angle is E1
* ANGLE + AE1, and a positive angle at the entrance corresponds to a surface with dx/ds > 0. For
example, a symmetrically-placed rectangular magnet has
 E1 = 0.5 and E2 = 0.5.</pre>
<pre>See also:
 <a href=#LAE1>AE1</a> <a href=#LE2>E2</a> <a href=#LANGLE>ANGLE</a></pre>
<li><h3><a name=LE2>E2</a></h3>
<pre>The ratio of the face-angle at the exit to the bending angle. The effective face angle is E2 * ANGLE
+ AE2, and a positive angle at the exit corresponds to a surface with dx/ds < 0. For example, a symmetrically-placed
rectangular magnet has E1 = 0.5 and E2 = 0.5.</pre>
<pre>See also:
 <a href=#LAE2>AE2</a> <a href=#LE1>E1</a> <a href=#LANGLE>ANGLE</a></pre>
<li><h3><a name=LF1>F1</a></h3>
<pre>Length of the slope of the field at the edge as:

                By(s) |   *******
                      |  *
                      | *
                      |*
                      *
                     *|
                    * |
                   *  |
        ----*******---+--------- s
                  |       |
                  |<----->|
                  |   F1  |

Only the effects up to y^4 in Hamiltonian are taken into account. A more rigorous definition is

<img  class="eqs" src="SADHelp_img/equ_88.svg" />

where integration is done over one fringe.

   The transformation of the linear fringe of the entrance of a bend is

<img  class="eqs" src="SADHelp_img/equ_89.svg" />

where f is the length of fringe given by F1, and rhob bending radius at the design momentum. At the exit, the sign of rhob is chang
ed. This linear fringe also changes the path length in the body of the bend as

<img  class="eqs" src="SADHelp_img/equ_90.svg" />

to maintain the geometric position of the design orbit, i.e., you have to increase the bend field
a little bit to keep the orbit unchanged. Unlike a quadrupole, the effect of linear fringe is always
applied at both the entrance and the exit, otherwise you cannot obtain a circular design orbit.

   Use FB1 and FB2 to specify the values of entrance and exit separately.</pre>
<pre>See also:
 <a href=#LFRINGE>FRINGE</a> <a href=#LFB1>FB1</a> <a href=#LFB2>FB2</a></pre>
<li><h3><a name=LFB1>FB1</a></h3>
<pre>   F1 at the entrance. Actually F1 + FB1 is used at the entrance.</pre>
<pre>See also:
 <a href=#LF1>F1</a> <a href=#LFB2>FB2</a></pre>
<li><h3><a name=LFB2>FB2</a></h3>
<pre>   F1 at the exit. Actually F1 + FB2 is used at the exit.</pre>
<pre>See also:
 <a href=#LF1>F1</a> <a href=#LFB1>FB1</a></pre>
<li><h3><a name=LFRINGE>FRINGE</a></h3>
<pre>When FRINGE is non-zero, the effect of the linear fringe F1 is taken into account both at the entrance and the exit.
   The transformation of the linear fringe of the entrance of a bend is

<img  class="eqs" src="SADHelp_img/equ_89.svg" />

where f is the length of fringe given by F1, and rhob bending radius at the design momentum. At the exit, the sign of rhob is chang
ed. This linear fringe also changes the path length in the body of the bend as

<img  class="eqs" src="SADHelp_img/equ_90.svg" />

to maintain the geometric position of the design orbit, i.e., you have to increase the bend field
a little bit to keep the orbit unchanged. Unlike a quadrupole, the effect of linear fringe is always
applied at both the entrance and the exit, otherwise you cannot obtain a circular design orbit.

   Use FB1 and FB2 to specify the values of entrance and exit separately.</pre>
<pre>See also:
 <a href=#LF1>F1</a></pre>
<li><h3><a name=LK0>K0</a></h3>
<pre>The normal dipole magnetic field component (times the length L).

<img  class="eqs" src="SADHelp_img/equ_91.svg" />

where L is the effective length of the component. Positive sign means horizontal focusing.</pre>
<pre>See also:
 <a href=#LL>L</a></pre>
<li><h3><a name=LK1>K1</a></h3>
<pre>The normal quadrupole magnetic field component (times the length L).

<img  class="eqs" src="SADHelp_img/equ_92.svg" />

where L is the effective length of the component. Positive sign means horizontal focusing.</pre>
<pre>See also:
 <a href=#LL>L</a></pre>
<li><h3><a name=LL>L</a></h3>
<pre>The effective length along the arc of the orbit.</pre>
<li><h3><a name=LROTATE>ROTATE</a></h3>
<pre>Rotation in x-y plane. After displacing the magnet by DX and DY, rotate the magnet around the local
s-axis by -(amount given by ROTATE), then place the component. At the exit rotate back the magnet
around the local s-axis at the exit, then take out displacement.</pre>
<pre>See also:
 <a href=#LDX>DX</a> <a href=#LDY>DY</a> <a href=#LDROTATE>DROTATE</a></pre>
<li><h3><a name=Ltransformation:BEND>transformation:BEND</a></h3>
<pre>The transformation of a bend depends on the value of K1. If K1 is zero, it is a series of transformations:

    (transformation due to misalignments)
   (drift to the entrance face)
<img  class="eqs" src="SADHelp_img/equ_93.svg" />
   (linear fringe at entrance face)
<img  class="eqs" src="SADHelp_img/equ_94.svg" />
   (nonlinear fringe at entrance)
<img  class="eqs" src="SADHelp_img/equ_95.svg" />
   (body of bend)
<img  class="eqs" src="SADHelp_img/equ_96.svg" />
   (nonlinear fringe at exit)
<img  class="eqs" src="SADHelp_img/equ_97.svg" />
   (linear fringe at exit face)
<img  class="eqs" src="SADHelp_img/equ_98.svg" />
   (drift from the exit face)
<img  class="eqs" src="SADHelp_img/equ_99.svg" />
   (transformation due to misalignments)

If K1 is nonzero, the effects from E1 and E2 are approximated by thin
quadrupoles. Then the body is subdivided into

   1 + floor(sqrt(abs(K1 L')/(12 10^-5 EPS)))

pieces (EPS = 1 is used when EPS = 0), and the bend-body transformation above is done for each piece
and the kick from K1 is applied alternatively. In FFS optics and Emittance calculations, or when
the synchrotron radiation is turned on, the same algorithm as K1 <> 0 is applied.</pre>
<pre>See also:
 coordinates <a href=#Lequilibrium-beam-envelope>equilibrium-beam-envelope</a></pre>
</ul>
<li><h3><a name=LCAVI>CAVI</a></h3>
<pre>Accelerating structure.</pre>
<ul>
<li><h3><a name=LDISFRIN>DISFRIN</a></h3>
<pre>If nonzero, the Maxwellian fringe is suppressed. The effects of DISFRIN and FRINGE are summarized
as

             DISFRIN=0          DISFRIN<>0
FRINGE=0    entr & exit            none
FRINGE=1       entr                none
FRINGE=2       exit                none
FRINGE=3    entr & exit            none</pre>
<pre>See also:
 <a href=#LFRINGE>FRINGE</a></pre>
<li><h3><a name=LDPHI>DPHI</a></h3>
<pre> Relative phase offset. The stable synchrotron phase above the transition is near PHI = 0. The acceleration is given by 

<img  class="eqs" src="SADHelp_img/equ_100.svg" />

where ts is the equilibrium time determined by the valance between the acceleration and the radiation
loss around the ring. DPHI is not taken into account to determine the design momentum p0(s).</pre>
<pre>See also:
 <a href=#LFREQ>FREQ</a> <a href=#LVOLT>VOLT</a> <a href=#LDVOLT>DVOLT</a> <a href=#LV1>V1</a> V20 <a href=#LV11>V11</a></pre>
<li><h3><a name=LDVOLT>DVOLT</a></h3>
<pre>Additional accelerating voltage to be added to VOLT without affecting the design momentum.</pre>
<pre>See also:
 <a href=#LVOLT>VOLT</a></pre>
<li><h3><a name=LDX>DX</a></h3>
<pre>Horizontal displacement of magnet. This applied before the rotation by ROTATE.</pre>
<pre>See also:
 <a href=#LDY>DY</a> <a href=#LROTATE>ROTATE</a> <a href=#LDROTATE>DROTATE</a></pre>
<li><h3><a name=LDY>DY</a></h3>
<pre>Vertical displacement of magnet. This applied before the rotation by ROTATE.</pre>
<pre>See also:
 <a href=#LDX>DX</a> <a href=#LROTATE>ROTATE</a> <a href=#LDROTATE>DROTATE</a></pre>
<li><h3><a name=LFREQ>FREQ</a></h3>
<pre> Rf frequency. If this keyword is nonzero, the keyword HARM is ignored.
<img  class="eqs" src="SADHelp_img/equ_100.svg" /></pre>
<pre>See also:
 <a href=#LHARM>HARM</a></pre>
<li><h3><a name=LHARM>HARM</a></h3>
<pre> A harmonic number. This is valid only when FREQ is zero.</pre>
<pre>See also:
 <a href=#LFREQ>FREQ</a></pre>
<li><h3><a name=LL>L</a></h3>
<pre>The effective length.</pre>
<li><h3><a name=LPHI>PHI</a></h3>
<pre> Relative phase offset. The stable synchrotron phase above the transition is near PHI = 0. The acceleration is given by 

<img  class="eqs" src="SADHelp_img/equ_100.svg" />

where ts is the equilibrium time determined by the valance between the acceleration and the radiation
loss around the ring.</pre>
<pre>See also:
 <a href=#LFREQ>FREQ</a> <a href=#LVOLT>VOLT</a> <a href=#LDVOLT>DVOLT</a> <a href=#LV1>V1</a> V20 <a href=#LV11>V11</a></pre>
<li><h3><a name=LROTATE>ROTATE</a></h3>
<pre>Rotation in x-y plane. After displacing the magnet by DX and DY, rotate the magnet around the local
s-axis by -(amount given by ROTATE), then place the component. At the exit rotate back the magnet
around the local s-axis at the exit, then take out displacement.</pre>
<pre>See also:
 <a href=#LDX>DX</a> <a href=#LDY>DY</a> <a href=#LDROTATE>DROTATE</a></pre>
<li><h3><a name=LV02>V02</a></h3>
<pre> The y^2-dependence of the acceleration. Tracking only.
<img  class="eqs" src="SADHelp_img/equ_100.svg" /></pre>
<pre>See also:
 <a href=#LVOLT>VOLT</a> <a href=#LDVOLT>DVOLT</a> <a href=#LV1>V1</a> V20 <a href=#LV11>V11</a></pre>
<li><h3><a name=LV1>V1</a></h3>
<pre> The linear x-dependence of the acceleration. Tracking only.
<img  class="eqs" src="SADHelp_img/equ_100.svg" /></pre>
<pre>See also:
 <a href=#LVOLT>VOLT</a> <a href=#LDVOLT>DVOLT</a> <a href=#LV1>V1</a> <a href=#LV11>V11</a> <a href=#LV02>V02</a></pre>
<li><h3><a name=LV11>V11</a></h3>
<pre> The xy-dependence of the acceleration. Tracking only.
<img  class="eqs" src="SADHelp_img/equ_100.svg" /></pre>
<pre>See also:
 <a href=#LVOLT>VOLT</a> <a href=#LDVOLT>DVOLT</a> <a href=#LV1>V1</a> V20 <a href=#LV02>V02</a></pre>
<li><h3><a name=LVOLT>VOLT</a></h3>
<pre>Accelerating peak voltage in Volt.

<img  class="eqs" src="SADHelp_img/equ_100.svg" />

where ts is the equilibrium time determined by the valance between the acceleration and the radiation
loss around the ring. (CAVI only) The non-relativistic corrections

     (VOLT+DVOLT)*(2 Pi FREQ/c)^2/(gamma beta)^2/4 are

automatically added to V20 and V02, respectively. The Lorentz factor is evaluated as inverse of average
of 1/(beta gamma) at the entrance and the exit.
   CAVI includes the edge effect at the lowest order, given by a Hamiltonian at the entrance edge
at s0:

   Hf = - (e (VOLT+DVOLT)/L)(Sin(omega t - dphi) + Sin(dphi) - offset) (x^2+y^2)/4 delta(s-s0)
 where dphi and offset are determined by the cavity phase and the radiation loss, which is nonzero
only in the case of NORAD. The sign flips at the exit. This Hamiltonian should be consistent with
what Kiyoshi Kubo derived.</pre>
<pre>See also:
 <a href=#LDVOLT>DVOLT</a></pre>
</ul>
<li><h3><a name=LCOORD>COORD</a></h3>
<pre>An element for an arbitrary coordinate transformation. This element can be used to express an off-axis element.

Usage: COORD name=(DX=dx DY=dy CHI1=chi1 CHI2=chi2 CHI3=chi3 DIR=dir); .

If dir is zero (default), the transformation of the coordinate by COORD is

<img  class="eqs" src="SADHelp_img/equ_101.svg" />

and if dir is nonzero,

<img  class="eqs" src="SADHelp_img/equ_102.svg" />

where {x, y, z}_1 are the new coordinates and

<img  class="eqs" src="SADHelp_img/equ_103.svg" />

Note that these transformationis are NOT the inverse to each other.

   To use this element, you have to calculate the values of those parameters carefully. DISP G may
help you but there is no automatic way to get them. You may also have to be careful when you use
a line with this element in the reverse direction.

   A better way to do an equivalent thing in most cases is to use SOL. Unlike COORD, SOL automatically
determines the parameters for the coordinate transformation.</pre>
<pre>See also:
 <a href=#LSOL>SOL</a> <a href=#LDISPLAY(DISP)>DISPLAY(DISP)</a></pre>
<li><h3><a name=Ldefault-keyword>default-keyword</a></h3>
<pre>The default and available non-default variable keywords are:

type    default-keyword  non-default variable keyword
DRIFT   L                -
BEND    ANGLE            K1,K0,E1,E2
QUAD    K1               ROTATE
SEXT    K2               ROTATE
OCT     K3               ROTATE
DECA    K4               ROTATE
DODECA  K5               ROTATE
MULT    K1               K0,K2..K21,SK0,SK1,SK2..SK21,ROTATE,ANGLE
MARK    -                AX,BX,EX,EPX,AY,BY,EY,EPY,R1,R2,R3,R4,DETR,
                         DX,DPX,DY,DPY,DZ,DDP,AZ,BZ,ZX,ZPX,ZY,ZPY</pre>
<pre>See also:
 <a href=#Lkeywords>keywords</a></pre>
<li><h3><a name=LDECA>DECA</a></h3>
<pre>A decapole magnet.</pre>
<ul>
<li><h3><a name=LDISFRIN>DISFRIN</a></h3>
<pre>If nonzero, the nonlinear Maxwellian fringe is suppressed.</pre>
<li><h3><a name=LDISRAD>DISRAD</a></h3>
<pre>If nonzero, the synchrotron radiation in the particle-tracking is inhibited.</pre>
<pre>See also:
 <a href=#LRAD>RAD</a></pre>
<li><h3><a name=LDX>DX</a></h3>
<pre>Horizontal displacement of magnet. This applied before the rotation by ROTATE.</pre>
<pre>See also:
 <a href=#LDY>DY</a> <a href=#LROTATE>ROTATE</a> <a href=#LDROTATE>DROTATE</a></pre>
<li><h3><a name=LDY>DY</a></h3>
<pre>Vertical displacement of magnet. This applied before the rotation by ROTATE.</pre>
<pre>See also:
 <a href=#LDX>DX</a> <a href=#LROTATE>ROTATE</a> <a href=#LDROTATE>DROTATE</a></pre>
<li><h3><a name=LK4>K4</a></h3>
<pre>The normal decapole magnetic field component (times the length L).

<img  class="eqs" src="SADHelp_img/equ_104.svg" />

where L is the effective length of the component. Positive sign means horizontal focusing.</pre>
<pre>See also:
 <a href=#LL>L</a></pre>
<li><h3><a name=LL>L</a></h3>
<pre>The effective length.</pre>
<li><h3><a name=LROTATE>ROTATE</a></h3>
<pre>Rotation in x-y plane. After displacing the magnet by DX and DY, rotate the magnet around the local
s-axis by -(amount given by ROTATE), then place the component. At the exit rotate back the magnet
around the local s-axis at the exit, then take out displacement.</pre>
<pre>See also:
 <a href=#LDX>DX</a> <a href=#LDY>DY</a> <a href=#LDROTATE>DROTATE</a></pre>
<li><h3><a name=Ltransformation:THIN>transformation:THIN</a></h3>
<pre><img  class="eqs" src="SADHelp_img/equ_105.svg" /></pre>
</ul>
<li><h3><a name=LDODECA>DODECA</a></h3>
<pre>A dodecapole magnet.</pre>
<ul>
<li><h3><a name=LDISFRIN>DISFRIN</a></h3>
<pre>If nonzero, the nonlinear Maxwellian fringe is suppressed.</pre>
<li><h3><a name=LDISRAD>DISRAD</a></h3>
<pre>If nonzero, the synchrotron radiation in the particle-tracking is inhibited.</pre>
<pre>See also:
 <a href=#LRAD>RAD</a></pre>
<li><h3><a name=LDX>DX</a></h3>
<pre>Horizontal displacement of magnet. This applied before the rotation by ROTATE.</pre>
<pre>See also:
 <a href=#LDY>DY</a> <a href=#LROTATE>ROTATE</a> <a href=#LDROTATE>DROTATE</a></pre>
<li><h3><a name=LDY>DY</a></h3>
<pre>Vertical displacement of magnet. This applied before the rotation by ROTATE.</pre>
<pre>See also:
 <a href=#LDX>DX</a> <a href=#LROTATE>ROTATE</a> <a href=#LDROTATE>DROTATE</a></pre>
<li><h3><a name=LK5>K5</a></h3>
<pre>The normal dodecapole magnetic field component (times the length L).

<img  class="eqs" src="SADHelp_img/equ_108.svg" />

where L is the effective length of the component. Positive sign means horizontal focusing.</pre>
<pre>See also:
 <a href=#LL>L</a></pre>
<li><h3><a name=LL>L</a></h3>
<pre>The effective length.</pre>
<li><h3><a name=LROTATE>ROTATE</a></h3>
<pre>Rotation in x-y plane. After displacing the magnet by DX and DY, rotate the magnet around the local
s-axis by -(amount given by ROTATE), then place the component. At the exit rotate back the magnet
around the local s-axis at the exit, then take out displacement.</pre>
<pre>See also:
 <a href=#LDX>DX</a> <a href=#LDY>DY</a> <a href=#LDROTATE>DROTATE</a></pre>
<li><h3><a name=Ltransformation:THIN>transformation:THIN</a></h3>
<pre><img  class="eqs" src="SADHelp_img/equ_109.svg" /></pre>
</ul>
<li><h3><a name=LDRIFT>DRIFT</a></h3>
<pre>A drift space.</pre>
<ul>
<li><h3><a name=LL>L</a></h3>
<pre>The length, can be negative.</pre>
<li><h3><a name=LRADIUS>RADIUS</a></h3>
<pre>Radius of the vacuum chamber. Effective when SPAC is ON.</pre>
<pre>See also:
 <a href=#LSPAC>SPAC</a></pre>
<li><h3><a name=Ltransformation:DRIFT>transformation:DRIFT</a></h3>
<pre>The transformation of a drift is written as

<img  class="eqs" src="SADHelp_img/equ_112.svg" />

with

<img  class="eqs" src="SADHelp_img/equ_113.svg" /></pre>
<pre>See also:
 coordinates</pre>
</ul>
<li><h3><a name=Lkeywords>keywords</a></h3>
<pre>Available keywords are:

        
type    keywords
DRIFT   L RADIUS
BEND    L ROTATE DROTATE DX DY ANGLE K0 K1 E1 E2 AE1 AE2 F1 FB1 FB2 FRINGE DISFRIN DISRAD EPS RANKICK
QUAD    L ROTATE DX DY K1 F1 F2 FRINGE DISFRIN DISRAD EPS
SEXT    L ROTATE DX DY K2 DISFRIN DISRAD
OCT     L ROTATE DX DY K3 DISFRIN DISRAD
DECA    L ROTATE DX DY K4 DISFRIN DISRAD
DODECA  L ROTATE DX DY K5 DISFRIN DISRAD
MULT    L DX DY DZ CHI1 CHI2 ROTATE(=CHI3) K0..K21 SK0..SK21 DISFRIN F1 F2 FRINGE DISRAD EPS VOLT
        DVOLT HARM PHI DPHI FREQ RADIUS ANGLE E1 E2 AE1 AE2 DROTATE
SOL     BZ DX DY DZ DPX DPY BOUND GEO CHI1 CHI2 CHI3 DBZ DISFRIN
CAVI    L ROTATE DX DY VOLT DVOLT V1 V20 V11 V02 FREQ PHI HARM RANVOLT RANPHASE DISFRIN FRINGE
TCAVI   L ROTATE DX DY K0 V1 FREQ PHI HARM RANKICK RANPHASE
COORD   DX DY CHI1 CHI2 CHI3 DIR
MARK    AX BX AY BY EX EPX EY EPY R1 R2 R3 R4 DETR DX DPX DY DPY DZ DDP AZ BZ NZ ZX ZPX ZY ZPY EMITX
        EMITY DP AZ SIGZ GEO OFFSET
APERT   DX1 DX2 DY1 DY2 DP AX AY DX DY</pre>
<pre>See also:
 <a href=#Ldefault-keyword>default-keyword</a> <a href=#Lset-value-of-element>set-value-of-element</a> <a href=#LElement>Element</a></pre>
<li><h3><a name=LMARK>MARK</a></h3>
<pre>MARK elements play special roles in FFS:

     
(1)  The first element of the beam line must be a MARK element to be used by FFS. In this case the
     MARK element contains the parameters of the incoming beam (see optical-functions, special-variables
     EMITX, EMITY, DP).
(2)  The calculated optical parameters at a MARK command is saved by SAVE or STOP commands, then
     it can be used as the incoming condition of other beam lines which have the same MARK element.

Example: MARK P1 = (EMITX = .. EMITY = .. DP = ..);
         LINE  A = ( .. P1 ..)
               B = (P1 .. );
         FFS USE = A;
             ...           do matching on LINE A
             SAVE P1       save the parameters at P1
             USE B;        switch to LINE B
             ...           do matching of LINE B whose entrance is to be
                           matched P1.

     
(3)  If a MARK element has keyword GEO nonzero, this MARK element becomes the origin of the geometric
     rotation after the last SOL element.
(4)  The values of optical-functions of the MARK element at the beginning of the beam line can be
     specified as matching variables by the FREE command.

 A MARK elements have all optical-functions as its keywords except NX, NY, TRX, TRY, and LENG. Also
it has keywords EMITX, EMITY, and DP which give the values of the corresponding special-variables.</pre>
<pre>See also:
 <a href=#LSAVE>SAVE</a> <a href=#LUSE>USE</a> <a href=#Loptical-functions>optical-functions</a> <a href=#LSOL>SOL</a> <a href=#Lspecial-variables>special-variables</a> <a href=#LEMITX>EMITX</a>
 <a href=#LEMITY>EMITY</a> <a href=#LDP>DP</a></pre>
<ul>
<li><h3><a name=LOFFSET>OFFSET</a></h3>
<pre>OFFSET is a relative position from the current position. A fraction is allowed to specify a location
within an element.
   If the MARK at the beginning of a beam line has OFFSET nonzero, the optics calculation starts
from the shifted location. If the last component of a beam line is a MARK with nonzero OFFSET, the
optics calculation stops at the shifted location. The periodic condition is applied between those
shifted locations.
   The geometric origin and the origin of LENG shift to the first MARK.

Examples:
(1)  LINE A    = ( ...  QF PQFC  ... );
     QUAD QF   = (L=0.3 K1=0.2);
     MARK PQFC = (OFFSET = -0.5);

Here PQFC represents the center of QF.

(2)  LINE A    = ( ...  PQFC QF  ... );

     QUAD QF   = (L=0.3 K1=0.2);
     MARK PQFC = (OFFSET =  1.5);
Here PQFC represents the center of QF, too (consider why). The value of OFFSET is interpreted taking
the direction of the LINE into account, i.e., a MARK in a line A represents the same location in
a line -A.

Restrictions:
(1) Function TrackParticles does not take OFFSET into account if the start
    or stop location is in the midst of a beam line and a Mark with nonzero
    OFFSET, in the current version. Tracking for entire beam line or
    MEASURE(MEA) command supports OFFSET.
(2) The outputs by DISPLAY(DISP) outside of the narrowed region by OFFSET are
    meaningless.</pre>
</ul>
<li><h3><a name=LMULT>MULT</a></h3>
<pre>A magnet with multipoles. Note that the reference plane is defined so that the skew quadrupole component
becomes zero.
   It can have a nonzero ANGLE to express a combined function bending magnet with multipoles. Note
that the definition of the multipoles with nonzero ANGLE is very special The current version does
not allow nonzero ANGLE inside a solenoid or with acceleration. Also the fringe field and emittance
calculation are not installed properly for nonzero ANGLE.</pre>
<pre>See also:
 <a href=#Lmultipole_with_nonzero_ANGLE>multipole_with_nonzero_ANGLE</a></pre>
<ul>
<li><h3><a name=LK0>K0</a></h3>
<pre>The normal dipole magnetic field component (times the length L).

<img  class="eqs" src="SADHelp_img/equ_91.svg" />

where L is the effective length of the component. Positive sign means horizontal focusing.</pre>
<pre>See also:
 <a href=#LL>L</a></pre>
<li><h3><a name=LSK0>SK0</a></h3>
<pre>The skew dipole magnetic field component (times the length L).
<img  class="eqs" src="SADHelp_img/equ_114.svg" />

where L is the length of the component. Positive sign means a horizontally focusing magnet rotated
around z-axis by -90/1 degree, i.e., ROTATE = 90 DEG .</pre>
<pre>See also:
 <a href=#LL>L</a></pre>
<li><h3><a name=LK1>K1</a></h3>
<pre>The normal quadrupole magnetic field component (times the length L).

<img  class="eqs" src="SADHelp_img/equ_92.svg" />

where L is the effective length of the component. Positive sign means horizontal focusing.</pre>
<pre>See also:
 <a href=#LL>L</a></pre>
<li><h3><a name=LSK1>SK1</a></h3>
<pre>The skew quadrupole magnetic field component (times the length L).
<img  class="eqs" src="SADHelp_img/equ_115.svg" />

where L is the length of the component. Positive sign means a horizontally focusing magnet rotated
around z-axis by -90/2 degree, i.e., ROTATE = 45 DEG .</pre>
<pre>See also:
 <a href=#LL>L</a></pre>
<li><h3><a name=LK2>K2</a></h3>
<pre>The normal sextupole magnetic field component (times the length L).

<img  class="eqs" src="SADHelp_img/equ_116.svg" />

where L is the effective length of the component. Positive sign means horizontal focusing.</pre>
<pre>See also:
 <a href=#LL>L</a></pre>
<li><h3><a name=LSK2>SK2</a></h3>
<pre>The skew sextupole magnetic field component (times the length L).
<img  class="eqs" src="SADHelp_img/equ_117.svg" />

where L is the length of the component. Positive sign means a horizontally focusing magnet rotated
around z-axis by -90/3 degree, i.e., ROTATE = 30 DEG .</pre>
<pre>See also:
 <a href=#LL>L</a></pre>
<li><h3><a name=LK3>K3</a></h3>
<pre>The normal octupole magnetic field component (times the length L).

<img  class="eqs" src="SADHelp_img/equ_118.svg" />

where L is the effective length of the component. Positive sign means horizontal focusing.</pre>
<pre>See also:
 <a href=#LL>L</a></pre>
<li><h3><a name=LSK3>SK3</a></h3>
<pre>The skew octupole magnetic field component (times the length L).
<img  class="eqs" src="SADHelp_img/equ_119.svg" />

where L is the length of the component. Positive sign means a horizontally focusing magnet rotated
around z-axis by -90/4 degree, i.e., ROTATE = 22.5 DEG .</pre>
<pre>See also:
 <a href=#LL>L</a></pre>
<li><h3><a name=LK4>K4</a></h3>
<pre>The normal decapole magnetic field component (times the length L).

<img  class="eqs" src="SADHelp_img/equ_104.svg" />

where L is the effective length of the component. Positive sign means horizontal focusing.</pre>
<pre>See also:
 <a href=#LL>L</a></pre>
<li><h3><a name=LSK4>SK4</a></h3>
<pre>The skew decapole magnetic field component (times the length L).
<img  class="eqs" src="SADHelp_img/equ_120.svg" />

where L is the length of the component. Positive sign means a horizontally focusing magnet rotated
around z-axis by -90/5 degree, i.e., ROTATE = 18 DEG .</pre>
<pre>See also:
 <a href=#LL>L</a></pre>
<li><h3><a name=LK5>K5</a></h3>
<pre>The normal dodecapole magnetic field component (times the length L).

<img  class="eqs" src="SADHelp_img/equ_108.svg" />

where L is the effective length of the component. Positive sign means horizontal focusing.</pre>
<pre>See also:
 <a href=#LL>L</a></pre>
<li><h3><a name=LSK5>SK5</a></h3>
<pre>The skew dodecapole magnetic field component (times the length L).
<img  class="eqs" src="SADHelp_img/equ_121.svg" />

where L is the length of the component. Positive sign means a horizontally focusing magnet rotated
around z-axis by -90/6 degree, i.e., ROTATE = 15 DEG .</pre>
<pre>See also:
 <a href=#LL>L</a></pre>
<li><h3><a name=LK6>K6</a></h3>
<pre>The normal 14-pole magnetic field component (times the length L).

<img  class="eqs" src="SADHelp_img/equ_122.svg" />

where L is the effective length of the component. Positive sign means horizontal focusing.</pre>
<pre>See also:
 <a href=#LL>L</a></pre>
<li><h3><a name=LSK6>SK6</a></h3>
<pre>The skew 14-pole magnetic field component (times the length L).
<img  class="eqs" src="SADHelp_img/equ_123.svg" />

where L is the length of the component. Positive sign means a horizontally focusing magnet rotated
around z-axis by -90/7 degree, i.e., ROTATE = 12.857142857142856 DEG .</pre>
<pre>See also:
 <a href=#LL>L</a></pre>
<li><h3><a name=LK7>K7</a></h3>
<pre>The normal 16-pole magnetic field component (times the length L).

<img  class="eqs" src="SADHelp_img/equ_124.svg" />

where L is the effective length of the component. Positive sign means horizontal focusing.</pre>
<pre>See also:
 <a href=#LL>L</a></pre>
<li><h3><a name=LSK7>SK7</a></h3>
<pre>The skew 16-pole magnetic field component (times the length L).
<img  class="eqs" src="SADHelp_img/equ_125.svg" />

where L is the length of the component. Positive sign means a horizontally focusing magnet rotated
around z-axis by -90/8 degree, i.e., ROTATE = 11.25 DEG .</pre>
<pre>See also:
 <a href=#LL>L</a></pre>
<li><h3><a name=LK8>K8</a></h3>
<pre>The normal 18-pole magnetic field component (times the length L).

<img  class="eqs" src="SADHelp_img/equ_126.svg" />

where L is the effective length of the component. Positive sign means horizontal focusing.</pre>
<pre>See also:
 <a href=#LL>L</a></pre>
<li><h3><a name=LSK8>SK8</a></h3>
<pre>The skew 18-pole magnetic field component (times the length L).
<img  class="eqs" src="SADHelp_img/equ_127.svg" />

where L is the length of the component. Positive sign means a horizontally focusing magnet rotated
around z-axis by -90/9 degree, i.e., ROTATE = 10 DEG .</pre>
<pre>See also:
 <a href=#LL>L</a></pre>
<li><h3><a name=LK9>K9</a></h3>
<pre>The normal 20-pole magnetic field component (times the length L).

<img  class="eqs" src="SADHelp_img/equ_128.svg" />

where L is the effective length of the component. Positive sign means horizontal focusing.</pre>
<pre>See also:
 <a href=#LL>L</a></pre>
<li><h3><a name=LSK9>SK9</a></h3>
<pre>The skew 20-pole magnetic field component (times the length L).
<img  class="eqs" src="SADHelp_img/equ_129.svg" />

where L is the length of the component. Positive sign means a horizontally focusing magnet rotated
around z-axis by -90/10 degree, i.e., ROTATE = 9 DEG .</pre>
<pre>See also:
 <a href=#LL>L</a></pre>
<li><h3><a name=LK10>K10</a></h3>
<pre>The normal 22-pole magnetic field component (times the length L).

<img  class="eqs" src="SADHelp_img/equ_130.svg" />

where L is the effective length of the component. Positive sign means horizontal focusing.</pre>
<pre>See also:
 <a href=#LL>L</a></pre>
<li><h3><a name=LSK10>SK10</a></h3>
<pre>The skew 22-pole magnetic field component (times the length L).
<img  class="eqs" src="SADHelp_img/equ_131.svg" />

where L is the length of the component. Positive sign means a horizontally focusing magnet rotated
around z-axis by -90/11 degree, i.e., ROTATE = 8.181818181818182 DEG .</pre>
<pre>See also:
 <a href=#LL>L</a></pre>
<li><h3><a name=LK11>K11</a></h3>
<pre>The normal 24-pole magnetic field component (times the length L).

<img  class="eqs" src="SADHelp_img/equ_132.svg" />

where L is the effective length of the component. Positive sign means horizontal focusing.</pre>
<pre>See also:
 <a href=#LL>L</a></pre>
<li><h3><a name=LSK11>SK11</a></h3>
<pre>The skew 24-pole magnetic field component (times the length L).
<img  class="eqs" src="SADHelp_img/equ_133.svg" />

where L is the length of the component. Positive sign means a horizontally focusing magnet rotated
around z-axis by -90/12 degree, i.e., ROTATE = 7.5 DEG .</pre>
<pre>See also:
 <a href=#LL>L</a></pre>
<li><h3><a name=LK12>K12</a></h3>
<pre>The normal 26-pole magnetic field component (times the length L).

<img  class="eqs" src="SADHelp_img/equ_134.svg" />

where L is the effective length of the component. Positive sign means horizontal focusing.</pre>
<pre>See also:
 <a href=#LL>L</a></pre>
<li><h3><a name=LSK12>SK12</a></h3>
<pre>The skew 26-pole magnetic field component (times the length L).
<img  class="eqs" src="SADHelp_img/equ_135.svg" />

where L is the length of the component. Positive sign means a horizontally focusing magnet rotated
around z-axis by -90/13 degree, i.e., ROTATE = 6.923076923076923 DEG .</pre>
<pre>See also:
 <a href=#LL>L</a></pre>
<li><h3><a name=LK13>K13</a></h3>
<pre>The normal 28-pole magnetic field component (times the length L).

<img  class="eqs" src="SADHelp_img/equ_136.svg" />

where L is the effective length of the component. Positive sign means horizontal focusing.</pre>
<pre>See also:
 <a href=#LL>L</a></pre>
<li><h3><a name=LSK13>SK13</a></h3>
<pre>The skew 28-pole magnetic field component (times the length L).
<img  class="eqs" src="SADHelp_img/equ_137.svg" />

where L is the length of the component. Positive sign means a horizontally focusing magnet rotated
around z-axis by -90/14 degree, i.e., ROTATE = 6.428571428571428 DEG .</pre>
<pre>See also:
 <a href=#LL>L</a></pre>
<li><h3><a name=LK14>K14</a></h3>
<pre>The normal 30-pole magnetic field component (times the length L).

<img  class="eqs" src="SADHelp_img/equ_138.svg" />

where L is the effective length of the component. Positive sign means horizontal focusing.</pre>
<pre>See also:
 <a href=#LL>L</a></pre>
<li><h3><a name=LSK14>SK14</a></h3>
<pre>The skew 30-pole magnetic field component (times the length L).
<img  class="eqs" src="SADHelp_img/equ_139.svg" />

where L is the length of the component. Positive sign means a horizontally focusing magnet rotated
around z-axis by -90/15 degree, i.e., ROTATE = 6 DEG .</pre>
<pre>See also:
 <a href=#LL>L</a></pre>
<li><h3><a name=LK15>K15</a></h3>
<pre>The normal 32-pole magnetic field component (times the length L).

<img  class="eqs" src="SADHelp_img/equ_140.svg" />

where L is the effective length of the component. Positive sign means horizontal focusing.</pre>
<pre>See also:
 <a href=#LL>L</a></pre>
<li><h3><a name=LSK15>SK15</a></h3>
<pre>The skew 32-pole magnetic field component (times the length L).
<img  class="eqs" src="SADHelp_img/equ_141.svg" />

where L is the length of the component. Positive sign means a horizontally focusing magnet rotated
around z-axis by -90/16 degree, i.e., ROTATE = 5.625 DEG .</pre>
<pre>See also:
 <a href=#LL>L</a></pre>
<li><h3><a name=LK16>K16</a></h3>
<pre>The normal 34-pole magnetic field component (times the length L).

<img  class="eqs" src="SADHelp_img/equ_142.svg" />

where L is the effective length of the component. Positive sign means horizontal focusing.</pre>
<pre>See also:
 <a href=#LL>L</a></pre>
<li><h3><a name=LSK16>SK16</a></h3>
<pre>The skew 34-pole magnetic field component (times the length L).
<img  class="eqs" src="SADHelp_img/equ_143.svg" />

where L is the length of the component. Positive sign means a horizontally focusing magnet rotated
around z-axis by -90/17 degree, i.e., ROTATE = 5.294117647058823 DEG .</pre>
<pre>See also:
 <a href=#LL>L</a></pre>
<li><h3><a name=LK17>K17</a></h3>
<pre>The normal 36-pole magnetic field component (times the length L).

<img  class="eqs" src="SADHelp_img/equ_144.svg" />

where L is the effective length of the component. Positive sign means horizontal focusing.</pre>
<pre>See also:
 <a href=#LL>L</a></pre>
<li><h3><a name=LSK17>SK17</a></h3>
<pre>The skew 36-pole magnetic field component (times the length L).
<img  class="eqs" src="SADHelp_img/equ_145.svg" />

where L is the length of the component. Positive sign means a horizontally focusing magnet rotated
around z-axis by -90/18 degree, i.e., ROTATE = 5 DEG .</pre>
<pre>See also:
 <a href=#LL>L</a></pre>
<li><h3><a name=LK18>K18</a></h3>
<pre>The normal 38-pole magnetic field component (times the length L).

<img  class="eqs" src="SADHelp_img/equ_146.svg" />

where L is the effective length of the component. Positive sign means horizontal focusing.</pre>
<pre>See also:
 <a href=#LL>L</a></pre>
<li><h3><a name=LSK18>SK18</a></h3>
<pre>The skew 38-pole magnetic field component (times the length L).
<img  class="eqs" src="SADHelp_img/equ_147.svg" />

where L is the length of the component. Positive sign means a horizontally focusing magnet rotated
around z-axis by -90/19 degree, i.e., ROTATE = 4.7368421052631575 DEG .</pre>
<pre>See also:
 <a href=#LL>L</a></pre>
<li><h3><a name=LK19>K19</a></h3>
<pre>The normal 40-pole magnetic field component (times the length L).

<img  class="eqs" src="SADHelp_img/equ_148.svg" />

where L is the effective length of the component. Positive sign means horizontal focusing.</pre>
<pre>See also:
 <a href=#LL>L</a></pre>
<li><h3><a name=LSK19>SK19</a></h3>
<pre>The skew 40-pole magnetic field component (times the length L).
<img  class="eqs" src="SADHelp_img/equ_149.svg" />

where L is the length of the component. Positive sign means a horizontally focusing magnet rotated
around z-axis by -90/20 degree, i.e., ROTATE = 4.5 DEG .</pre>
<pre>See also:
 <a href=#LL>L</a></pre>
<li><h3><a name=LK20>K20</a></h3>
<pre>The normal 42-pole magnetic field component (times the length L).

<img  class="eqs" src="SADHelp_img/equ_150.svg" />

where L is the effective length of the component. Positive sign means horizontal focusing.</pre>
<pre>See also:
 <a href=#LL>L</a></pre>
<li><h3><a name=LSK20>SK20</a></h3>
<pre>The skew 42-pole magnetic field component (times the length L).
<img  class="eqs" src="SADHelp_img/equ_151.svg" />

where L is the length of the component. Positive sign means a horizontally focusing magnet rotated
around z-axis by -90/21 degree, i.e., ROTATE = 4.285714285714286 DEG .</pre>
<pre>See also:
 <a href=#LL>L</a></pre>
<li><h3><a name=LK21>K21</a></h3>
<pre>The normal 44-pole magnetic field component (times the length L).

<img  class="eqs" src="SADHelp_img/equ_152.svg" />

where L is the effective length of the component. Positive sign means horizontal focusing.</pre>
<pre>See also:
 <a href=#LL>L</a></pre>
<li><h3><a name=LSK21>SK21</a></h3>
<pre>The skew 44-pole magnetic field component (times the length L).
<img  class="eqs" src="SADHelp_img/equ_153.svg" />

where L is the length of the component. Positive sign means a horizontally focusing magnet rotated
around z-axis by -90/22 degree, i.e., ROTATE = 4.090909090909091 DEG .</pre>
<pre>See also:
 <a href=#LL>L</a></pre>
<li><h3><a name=LAE1>AE1</a></h3>
<pre>The absolute face angle at the entrance. The effective face angle is E1 * ANGLE + AE1, and a positive
angle at the entrance corresponds to a surface with dx/ds > 0.</pre>
<pre>See also:
 <a href=#LE1>E1</a> <a href=#LAE2>AE2</a> <a href=#LANGLE>ANGLE</a></pre>
<li><h3><a name=LAE2>AE2</a></h3>
<pre>The absolute face-angle at the exit to the bending angle. The effective face angle is E2 * ANGLE
+ AE2, and a positive angle at the exit corresponds to a surface with dx/ds < 0.</pre>
<pre>See also:
 <a href=#LE2>E2</a> <a href=#LAE1>AE1</a> <a href=#LANGLE>ANGLE</a></pre>
<li><h3><a name=LANGLE>ANGLE</a></h3>
<pre>The bending angle. If positive, it bends the orbit in x-s plane toward negative-x-direction. ANGLE
determines the geometry of the beam line, while K0 represents a dipole kick on top of the bending
angle given by ANGLE, i.e., the total deflection of the beam is given of ANGLE + K0.</pre>
<pre>See also:
 <a href=#LK0>K0</a></pre>
<li><h3><a name=LDISFRIN>DISFRIN</a></h3>
<pre>If nonzero, the nonlinear maxwellian fringe is suppressed. The effects of DISFRIN and FRINGE are
summarized as

                   DISFRIN=0                   DISFRIN<>0
             Nonlinear      Linear       Nonlinear     Linear
FRINGE=0    entr & exit      none          none         none
FRINGE=1       entr          entr          none         entr
FRINGE=2       exit          exit          none         exit
FRINGE=3    entr & exit   entr & exit      none      entr & exit

</pre>
<pre>See also:
 <a href=#LFRINGE>FRINGE</a></pre>
<li><h3><a name=LDISRAD>DISRAD</a></h3>
<pre>If nonzero, the synchrotron radiation in the particle-tracking is inhibited.</pre>
<pre>See also:
 <a href=#LRAD>RAD</a></pre>
<li><h3><a name=LDPHI>DPHI</a></h3>
<pre>Relative phase offset. The stable synchrotron phase above the transition is near PHI = 0. The acceleration is given as 

<img  class="eqs" src="SADHelp_img/equ_100.svg" />

where ts is the equilibrium time determined by the valance between the acceleration and the radiation
loss around the ring. DPHI is not taken into account to determine the design momentum p0(s).</pre>
<pre>See also:
 <a href=#LFREQ>FREQ</a> <a href=#LVOLT>VOLT</a> <a href=#LDVOLT>DVOLT</a> <a href=#LV1>V1</a> V20 <a href=#LV11>V11</a></pre>
<li><h3><a name=LDVOLT>DVOLT</a></h3>
<pre>Additional accelerating peak voltage to be added to Volt, without affecting the design momentum p0(s).</pre>
<pre>See also:
 <a href=#LVOLT>VOLT</a></pre>
<li><h3><a name=LE1>E1</a></h3>
<pre>The ratio of the face-angle at the entrance to the bending angle. The effective face angle is E1
* ANGLE + AE1, and a positive angle at the entrance corresponds to a surface with dx/ds > 0. For
example, a symmetrically-placed rectangular magnet has
 E1 = 0.5 and E2 = 0.5.</pre>
<pre>See also:
 <a href=#LAE1>AE1</a> <a href=#LE2>E2</a> <a href=#LANGLE>ANGLE</a></pre>
<li><h3><a name=LE2>E2</a></h3>
<pre>The ratio of the face-angle at the exit to the bending angle. The effective face angle is E2 * ANGLE
+ AE2, and a positive angle at the exit corresponds to a surface with dx/ds < 0. For example, a symmetrically-placed
rectangular magnet has E1 = 0.5 and E2 = 0.5.</pre>
<pre>See also:
 <a href=#LAE2>AE2</a> <a href=#LE1>E1</a> <a href=#LANGLE>ANGLE</a></pre>
<li><h3><a name=LF1>F1</a></h3>
<pre><img  class="eqs" src="SADHelp_img/equ_154.svg" />
   The effects only in the first order of K1 is taken into account.</pre>
<pre>See also:
 <a href=#LF2>F2</a> <a href=#LFRINGE>FRINGE</a></pre>
<li><h3><a name=LF2>F2</a></h3>
<pre><img  class="eqs" src="SADHelp_img/equ_154.svg" />
   The effects only in the first order of K1 is taken into account.</pre>
<pre>See also:
 <a href=#LF1>F1</a> <a href=#LFRINGE>FRINGE</a></pre>
<li><h3><a name=LFB1>FB1</a></h3>
<pre>Linear Fringe length F1 for the K0 component at the entrance.</pre>
<pre>See also:
 <a href=#LBEND>BEND</a> <a href=#LF1>F1</a> <a href=#LFB1>FB1</a></pre>
<li><h3><a name=LFB2>FB2</a></h3>
<pre>Linear Fringe length F1 for the K0 component at the exit.</pre>
<pre>See also:
 <a href=#LBEND>BEND</a> <a href=#LF1>F1</a> <a href=#LFB2>FB2</a></pre>
<li><h3><a name=LFREQ>FREQ</a></h3>
<pre> Rf frequency. If this keyword is nonzero, the keyword HARM is ignored.
<img  class="eqs" src="SADHelp_img/equ_100.svg" /></pre>
<pre>See also:
 <a href=#LHARM>HARM</a></pre>
<li><h3><a name=LFRINGE>FRINGE</a></h3>
<pre>The effects of the linear fringe (characterized by F1 and F2), and the nonlinear Mexwellian fringe
are controled as:

                   DISFRIN=0                   DISFRIN<>0
             Nonlinear      Linear       Nonlinear     Linear
FRINGE=0    entr & exit      none          none         none
FRINGE=1       entr          entr          none         entr
FRINGE=2       exit          exit          none         exit
FRINGE=3    entr & exit   entr & exit      none      entr & exit

</pre>
<pre>See also:
 <a href=#LF1>F1</a> <a href=#LF2>F2</a> <a href=#LDISFRIN>DISFRIN</a></pre>
<li><h3><a name=LHARM>HARM</a></h3>
<pre> A harmonic number. This is valid only when FREQ is zero.</pre>
<pre>See also:
 <a href=#LFREQ>FREQ</a></pre>
<li><h3><a name=LL>L</a></h3>
<pre>The effective length.</pre>
<li><h3><a name=Lmisalignments>misalignments</a></h3>
<pre>Misalignments of a MULT element are expressed by the keywords DX, DY, DZ, CHI1, CHI2, and ROTATE(=CHI3). They specify all misa
lignments of a rigid body,  At the entrance of MULT, the coordinates of a particle are transformed as

<img  class="eqs" src="SADHelp_img/equ_157.svg" />

where c1 and s1 are Cos[CHI1] and Sin[CHI1], etc. The inverse is applied at the exit.
   Those misalignments are also valid within a solenoid.
   Other straight elements such as QUAD or THIN do not and will not have these full misalignment
specifications, because they can be substituted by MULT.
   The geometry of the design orbit is determined by the saved values of CHI1, CHI2, and DZ, while
the current values are used for DX, DY, and ROTATE.</pre>
<li><h3><a name=Lmultipole_with_nonzero_ANGLE>multipole_with_nonzero_ANGLE</a></h3>
<pre>The multipoles in MULT with nonzero ANGLE are defined by

<img  class="eqs" src="SADHelp_img/equ_158.svg" />
Actually the summation is truncated at n + k <= 21 in the current version. While this definition
converges to the regular one for multipoles when ANGLE -> 0, K0 and K1 of MULT are different from
those of BEND.</pre>
<pre>See also:
 <a href=#LANGLE>ANGLE</a></pre>
<li><h3><a name=LPHI>PHI</a></h3>
<pre>Relative phase offset. The stable synchrotron phase above the transition is near PHI = 0. 
The acceleration is given as 

<img  class="eqs" src="SADHelp_img/equ_100.svg" />

where ts is the equilibrium time determined by the valance between the acceleration and the radiation
loss around the ring.</pre>
<li><h3><a name=LRADIUS>RADIUS</a></h3>
<pre>Radius of the vacuum chamber. Effective when SPAC is ON.</pre>
<pre>See also:
 <a href=#LSPAC>SPAC</a></pre>
<li><h3><a name=LVOLT>VOLT</a></h3>
<pre>Accelerating peak voltage in Volt.
<img  class="eqs" src="SADHelp_img/equ_100.svg" />

where ts is the equilibrium time determined by the valance between the acceleration and the radiation
loss around the ring.</pre>
<pre>See also:
 <a href=#LDVOLT>DVOLT</a></pre>
</ul>
<li><h3><a name=LOCT>OCT</a></h3>
<pre>A octupole magnet.</pre>
<ul>
<li><h3><a name=LDISFRIN>DISFRIN</a></h3>
<pre>If nonzero, the nonlinear Maxwellian fringe is suppressed.</pre>
<li><h3><a name=LDISRAD>DISRAD</a></h3>
<pre>If nonzero, the synchrotron radiation in the particle-tracking is inhibited.</pre>
<pre>See also:
 <a href=#LRAD>RAD</a></pre>
<li><h3><a name=LDX>DX</a></h3>
<pre>Horizontal displacement of magnet. This applied before the rotation by ROTATE.</pre>
<pre>See also:
 <a href=#LDY>DY</a> <a href=#LROTATE>ROTATE</a> <a href=#LDROTATE>DROTATE</a></pre>
<li><h3><a name=LDY>DY</a></h3>
<pre>Vertical displacement of magnet. This applied before the rotation by ROTATE.</pre>
<pre>See also:
 <a href=#LDX>DX</a> <a href=#LROTATE>ROTATE</a> <a href=#LDROTATE>DROTATE</a></pre>
<li><h3><a name=LK3>K3</a></h3>
<pre>The normal octupole magnetic field component (times the length L).

<img  class="eqs" src="SADHelp_img/equ_118.svg" />

where L is the effective length of the component. Positive sign means horizontal focusing.</pre>
<pre>See also:
 <a href=#LL>L</a></pre>
<li><h3><a name=LL>L</a></h3>
<pre>The effective length.</pre>
<li><h3><a name=LROTATE>ROTATE</a></h3>
<pre>Rotation in x-y plane. After displacing the magnet by DX and DY, rotate the magnet around the local
s-axis by -(amount given by ROTATE), then place the component. At the exit rotate back the magnet
around the local s-axis at the exit, then take out displacement.</pre>
<pre>See also:
 <a href=#LDX>DX</a> <a href=#LDY>DY</a> <a href=#LDROTATE>DROTATE</a></pre>
<li><h3><a name=Ltransformation:THIN>transformation:THIN</a></h3>
<pre><img  class="eqs" src="SADHelp_img/equ_159.svg" /></pre>
</ul>
<li><h3><a name=LQUAD>QUAD</a></h3>
<pre>A quadrupole magnet.</pre>
<ul>
<li><h3><a name=LDISFRIN>DISFRIN</a></h3>
<pre>If nonzero, the nonlinear maxwellian fringe is suppressed. The effects of DISFRIN and FRINGE are
summarized as

                   DISFRIN=0                   DISFRIN<>0
             Nonlinear      Linear       Nonlinear     Linear
FRINGE=0    entr & exit      none          none         none
FRINGE=1       entr          entr          none         entr
FRINGE=2       exit          exit          none         exit
FRINGE=3    entr & exit   entr & exit      none      entr & exit

</pre>
<pre>See also:
 <a href=#LFRINGE>FRINGE</a></pre>
<li><h3><a name=LDISRAD>DISRAD</a></h3>
<pre>If nonzero, the synchrotron radiation in the particle-tracking is inhibited.</pre>
<pre>See also:
 <a href=#LRAD>RAD</a></pre>
<li><h3><a name=LDX>DX</a></h3>
<pre>Horizontal displacement of magnet. This applied before the rotation by ROTATE.</pre>
<pre>See also:
 <a href=#LDY>DY</a> <a href=#LROTATE>ROTATE</a> <a href=#LDROTATE>DROTATE</a></pre>
<li><h3><a name=LDY>DY</a></h3>
<pre>Vertical displacement of magnet. This applied before the rotation by ROTATE.</pre>
<pre>See also:
 <a href=#LDX>DX</a> <a href=#LROTATE>ROTATE</a> <a href=#LDROTATE>DROTATE</a></pre>
<li><h3><a name=LF1>F1</a></h3>
<pre><img  class="eqs" src="SADHelp_img/equ_154.svg" />
   The effects only in the first order of K1 is taken into account.</pre>
<pre>See also:
 <a href=#LF2>F2</a> <a href=#LFRINGE>FRINGE</a></pre>
<li><h3><a name=LF2>F2</a></h3>
<pre><img  class="eqs" src="SADHelp_img/equ_154.svg" />
   The effects only in the first order of K1 is taken into account.</pre>
<pre>See also:
 <a href=#LF1>F1</a> <a href=#LFRINGE>FRINGE</a></pre>
<li><h3><a name=LFRINGE>FRINGE</a></h3>
<pre>The effects of the linear fringe (characterized by F1 and F2), and the nonlinear Mexwellian fringe
are controled as:

                   DISFRIN=0                   DISFRIN<>0
             Nonlinear      Linear       Nonlinear     Linear
FRINGE=0    entr & exit      none          none         none
FRINGE=1       entr          entr          none         entr
FRINGE=2       exit          exit          none         exit
FRINGE=3    entr & exit   entr & exit      none      entr & exit

</pre>
<pre>See also:
 <a href=#LF1>F1</a> <a href=#LF2>F2</a> <a href=#LDISFRIN>DISFRIN</a></pre>
<li><h3><a name=LK1>K1</a></h3>
<pre>The normal quadrupole magnetic field component (times the length L).

<img  class="eqs" src="SADHelp_img/equ_92.svg" />

where L is the effective length of the component. Positive sign means horizontal focusing.</pre>
<pre>See also:
 <a href=#LL>L</a></pre>
<li><h3><a name=LL>L</a></h3>
<pre>The effective length.</pre>
<li><h3><a name=LROTATE>ROTATE</a></h3>
<pre>Rotation in x-y plane. After displacing the magnet by DX and DY, rotate the magnet around the local
s-axis by -(amount given by ROTATE), then place the component. At the exit rotate back the magnet
around the local s-axis at the exit, then take out displacement.</pre>
<pre>See also:
 <a href=#LDX>DX</a> <a href=#LDY>DY</a> <a href=#LDROTATE>DROTATE</a></pre>
<li><h3><a name=Ltransformation:QUAD>transformation:QUAD</a></h3>
<pre>The transformation in a QUAD is a sequence of:

   (nonlinear fringe at entrance)
<img  class="eqs" src="SADHelp_img/equ_162.svg" />
   (linear fringe at entrance)
<img  class="eqs" src="SADHelp_img/equ_168.svg" />
   (body of quad)
<img  class="eqs" src="SADHelp_img/equ_175.svg" />
   (linear fringe at exit)

<img  class="eqs" src="SADHelp_img/equ_178.svg" />
   (nonlinear fringe at exit)
<img  class="eqs" src="SADHelp_img/equ_185.svg" /></pre>
<pre>See also:
 <a href=#LHamiltonian>Hamiltonian</a> <a href=#L2nd-order-Hamiltonian>2nd-order-Hamiltonian</a> <a href=#Lsolution-H2>solution-H2</a> <a href=#Lsolution-dH>solution-dH</a>
</pre>
</ul>
<li><h3><a name=LSEXT>SEXT</a></h3>
<pre>A sextupole magnet.</pre>
<ul>
<li><h3><a name=LDISFRIN>DISFRIN</a></h3>
<pre>If nonzero, the nonlinear Maxwellian fringe is suppressed.</pre>
<li><h3><a name=LDISRAD>DISRAD</a></h3>
<pre>If nonzero, the synchrotron radiation in the particle-tracking is inhibited.</pre>
<pre>See also:
 <a href=#LRAD>RAD</a></pre>
<li><h3><a name=LDX>DX</a></h3>
<pre>Horizontal displacement of magnet. This applied before the rotation by ROTATE.</pre>
<pre>See also:
 <a href=#LDY>DY</a> <a href=#LROTATE>ROTATE</a> <a href=#LDROTATE>DROTATE</a></pre>
<li><h3><a name=LDY>DY</a></h3>
<pre>Vertical displacement of magnet. This applied before the rotation by ROTATE.</pre>
<pre>See also:
 <a href=#LDX>DX</a> <a href=#LROTATE>ROTATE</a> <a href=#LDROTATE>DROTATE</a></pre>
<li><h3><a name=LK2>K2</a></h3>
<pre>The normal sextupole magnetic field component (times the length L).

<img  class="eqs" src="SADHelp_img/equ_116.svg" />

where L is the effective length of the component. Positive sign means horizontal focusing.</pre>
<pre>See also:
 <a href=#LL>L</a></pre>
<li><h3><a name=LL>L</a></h3>
<pre>The effective length.</pre>
<li><h3><a name=LROTATE>ROTATE</a></h3>
<pre>Rotation in x-y plane. After displacing the magnet by DX and DY, rotate the magnet around the local
s-axis by -(amount given by ROTATE), then place the component. At the exit rotate back the magnet
around the local s-axis at the exit, then take out displacement.</pre>
<pre>See also:
 <a href=#LDX>DX</a> <a href=#LDY>DY</a> <a href=#LDROTATE>DROTATE</a></pre>
<li><h3><a name=Ltransformation:THIN>transformation:THIN</a></h3>
<pre><img  class="eqs" src="SADHelp_img/equ_191.svg" /></pre>
</ul>
<li><h3><a name=LSOL>SOL</a></h3>
<pre>A solenoid. Unlike other elements, SOL elements inserted at boundaries or of a solenoid or at where
the field changes. Between SOL elements DRIFT, BEND(straight bend only), QUAD, and MULT elements
can be inserted. The longitudinal field of the solenoid overlaps on those elements.
   In a SOL region, the coordinate is shifted on the axis of the solenoid, no matter how the design
orbit bends there. The x-direction of the coordinate in a solenoid is so chosen as to CHI3 = 0. At
the exit of a solenoid, the coordinate is shifted back to the design orbit, but the value of CHI3
is so determined as to set CHI3 zero at the nearest MARK element which has GEO = 1 after the exit.
The offset and orientation of the design orbit can be given by keywords DX, DY, DPX, DPY at a SOL
element with GEO = 1. SOL can be used to shift the coordinate to the actual orbit even without BZ.
It is useful to define the coordinate with magnets with DX and DY.</pre>
<pre>See also:
 <a href=#Lgeometric-functions>geometric-functions</a> <a href=#LMARK>MARK</a></pre>
<ul>
<li><h3><a name=LBOUND>BOUND</a></h3>
<pre>BOUND = 1 must be given at both sides of the boundaries of a solenoid, otherwise SOL only specifies
the change of BZ</pre>
<li><h3><a name=LBZ>BZ</a></h3>
<pre>The longitudinal field of a solenoid. If a SOL is used with BOUND = 0 (default), only BZ is used
to change the field, and no coordinate transformation is applied.</pre>
<li><h3><a name=LDISFRIN>DISFRIN</a></h3>
<pre><img  class="eqs" src="SADHelp_img/equ_194.svg" /></pre>
<li><h3><a name=LDPX>DPX</a></h3>
<pre>An offset of the design ORBIT angle CHI1 relative to the solenoid axis at SOL with GEO = 1.</pre>
<pre>See also:
 <a href=#LGEO>GEO</a> <a href=#LDX>DX</a> <a href=#LDY>DY</a> <a href=#LDPY>DPY</a> CHI1</pre>
<li><h3><a name=LDPY>DPY</a></h3>
<pre>An offset of the design ORBIT angle CHI2 relative to the solenoid axis at SOL with GEO = 1.</pre>
<pre>See also:
 <a href=#LGEO>GEO</a> <a href=#LDX>DX</a> <a href=#LDY>DY</a> <a href=#LDPX>DPX</a> CHI2</pre>
<li><h3><a name=LDX>DX</a></h3>
<pre>An x-offset of the design ORBIT relative to the solenoid center at SOL with GEO = 1.</pre>
<pre>See also:
 <a href=#LGEO>GEO</a> <a href=#LDY>DY</a> <a href=#LDPX>DPX</a> <a href=#LDPY>DPY</a></pre>
<li><h3><a name=LDY>DY</a></h3>
<pre>A y-offset of the design ORBIT relative to the solenoid center at SOL with GEO = 1.</pre>
<pre>See also:
 <a href=#LGEO>GEO</a> <a href=#LDX>DX</a> <a href=#LDPX>DPX</a> <a href=#LDPY>DPY</a></pre>
<li><h3><a name=LF1>F1</a></h3>
<pre>The length of fringe of the solenoid field. It affects only the EMITTANCE calculation. If F1 = 0
(default), no radiation arises at the fringe.</pre>
<li><h3><a name=LGEO>GEO</a></h3>
<pre>One of boundaries (with GEO = 1) of a solenoid must have GEO = 1 to specify the alignment of the
design orbit. At a SOL element with GEO = 1, the design orbit is determined by DX, DY, DPX, DPY parameters</pre>
<pre>See also:
 <a href=#LDX>DX</a> <a href=#LDY>DY</a> <a href=#LDPX>DPX</a> <a href=#LDPY>DPY</a> <a href=#Lgeometric-functions>geometric-functions</a> <a href=#LDISPLAY(DISP)>DISPLAY(DISP)</a> GEOMRTRY(G) <a href=#LOGEOMETRY(OG)>OGEOMETRY(OG)</a>
</pre>
</ul>
</ul>
<h3><a name=Lexpression>expression</a></h3>
<pre>An expression in FFS consists of a symbol, constants, and operators.

>>> A symbol is a characters of any length starting with an alphabet or $.
>>> There are two kinds of constants, real number and character-string.
    real number is a number in fortran-line format.
    character-string is a set of characters surrounded by "" or ''.
    special-characters can be specified with backslash.
>>> Available operators are (in the order of the priority):
    #,##,
    ?,
    ::,
    @,
    [],
    ++, --,
    /@, //@, @@,
    .,
    ^,
    *, /,
    +, -,
    ==, <>, >, <, >=, =>, <=, =<, 
    ===, <=>, 
    ~, 
    &&,
    ||,
    .., ...,
    |,
    :,
    ->, :>,
    /., //.,
    +=, -=, *=, /=,
    &,
    //,
    /:,
    =, :=, ^=, ^:=, =.
    ;,
    {}
An operator with higher priority is operated first. An expression enclosed in () is evaluated first.
Most mathematical operations are threaded into a list, i.e., {a,b} + {c,d} gives {a + b,c + d}, etc.

  Each operators can be used as a function using its name. For example, Plus[x,y] gives the same
result as x + y.</pre>
<pre>See also:
 <a href=#Lconstants>constants</a> <a href=#Lfunctions>functions</a> <a href=#Lcommand-syntax>command-syntax</a> <a href=#Lcharacter-string>character-string</a></pre>
<ul>
<li><h3><a name=L(-)>(-)</a></h3>
<pre>operator for subtraction or unary minus.</pre>
<li><h3><a name=L(/)>(/)</a></h3>
<pre>operator for division.</pre>
<li><h3><a name=LAddTo(+=)>AddTo(+=)</a></h3>
<pre>a+=b is equivalent to a=a+b .</pre>
<li><h3><a name=LAlternatives(|)>Alternatives(|)</a></h3>
<pre>a | b | ... represents a pattern which matches one of patterns a, b, ...</pre>
<li><h3><a name=LAnd(&&)>And(&&)</a></h3>
<pre> a && b returns True(==1) when both a and b are nonzero real,  False(==0) otherwise. b is not evaluated
when a is zero.</pre>
<li><h3><a name=LApply (@@)>Apply (@@)</a></h3>
<pre>f@@a applies function f to subexpressions of a. f@@[a,level] specifies a levelspec to apply by level.</pre>
<pre>See also:
 <a href=#LApply>Apply</a></pre>
<li><h3><a name=LCompoundExpression(;)>CompoundExpression(;)</a></h3>
<pre>a ; b evaluates a, then evaluates b and returns its result.</pre>
<li><h3><a name=LDecrement(--)>Decrement(--)</a></h3>
<pre>a-- decrements a by 1, returning the old value of a. --a decrements a by 1, returning the new value
of a.</pre>
<li><h3><a name=LDivideBy(/=)>DivideBy(/=)</a></h3>
<pre>a/=b is equivalent to a=a/b.</pre>
<li><h3><a name=LDot(.)>Dot(.)</a></h3>
<pre>a . b returns the inner product of a and b.</pre>
<li><h3><a name=LEqual(==)>Equal(==)</a></h3>
<pre>a == b returns True(==1) if a and b have the same type and the same value. It returns False(==0)
if a and b have the same type but the different values. Otherwise returns the expression a == b.</pre>
<li><h3><a name=LFunction(&)>Function(&)</a></h3>
<pre> a & is a pure-function whose argument is specified #, #n, ##, ##n.</pre>
<pre>See also:
 Slot(#) SlotSequence(##) <a href=#Lfunctions>functions</a> <a href=#LFunction(&)>Function(&)</a></pre>
<li><h3><a name=LGreater(>)>Greater(>)</a></h3>
<pre>
If both a and b are real, a > b returns True if a is greater than b, False otherwise. It causes an
error when a or b is not real.</pre>
<li><h3><a name=LGreaterEqual(>= or =>)>GreaterEqual(>= or =>)</a></h3>
<pre>If both a and b are real, a => b returns True if a is greater than or equal to b, False otherwise.
It causes an error when a or b is not real.</pre>
<li><h3><a name=LIncrement(++)>Increment(++)</a></h3>
<pre>a++ increments a by 1, returning the old value of a. ++a increments a by 1, returning the new value
of a.</pre>
<li><h3><a name=LLess(<)>Less(<)</a></h3>
<pre>
If both a and b are real, a < b returns True if a is less than b, False otherwise. It causes an error
when a or b is not real.</pre>
<li><h3><a name=LLessEqual(<= or =<)>LessEqual(<= or =<)</a></h3>
<pre>If both a and b are real, a <= b returns True if a is less than or equal to b, False otherwise. It
causes an error when a or b is not real.</pre>
<li><h3><a name=LList({})>List({})</a></h3>
<pre>{a,b,c...} is a list structure.</pre>
<li><h3><a name=LMap (/@)>Map (/@)</a></h3>
<pre>f/@a maps function f to subexpressions of a. f/@[a,level] specifies a levelspec of map by level.</pre>
<pre>See also:
 <a href=#LMap>Map</a></pre>
<li><h3><a name=LMapAll(//@)>MapAll(//@)</a></h3>
<pre>f//@a maps function f to all subexpressions of a. f//@[a,Heads->True] maps including the heads of
a and its subexpressions.</pre>
<li><h3><a name=LMember(@)>Member(@)</a></h3>
<pre>f@a refers the member a of an instance or a class f. Otherwise it is same as f[a]. f@g@h means (f@g)@h,
and f@g[h] (f@g)[h].</pre>
<li><h3><a name=LMessageName(::)>MessageName(::)</a></h3>
<pre>symbol::tag returns a message associated with symbol and tag
 symbol::tag = message sets a message identified by symbol</pre>
<li><h3><a name=LNot(~)>Not(~)</a></h3>
<pre> ~a returns True(==1) when a is zero, False(==0) when a is a nonzero real.</pre>
<li><h3><a name=LOr(||)>Or(||)</a></h3>
<pre>
a || b returns True(==1) when a is nonzero real or b is nonzero real, False(==0) otherwise. b is
not evaluated when a is nonzero.</pre>
<li><h3><a name=LPart([[]])>Part([[]])</a></h3>
<pre>a[[b,..]] is a subexpression of an expression a.
 If an index is omitted or Null like as a[[,b]], Part returns a list of elements whose corresponding
index takes the entire range. For instance,
 {{1, 2}, {3, 4}, {5, 6}}[[,2]] gives {2, 4, 6}.</pre>
<pre>See also:
 <a href=#LPart>Part</a></pre>
<li><h3><a name=LPatternTest(?)>PatternTest(?)</a></h3>
<pre>pattern?test matches to an object which matches pattern then test[object] gives True.</pre>
<li><h3><a name=LPlus(+)>Plus(+)</a></h3>
<pre>a + b returns the sum of a and b.</pre>
<li><h3><a name=LPower(^)>Power(^)</a></h3>
<pre>a ^ b returns the power of a to b.</pre>
<li><h3><a name=LRepeated(..)>Repeated(..)</a></h3>
<pre>p.. matches sequence of one ore more expressions, each matching p.</pre>
<li><h3><a name=LRepeatedNull(...)>RepeatedNull(...)</a></h3>
<pre>p... matches sequence of zero ore more expressions, each matching p.</pre>
<li><h3><a name=LReplaceAll(/.)>ReplaceAll(/.)</a></h3>
<pre>expr/.rule replaces all subexpressions of expr using rule.</pre>
<li><h3><a name=LReplaceRepeated(//.)>ReplaceRepeated(//.)</a></h3>
<pre>expr//.rule replaces all subexpressionso of expr using rule, while a replacement is performed.</pre>
<li><h3><a name=LRule(->)>Rule(->)</a></h3>
<pre>pattern->expr represents a rule for ReplaceAll.</pre>
<li><h3><a name=LRuleDelayed(:>)>RuleDelayed(:>)</a></h3>
<pre>pattern:>expr represents a rule for ReplaceAll, where expr is kept unevaluated until the replacement.</pre>
<pre>See also:
 Literal</pre>
<li><h3><a name=LSameQ(===)>SameQ(===)</a></h3>
<pre>a === b returns True(==1) if a and b have the same type and same value, False(==0) otherwise.</pre>
<li><h3><a name=LSequence([])>Sequence([])</a></h3>
<pre>a[b,c,..] means a list of b, c,.. with the head a. It is evaluated as a function-reference when a
is a function or a defined-function. When a is a list with head List, it is interpreted as a part
specification of a list. When a is a character-string, it is interpreted as a substring specification.
When a is an operator, it is an expression b (a) c (a) .. . When a is Null, it means a sequence.</pre>
<li><h3><a name=LSet(=)>Set(=)</a></h3>
<pre>a = value sets the value b to the symbol a. {a,b,..}={v1,v2,..} sets a,b,c simultaneously. a[b,c,..]=v1
sets the part of a[b,c,..] if a is a list. a[b,c,..] = expression defines the value a[b,c,..] if
a is not a list.</pre>
<li><h3><a name=LSetDelayed(:=)>SetDelayed(:=)</a></h3>
<pre>same as Set but the right hand side is not evaluated when it is set.</pre>
<pre>See also:
 <a href=#LSet(=)>Set(=)</a></pre>
<li><h3><a name=LStringJoin (//)>StringJoin (//)</a></h3>
<pre>a // b converts a and b to character-strings, then join them.</pre>
<pre>See also:
 <a href=#LStringJoin>StringJoin</a></pre>
<li><h3><a name=LSubtractFrom(-=)>SubtractFrom(-=)</a></h3>
<pre>a-=b is equivalent to a=a-b .</pre>
<li><h3><a name=LTagSet(/:)>TagSet(/:)</a></h3>
<pre>symb/:lhs = rhs sets rhs to lhs, associated with symbol symb. symb/:lhs := rhs sets rhs to lhs unevaluated,
associated with symbol symb. symb/:lhs =. unsets lhs, associated with symbol symb.</pre>
<li><h3><a name=LTimes(*)>Times(*)</a></h3>
<pre>a * b returns the product of a and b.</pre>
<li><h3><a name=LTimesBy(*=)>TimesBy(*=)</a></h3>
<pre>a*=b is equivalent to a=a*b .</pre>
<li><h3><a name=LUnequal(<>)>Unequal(<>)</a></h3>
<pre>a <> b returns True(==1) if a and b have the same type but the different values. It returns False(==0)
if a and b have the same type but the same value. Otherwise returns the expression a <> b.</pre>
<li><h3><a name=LUnsameQ(<=>)>UnsameQ(<=>)</a></h3>
<pre>a <=> b returns True(==1) if a and b have the different types or different values. False(==0) otherwise.</pre>
<li><h3><a name=LUnset(=.)>Unset(=.)</a></h3>
<pre>a=. clears the definition assigned to a.</pre>
<pre>See also:
 Clear</pre>
</ul>
<h3><a name=LELSE>ELSE</a></h3>
<pre>Usage: IF expr1 body1 [ELSEIF expr2 body2 [ELSEIF ..]] [ELSE body3] ENDIF

This is a FORTRAN77 like IF-structure. If the expression expr1 is True(==1) or nonzero, executes
commands in body1. If it is False(==0), skip commands until ELSE, ELSEIF or ENDIF appears at the
same level of the IF-structure, and executes commands after ELSE or ENDIF, or executes the ELSEIF
command. If expr1 is not a real number, an error message is printed and ignores the command line.</pre>
<pre>See also:
 If <a href=#LELSEIF>ELSEIF</a> <a href=#LENDIF>ENDIF</a></pre>
<h3><a name=LELSEIF>ELSEIF</a></h3>
<pre>Usage: IF expr1 body1 [ELSEIF expr2 body2 [ELSEIF ..]] [ELSE body3] ENDIF

This is a FORTRAN77 like IF-structure. If the expression expr1 is True(==1) or nonzero, executes
commands in body1. If it is False(==0), skip commands until ELSE, ELSEIF or ENDIF appears at the
same level of the IF-structure, and executes commands after ELSE or ENDIF, or executes the ELSEIF
command. If expr1 is not a real number, an error message is printed and ignores the command line.</pre>
<pre>See also:
 <a href=#LIF>IF</a> <a href=#LELSE>ELSE</a> <a href=#LENDIF>ENDIF</a></pre>
<h3><a name=LEMITTANCE(EMIT)>EMITTANCE(EMIT)</a></h3>
<pre>Usage: (1) EMIT
       (2) EMIT dp

(1) EMIT calculates the closed orbit, the normal coordinate, and the equilibrium emittance assuming the current beam line is a posi
tron ring. One of EMITTANCE(EMIT), the Emittance[] function, or the EMIT command in the MAIN level are necessary to be done in prio
r to multi-turn tracking. See multi-turn-tracking.

(2) EMIT dp, where dp is |df_rf/f_rf|/(alpha_p == momentum compaction), does EMIT for five rf frequencies:

<img  class="eqs" src="SADHelp_img/equ_199.svg" />

then prints out a table of the dependences of various quantities on the frequency shift.

   The results of EMITTANCE(EMIT) are affected by flags COD, RADCOD, RFSW, INTRA, WSPAC, EMIOUT,
CODPLOT and special-variables MOMENTUM, CHARGE, FSHIFT, MINCOUP, PBUNCH. The flag TRPT or RING affects
only Emittance[], as EMITTANCE(EMIT) automatically set RING.
   EMITTANCE(EMIT) returns the equilibrium emittances in variables EMITX, EMITY, EMITZ, and the equilibrium
bunch length in SIGZ, the relative momentum spread in SIGE, and the longitudinal equilibrium position
DTSYNCH. 

   The map used in EMIT is slightly different from that used in the tracking. For instance, the edge
angle of a bend is approximated by a thin quad. If the edge angle is large and the curvature is small,
EMIT may give a wrong answer. This will be corrected in near future.</pre>
<pre>See also:
 <a href=#Lmulti-turn-tracking>multi-turn-tracking</a> <a href=#Lextended-Twiss-parameters>extended-Twiss-parameters</a> <a href=#LCOD>COD</a> <a href=#LRADCOD>RADCOD</a>
 <a href=#LRFSW>RFSW</a> <a href=#LINTRA>INTRA</a> <a href=#LEMIOUT>EMIOUT</a> <a href=#LWSPAC>WSPAC</a> <a href=#LCODPLOT>CODPLOT</a> <a href=#LTRPT>TRPT</a> <a href=#LMOMENTUM>MOMENTUM</a> <a href=#LCHARGE>CHARGE</a> <a href=#LFSHIFT>FSHIFT</a>
 <a href=#LMINCOUP>MINCOUP</a> <a href=#LPBUNCH>PBUNCH</a> <a href=#LEMITX>EMITX</a> <a href=#LEMITY>EMITY</a> <a href=#LEMITZ>EMITZ</a> <a href=#LSIGE>SIGE</a> <a href=#LSIGZ>SIGZ</a> <a href=#LDTSYNCH>DTSYNCH</a> <a href=#LEmittance>Emittance</a>
 <a href=#Lequilibrium-beam-envelope>equilibrium-beam-envelope</a></pre>
<h3><a name=LEND>END</a></h3>
<pre>Closes the current output-stream and set the output stream to the standard output(6). It also suspends
all the input streams and switches to the standard input(5). Since this command affects all input
and output streams, you may consider to use TERMINATE(TERM) or CLOSE(CLO) to suspend or close them
selectively.</pre>
<pre>See also:
 <a href=#LTERMINATE(TERM)>TERMINATE(TERM)</a> <a href=#LCLOSE(CLO)>CLOSE(CLO)</a> <a href=#LINPUT(IN)>INPUT(IN)</a> <a href=#LREAD>READ</a> <a href=#LOUTPUT(OUT)>OUTPUT(OUT)</a>
 <a href=#LAPPEND(APP)>APPEND(APP)</a></pre>
<h3><a name=LENDIF>ENDIF</a></h3>
<pre>Usage: IF expr1 body1 [ELSEIF expr2 body2 [ELSEIF ..]] [ELSE body3] ENDIF

This is a FORTRAN77 like IF-structure. If the expression expr1 is True(==1) or nonzero, executes
commands in body1. If it is False(==0), skip commands until ELSE, ELSEIF or ENDIF appears at the
same level of the IF-structure, and executes commands after ELSE or ENDIF, or executes the ELSEIF
command. If expr1 is not a real number, an error message is printed and ignores the command line.</pre>
<pre>See also:
 <a href=#LIF>IF</a> <a href=#LELSE>ELSE</a> <a href=#LELSEIF>ELSEIF</a></pre>
<h3><a name=LEXECUTE(EXEC)>EXECUTE(EXEC)</a></h3>
<pre>Usage: EXEC character-string-expression

executes the character-string-expression as FFS commands.</pre>
<pre>See also:
 <a href=#Lexpression>expression</a> <a href=#LFFS>FFS</a> <a href=#LToExpression>ToExpression</a></pre>
<h3><a name=LEXPAND>EXPAND</a></h3>
<pre> EXPAND distributes all variable keys to each corresponding components. Individual deviations (machine
errors) are cleared.</pre>
<pre>See also:
 <a href=#LGO>GO</a> <a href=#LCALCULATE(CAL)>CALCULATE(CAL)</a> <a href=#LEMITTANCE(EMIT)>EMITTANCE(EMIT)</a></pre>
<h3><a name=Lflags>flags</a></h3>
<pre>Usage: [NO]flag

turns the flag on. If NO is prepended to flag, the flag is turned off. Some flags have antonym which
works in the opposite way. Flags can be accessed in the function-syntax with the form ?flag, which
returns True (=1) when the flag is on, or False (=0) otherwise. Some flags can be accessed by the
ON/OFF commands at the MAIN level.
 Status of all flags are displayed by the STATUS(STAT) command.</pre>
<pre>See also:
 <a href=#LSTATUS(STAT)>STATUS(STAT)</a> <a href=#LPatternTest(?)>PatternTest(?)</a></pre>
<ul>
<li><h3><a name=LABSW>ABSW</a></h3>
<pre>ABSW or NORELW sets the weights of variable elements independent from their values in the matching.
Otherwise they are weighted relatively.</pre>
<pre>See also:
 <a href=#LRELW>RELW</a></pre>
<li><h3><a name=LBIPOL>BIPOL</a></h3>
<pre>BIPOL or NOUNIPOL allows the change of sign of the value of the element during the matching. It affects
the default keywords of all elements. This is overridden by MIN, MAX specification or VariableRange
of each element.</pre>
<pre>See also:
 <a href=#LUNIPOL>UNIPOL</a> <a href=#Ldefault-keyword>default-keyword</a> <a href=#Lset-value-of-element>set-value-of-element</a> <a href=#LVariableRange>VariableRange</a>
</pre>
<li><h3><a name=LCALC4D>CALC4D</a></h3>
<pre>If CALC4D is on, the optics calculation in CAL and GO performs a 4x5 calculation (4D + dispersion).
The antonyms is CALC6D. The Default is CALC4D.</pre>
<pre>See also:
 <a href=#LCALC6D>CALC6D</a> <a href=#LCALCULATE(CAL)>CALCULATE(CAL)</a> <a href=#LGO>GO</a></pre>
<li><h3><a name=LCALC6D>CALC6D</a></h3>
<pre>If CALC6D is on, the optics calculation in CAL and GO performs full 6D calculation, which may takes
RADCOD into account. The antonyms is CALC4D. The Default is CALC4D.</pre>
<pre>See also:
 <a href=#LCALC4D>CALC4D</a> <a href=#LCALCULATE(CAL)>CALCULATE(CAL)</a> <a href=#LGO>GO</a></pre>
<li><h3><a name=LCELL>CELL</a></h3>
<pre>CELL or NOINS sets the periodic condition in calculating the optical-functions.</pre>
<pre>See also:
 <a href=#LINS>INS</a> <a href=#LCALCULATE(CAL)>CALCULATE(CAL)</a> <a href=#LGO>GO</a> <a href=#Loptical-functions>optical-functions</a> <a href=#Lmatching-function-commands>matching-function-commands</a>
</pre>
<li><h3><a name=LCMPLOT>CMPLOT</a></h3>
<pre>CMPLOT enables the shift of the center of mass at the beginning of the tracking. This is almost obsolete.</pre>
<li><h3><a name=LCOD>COD</a></h3>
<pre>COD turns on finding the closed-orbit in the emittance calculation. Accessible in MAIN level.</pre>
<pre>See also:
 <a href=#LEMITTANCE(EMIT)>EMITTANCE(EMIT)</a></pre>
<li><h3><a name=LCODPLOT>CODPLOT</a></h3>
<pre>CODPLOT lets the emittance calculation return the information on the closed-orbit, extended Twiss
parameters, and the beam size along the beam line into the FFS optics buffer, which can be shown
by DISPLAY(DISP) or DRAW commands as well as Twiss and OpticsPlot functions.</pre>
<pre>See also:
 <a href=#LEMITTANCE(EMIT)>EMITTANCE(EMIT)</a> <a href=#LDISPLAY(DISP)>DISPLAY(DISP)</a> <a href=#LDRAW>DRAW</a> <a href=#LWSPAC>WSPAC</a> <a href=#LRADTAPER>RADTAPER</a></pre>
<li><h3><a name=LCONV>CONV</a></h3>
<pre>CONV is a flag set by the CALCULATE(CAL) or GO commands. It becomes True when MatchingResidual is
less than CONVERGENCE.</pre>
<pre>See also:
 <a href=#LCALCULATE(CAL)>CALCULATE(CAL)</a> <a href=#LGO>GO</a> <a href=#LMatchingResidual>MatchingResidual</a> <a href=#LCONVERGENCE>CONVERGENCE</a></pre>
<li><h3><a name=LCONVCASE>CONVCASE</a></h3>
<pre>When CONVCASE is on, FFS command line parser converts the input characters to the upper case.(Default
on) CONVCASE actions for the element names and patterns CAN be overridden by PRSVCASE flag.</pre>
<pre>See also:
 <a href=#LPRSVCASE>PRSVCASE</a></pre>
<li><h3><a name=LDAMPONLY>DAMPONLY</a></h3>
<pre>DAMPONLY is the antonym of FLUC.</pre>
<pre>See also:
 <a href=#LFLUC>FLUC</a></pre>
<li><h3><a name=LDAPERT>DAPERT</a></h3>
<pre>DAPERT enables the DAPERT procedure in the multi-turn tracking to obtain the dynamic aperture diagram.
Accessible in the MAIN level.</pre>
<pre>See also:
 <a href=#Lfunctions>functions</a> <a href=#LDynamicApertureSurvey>DynamicApertureSurvey</a></pre>
<li><h3><a name=LDIFFRES>DIFFRES</a></h3>
<pre>
In the case of CELL, if the total tune deviates across a difference resonance, it is counted as unstable.
The default is NODIFFRES.</pre>
<pre>See also:
 <a href=#LINTRES>INTRES</a> <a href=#LHALFRES>HALFRES</a> <a href=#LSUMRES>SUMRES</a> <a href=#LSTABLE>STABLE</a></pre>
<li><h3><a name=LECHO>ECHO</a></h3>
<pre>ECHO enables the echo of the main input in the MAIN level.</pre>
<li><h3><a name=LEMIOUT>EMIOUT</a></h3>
<pre>EMIOUT turns on the extended output of emittance calculation.
Accessible in the MAIN level.</pre>
<pre>See also:
 <a href=#LEMITTANCE(EMIT)>EMITTANCE(EMIT)</a></pre>
<li><h3><a name=LFFSPRMPT>FFSPRMPT</a></h3>
<pre>When FFSPRMPT is off(default) the input prompt is In[n]:= , where n is $Line+1. Otherwise the prompt
is the traditional FFS prompt, showing the FIT location and the DISP range.</pre>
<pre>See also:
 <a href=#L$Line>$Line</a> <a href=#LLOG>LOG</a></pre>
<li><h3><a name=LFIXSEED>FIXSEED</a></h3>
<pre>FIXSEED or NOMOVESEED disables the change of the seed of the random number generator after the particle
tracking.</pre>
<pre>See also:
 <a href=#LMOVESEED>MOVESEED</a> <a href=#LMEASURE(MEA)>MEASURE(MEA)</a> <a href=#LSEED>SEED</a></pre>
<li><h3><a name=LFLUC>FLUC</a></h3>
<pre>FLUC or NODAMPONLY enables the diffusion due to synchrotron radiation in the particle tracking. Otherwise
only the damping is enabled when RAD is ON.</pre>
<pre>See also:
 <a href=#LDAMPONLY>DAMPONLY</a> <a href=#LRAD>RAD</a> <a href=#LRADCOD>RADCOD</a></pre>
<li><h3><a name=LGAUSS>GAUSS</a></h3>
<pre>GAUSS or NOUNIFORM sets the momentum distribution of the incoming beam to be Gaussian, otherwise
uniform(square) distribution is assumed. It affects the beam size calculated by Twiss parameters.</pre>
<pre>See also:
 <a href=#LUNIFORM>UNIFORM</a> <a href=#LMEASURE(MEA)>MEASURE(MEA)</a> <a href=#LBEAMSIZE(BEAM)>BEAMSIZE(BEAM)</a> <a href=#Lspecial-variables>special-variables</a>
 <a href=#LDP>DP</a></pre>
<li><h3><a name=LGEOCAL>GEOCAL</a></h3>
<pre>When GEOCAL is on(default), the geometry of the beam line is always updated by CALCULATE(CAL) or
GO commands using the current values of components. The coordinate transformation by SOL is also
updated. When GEOCAL is off, the geometry is never updated. It is useful to simulate misalignments
within a solenoid, etc.</pre>
<pre>See also:
 <a href=#LGEOFIX>GEOFIX</a> <a href=#LCALCULATE(CAL)>CALCULATE(CAL)</a> <a href=#LGO>GO</a> <a href=#LSOL>SOL</a></pre>
<li><h3><a name=LGEOFIX>GEOFIX</a></h3>
<pre>GEOFIX is the antonym of GEOCAL.</pre>
<pre>See also:
 <a href=#LGEOCAL>GEOCAL</a></pre>
<li><h3><a name=LHALFRES>HALFRES</a></h3>
<pre>In the case of CELL, if the total tune deviates across a half-integer resonance, or the traces is
less than -2, it is counted as unstable (~?STABLE). Otherwise the optics is recognized as STABLE.
The default is HALFRES.</pre>
<pre>See also:
 <a href=#LINTRES>INTRES</a> <a href=#LSUMRES>SUMRES</a> <a href=#LDIFFRES>DIFFRES</a> <a href=#LSTABLE>STABLE</a></pre>
<li><h3><a name=LIDEAL>IDEAL</a></h3>
<pre>IDEAL or NOREAL inhibits to use the component-specific deviations in the optics calculation.</pre>
<pre>See also:
 <a href=#LREAL>REAL</a> <a href=#LCALCULATE(CAL)>CALCULATE(CAL)</a> <a href=#LGO>GO</a></pre>
<li><h3><a name=LINS>INS</a></h3>
<pre>INS is the antonym of CELL.</pre>
<pre>See also:
 <a href=#LCELL>CELL</a></pre>
<li><h3><a name=LINTRA>INTRA</a></h3>
<pre>INTRA turns on the calculation of intra-beam scattering in the emittance calculation. Accessible
in MAIN level.</pre>
<pre>See also:
 <a href=#LEMITTANCE(EMIT)>EMITTANCE(EMIT)</a> <a href=#LEmittance>Emittance</a> <a href=#Lequilibrium-beam-envelope>equilibrium-beam-envelope</a>
</pre>
<li><h3><a name=LINTRES>INTRES</a></h3>
<pre>In the case of CELL, if the total tune deviates across an integer resonance, or the trace is larger
than 2, it is counted as unstable (~?STABLE). Otherwise the optics is recognized as STABLE. The default
is INTRES.</pre>
<pre>See also:
 <a href=#LHALFRES>HALFRES</a> <a href=#LSUMRES>SUMRES</a> <a href=#LDIFFRES>DIFFRES</a> <a href=#LSTABLE>STABLE</a></pre>
<li><h3><a name=LJITTER>JITTER</a></h3>
<pre>JITTER or NOQUIET allows jitter of the center-of-mass of the incoming beam in the case of TRPT. Otherwise
the center-of-mass statistically fluctuates depending on the number of particles.</pre>
<pre>See also:
 <a href=#LQUIET>QUIET</a> <a href=#LMEASURE(MEA)>MEASURE(MEA)</a> <a href=#LTRPT>TRPT</a></pre>
<li><h3><a name=LLOG>LOG</a></h3>
<pre>LOG enables the echo of all inputs in the MAIN level. Also suppresses the prompt in FFS.</pre>
<pre>See also:
 <a href=#LECHO>ECHO</a></pre>
<li><h3><a name=LLOSSMAP>LOSSMAP</a></h3>
<pre>If LOSSMAP is on, TrackParticles returns the location and turn where the particle lost is detected,
in the 7/9th and 8/10th element of the result, for  NOPOL/POL, respectively. The default is NOLOSSMAP</pre>
<pre>See also:
 <a href=#LTrackParticles>TrackParticles</a> <a href=#LPOL>POL</a></pre>
<li><h3><a name=LLWAKE>LWAKE</a></h3>
<pre>LWAKE turns on optics calculation with Longitudinal WakeFunction</pre>
<pre>See also:
 <a href=#LWakeFunction>WakeFunction</a> <a href=#LTrackParticles>TrackParticles</a> <a href=#LInitialOrbits>InitialOrbits</a> <a href=#LTWAKE>TWAKE</a></pre>
<li><h3><a name=LMOVESEED>MOVESEED</a></h3>
<pre>MOVESEED is the antonym of FIXSEED.</pre>
<pre>See also:
 <a href=#LFIXSEED>FIXSEED</a></pre>
<li><h3><a name=LPHOTONS>PHOTONS</a></h3>
<pre>When PHOTONS is ON (default is OFF), with RAD and FLUC, TrackParticles generates a list of all photons
radiated through the tracking. The list is assigned to a symbol PhotonList.</pre>
<pre>See also:
 <a href=#LPhotonList>PhotonList</a> <a href=#LTrackParticles>TrackParticles</a> <a href=#LRAD>RAD</a> <a href=#LFLUC>FLUC</a></pre>
<li><h3><a name=LPOL>POL</a></h3>
<pre>POL turns on spin tracking and the calculation of equilibrium polarization in EMIT/Emittance[].</pre>
<pre>See also:
 <a href=#LRADPOL>RADPOL</a> <a href=#LEMITTANCE(EMIT)>EMITTANCE(EMIT)</a> <a href=#LEmittance>Emittance</a> <a href=#LTrackParticles>TrackParticles</a></pre>
<li><h3><a name=LPRSVCASE>PRSVCASE</a></h3>
<pre>When PRSVCASE is on, FFS command line parser preserves the input characters for the element names
and patterns.(Default off)</pre>
<pre>See also:
 <a href=#LCONVCASE>CONVCASE</a></pre>
<li><h3><a name=LPSPAC>PSPAC</a></h3>
<pre>When on, performs space-charge simulation in a "Particle-In-Cell" method. PSPAC is effective in tracking
only.
   Do not confuse PSPAC with SPAC/WSPAC.</pre>
<pre>See also:
 PSPACNX PSPACNY PSPACNZ PSPACDX PSPACDY PSPACDZ</pre>
<li><h3><a name=LQUIET>QUIET</a></h3>
<pre>QUIET is the antonym of JITEER.</pre>
<pre>See also:
 <a href=#LJITTER>JITTER</a></pre>
<li><h3><a name=LRAD>RAD</a></h3>
<pre>RAD turns on the synchrotron radiation in the particle-tracking. Accessible in the MAIN level.</pre>
<pre>See also:
 <a href=#LRADCOD>RADCOD</a> <a href=#LFLUC>FLUC</a></pre>
<li><h3><a name=LRADCOD>RADCOD</a></h3>
<pre>RADCOD turns on the energy loss due to synchrotron radiation at the closed-orbit in the emittance
calculation. Also turns off the implicit acceleration in the tracking to compensate the energy loss
automatically, in the case that TRPT is ON. Accessible in MAIN level.</pre>
<pre>See also:
 <a href=#LRAD>RAD</a> <a href=#LFLUC>FLUC</a> <a href=#LTRPT>TRPT</a></pre>
<li><h3><a name=LRADLIGHT>RADLIGHT</a></h3>
<pre>When RADLIGHT is on, the function TrackParticles returns a list of trajectories which are used to
calculate the synchrotron radiation field.</pre>
<pre>See also:
 <a href=#LTrackParticles>TrackParticles</a> <a href=#LRadiationField>RadiationField</a> <a href=#LRadiationSpectrum>RadiationSpectrum</a></pre>
<li><h3><a name=LRADPOL>RADPOL</a></h3>
<pre>If POL is on, RADPOL turns on Sokolov-Ternov effect in tracking.</pre>
<pre>See also:
 <a href=#LPOL>POL</a></pre>
<li><h3><a name=LRADTAPER>RADTAPER</a></h3>
<pre> Scales all magnets except for solenoids according to the local momentum (DDP) of the closed orbit.
It uses the average of DDPs at the entrance and the exit. For tracking, RADCOD and ( CAL/GO with
CALC6D or EMIT(Emittance[]) ) is necessary. CAL/GO with CALC4D will clear the necessary information
for tracking with RADTAPER.
 RADTAPER sets the momentum deviation of the closed orbit to DP0, which is an arbitrary choice of
an under-deterministic problem of tapering. Thus the difference in the path length around the ring
is adjusted by automatically updating FSHIFT.</pre>
<pre>See also:
 <a href=#LRADCOD>RADCOD</a> <a href=#LCALC6D>CALC6D</a> <a href=#LCALC4D>CALC4D</a> <a href=#LEMITTANCE(EMIT)>EMITTANCE(EMIT)</a> <a href=#LCALCULATE(CAL)>CALCULATE(CAL)</a> <a href=#LGO>GO</a>
 <a href=#LDP0>DP0</a> <a href=#LFSHIFT>FSHIFT</a></pre>
<li><h3><a name=LREAL>REAL</a></h3>
<pre>REAL is the antonym of IDEAL.</pre>
<pre>See also:
 <a href=#LIDEAL>IDEAL</a></pre>
<li><h3><a name=LRELW>RELW</a></h3>
<pre>RELW is the antonym of ABSW.</pre>
<pre>See also:
 <a href=#LABSW>ABSW</a></pre>
<li><h3><a name=LRFSW>RFSW</a></h3>
<pre>RFSW turns on the acceleration by CAVI and TCAVI element in the particle-tracking and the emittance
calculation. Accessible in MAIN level, but FFS always turns RFSW on at the beginning of the session.</pre>
<li><h3><a name=LRING>RING</a></h3>
<pre>RING is the antonym of TRPT.</pre>
<pre>See also:
 <a href=#LTRPT>TRPT</a></pre>
<li><h3><a name=LSELFCOD>SELFCOD</a></h3>
<pre>When on with WSPAC, in tracking, the space charge force is calculated relative to the center of mass
of the current set of particles each time. Otherwise(default) it is calculated relative to the closed
orbit given by EMIT. SELFCOD is useful when the closed orbits given by EMIT and TRACK are different.</pre>
<pre>See also:
 <a href=#LWSPAC>WSPAC</a></pre>
<li><h3><a name=LSORG>SORG</a></h3>
<pre>SORG sets the origin of S (design orbit length) at the location set by ORG.</pre>
<pre>See also:
 <a href=#LORG>ORG</a></pre>
<li><h3><a name=LSPAC>SPAC</a></h3>
<pre>When SPAC is on, tracking is done with space charge effect. The actual number of particles in the
beam and the number of macro particles are given by PBUNCH and NP, respectively. This calculation
assumes a cylindrical symmetry of the chamber whose radius is given by RADIUS of DRIFT and MULT elements.
If RADIUS is positive, an aperture is also set at RADIUS to make particle loss. If RADIUS is zero,
no space charge calculation is done. If RADIUS is negative, no space charge effect is taken, but
the aperture is set at -RADIUS.
   Do not confuse SPAC with WSPAC.</pre>
<pre>See also:
 <a href=#LNP>NP</a> <a href=#LPBUNCH>PBUNCH</a> <a href=#LWSPAC>WSPAC</a></pre>
<li><h3><a name=LSTABLE>STABLE</a></h3>
<pre>STABLE is a flag set by the CALCULATE(CAL) or GO commands in the case of CELL. It becomes True when
the closed orbit is found and the optics is stable in both x and y.</pre>
<pre>See also:
 <a href=#LCALCULATE(CAL)>CALCULATE(CAL)</a> <a href=#LGO>GO</a> <a href=#LINTRES>INTRES</a> <a href=#LHALFRES>HALFRES</a> <a href=#LSUMRES>SUMRES</a> <a href=#LDIFFRES>DIFFRES</a></pre>
<li><h3><a name=LSUMRES>SUMRES</a></h3>
<pre>In the case of CELL, if the total tune deviates across a sum resonance, it is counted as unstable.
The default is SUMRES.</pre>
<pre>See also:
 <a href=#LINTRES>INTRES</a> <a href=#LHALFRES>HALFRES</a> <a href=#LDIFFRES>DIFFRES</a> <a href=#LSTABLE>STABLE</a></pre>
<li><h3><a name=LSUS>SUS</a></h3>
<pre>If OFF, SUSPEND(SUSP) and END commands have no action. The default is ON.</pre>
<pre>See also:
 <a href=#LSUSPEND(SUSP)>SUSPEND(SUSP)</a> <a href=#LEND>END</a></pre>
<li><h3><a name=LTRPT>TRPT</a></h3>
<pre>TRPT or NORING declares that the beam line is a transport line, not a part of a storage ring. The
nominal momentum be changed in the beam line due to acceleration. The default momentum distribution
becomes uniform distribution. The default is RING or NOTRPT. TRPT affects Emittance[] to ignore equilibrium
calculation for a transport line.</pre>
<pre>See also:
 <a href=#LDISPLAY(DISP)>DISPLAY(DISP)</a> <a href=#LRING>RING</a> <a href=#LUNIFORM>UNIFORM</a> <a href=#LGAUSS>GAUSS</a></pre>
<li><h3><a name=LTWAKE>TWAKE</a></h3>
<pre>TWAKE turns on optics calculation with Transverse WakeFunction</pre>
<pre>See also:
 <a href=#LWakeFunction>WakeFunction</a> <a href=#LTrackParticles>TrackParticles</a> <a href=#LInitialOrbits>InitialOrbits</a> <a href=#LLWAKE>LWAKE</a></pre>
<li><h3><a name=LUNIFORM>UNIFORM</a></h3>
<pre>UNIFORM is the antonym of GAUSS. It assumes the momentum distribution to be a uniform(square) within
+-DP.</pre>
<pre>See also:
 <a href=#LGAUSS>GAUSS</a> <a href=#LTRPT>TRPT</a></pre>
<li><h3><a name=LUNIPOL>UNIPOL</a></h3>
<pre>UNIPOL is the antonym of BIPOL.</pre>
<pre>See also:
 <a href=#LBIPOL>BIPOL</a></pre>
<li><h3><a name=LUNSTABLE>UNSTABLE</a></h3>
<pre>UNSTABLE is the antonym of STABLE.</pre>
<pre>See also:
 <a href=#LSTABLE>STABLE</a></pre>
<li><h3><a name=LWSPAC>WSPAC</a></h3>
<pre>When on, performs space-charge simulation in a "strong-weak" mode. The beam size through the beam
line is to be calculated by EMIT with CODPLOT. The space-charge force is calculated assuming Gaussian
distribution in all dimensions, and particles/bunch given by PBUNCH. WSPAC is effective in optics
and emittance calculations and tracking.
   Do not confuse WSPAC with SPAC.</pre>
<pre>See also:
 <a href=#LEMITTANCE(EMIT)>EMITTANCE(EMIT)</a> <a href=#LPBUNCH>PBUNCH</a> <a href=#LCODPLOT>CODPLOT</a> <a href=#LMINCOUP>MINCOUP</a> <a href=#LSELFCOD>SELFCOD</a> <a href=#LSPAC>SPAC</a> <a href=#Lequilibrium-beam-envelope>equilibrium-beam-envelope</a>
</pre>
</ul>
<h3><a name=Lfunctions>functions</a></h3>
<pre>FFS functions:

Constants:
   Degree GoldenRatio I INF* Infinity NaN* Pi SpeedOfLight
Elementary-functions:
   ArcCos ArcCosh ArcSin ArcSinh ArcTan ArcTanh Cos Cosh Exp Log Sin Sinh
   Sqrt Tan Tanh
Special-functions:
   BesselI BesselJ BesselK BesselY BesselJZero Erf Erfc Factorial 
   Gamma LogGamma LogGamma1 GammaRegularized GammaRegularizedQ*
   GammaRegularizedP* GaussianCoulomb* GaussianCoulombU*
   GaussianCoulombFitted* LegendreP*
Numerical-functions:
   Abs Ceiling Floor Max Min MinMax* Mod Negative NonNegative Positive
   Round Sign FractionalPart
Matrix-operations:
   Det Eigensystem IdentityMatrix Inner LinearSolve Outer SingularValues*
   Transpose
Random-number:
   GaussRandom* Random* SeedRandom
Complex:
   Arg Complex ComplexQ Conjugate Im Re
Rational:
   Rational FromRational ContinuedFraction FromContinuedFraction SmallPrime
   Numerator Denominator
Fourier-Transformation:
   Fourier InverseFourier
Data-Manipulation:
   FindRoot Fit* NIntegrate* PolynomialFit* Spline*
Calculus:
   D NIntegrate
Minimization:
   DownhillSimplex*
List-manipulations:
   Append Complement Delete Depth Difference* Dimensions Drop Extract Flatten
   FlattenAt HeldPart Insert Intersection Join Length Part Partition Prepend
   Product Range ReplacePart Rest Reverse RotateLeft RotateRight Select 
   Sort Sum Take Table Union
Character-strings:
   FromCharacterCode CharacterPosition Characters DigitQ LetterQ StringDrop
   StringFill* StringInsert StringLength StringPosition StringTrim*
   Symbol SymbolName ToCharacterCode ToLowerCase ToUpperCase ToExpression
Functional-Operations:
   Apply Cases Count DeleteCases Identity FixedPoint* FixedPointList*
   Fold Function Level Map MapAll MapAt MapIndexed MapThread Nest Position
   Replace Scan ScanThread* SelectCases* SwitchCases* Thread
Object-oriented programing and context:
   Begin BeginPackage Class* End EndPackage
Flow-Control:
   Break Catch Check Continue Do For Goto If Label Return Switch Throw Which
   While
Tests:
   AtomQ ComplexQ DirectoryQ* EvenQ FileQ* MatchQ MatrixQ MemberQ NearlySameQ* 
   Negative NonNegative NumberQ OddQ Order Positive RealQ StringQ* VectorQ
   BoundQ* FBoundQ*
Input/Output:
   Close Flush* Get OpenRead OpenWrite OpenAppend Print Put Read ReadString SeekFile*
   Short* StringToStream Write WriteString
File System:
   CopyDirectory CopyFile CreateDirectory DeleteDirectory DeleteFile
   DirectoryName FileByteCount FileDate FileNames FileType
   RenameDirectory RenameFile SetFileDate ToFileName
Scoping:
   Block Module With*
Attributes:
   Attributes* Clear Evaluate Head Hold Literal Protect ReleaseHold
   SetAttributes* Unevaluated Unprotect
GUI Widget:
   Window* PanedWindow* Frame* LabelFrame* Canvas* TextLabel* TextMessage*
   Button* CheckButton* RadioButton* Menu* OptionMenu* MenuButton*
   Entry* SpinBox* ListBox* ScrollBar* Scale* TextEditor*
Graphics:
   BeamPlot* ColumnPlot* HistoPlot* ListContourPlot ListDensityPlot 
   ListPlot Plot Show FitPlot* GeometryPlot* OpticsPlot* TkPhotoPutBlock*
System Interface:
   Directory Environment GetEnv* GetGID* GetPID* GetUID* ProcessStatus* 
   SetDirectory SetEnv* System* TemporaryName* MkSecureTemp* RealPath*
Multiprocessing:
   BiPipe* Fork* OpenShared* Shared* Wait*
Utilities:
   Date DateString* Definition* FromDate* ToDate ToDateString* Pause
   MemoryCheck* Message Off On Sleep TimeUsed Timing TracePrint

Functions listed above work basically in the same way as Mathematica's 
except those marked by *.

FFS-dedicated-functions:
   BeamMatrix CalculateOptics DynamicApertureSurvey Element Emittance FFS
   FitValue FitWeight GeoBase LINE OptimizeOptics OrbitGeo RadiationField
   RadiationSpectrum SymplecticJ SetElement TrackParticles Twiss VariableRange
   SynchroBetaEmittance TouschekLifetime WakeFunction
Beam-line-functions:
   BeamLine BeamLineName ExtractBeamLine PrintBeamLine WriteBeamLine</pre>
<pre>See also:
 <a href=#Lexpression>expression</a> <a href=#Lconstants>constants</a> <a href=#Lphysical-constants>physical-constants</a> <a href=#Lbeam-line-functions>beam-line-functions</a>
</pre>
<ul>
<li><h3><a name=LData-Manipulation>Data-Manipulation</a></h3>
<pre></pre>
<ul>
<li><h3><a name=LFit>Fit</a></h3>
<pre>Usage: Fit[data, expr, var, 
         {par1, ini1, [{min1, max1}] }, .. ,{parn, inin, [{minn, maxn}]},
         [options..] ]

performs a nonlinear fitting of data with an expression expr.

data: list of {xi,yi}, {xi,yi,dyi}, or {xi,yi,dxi,dyi}, where dxi and dyi
      are the standard deviation of the i-th point.
expr: an expression containing var as the x-variable, and 
      parameters par1,..,parn explicitly. Use Evaluate[fun] if an implicit
      expression is necessary.
var:  a symbol to express the x-axis variable.
par:  parameter symbol to be varied in the fitting.
ini:  initial value of the parameter. It must be specified.
(min, max}: optional range of parameter.

Fit returns the result as a list:

{par1 -> v1, .., parn->vn, ChiSquare -> chisq, GoodnessOfFit -> good,
ConfidenceInterval -> {c1, .., cn}, ConvarianceMatrix -> cov},

where v1,..,vn are the values of the parameters which minimizes chi-square, chisq is the resulting
minimum value of the total chi-square (when no error is given for yi, variance is returned), good
is a number given by GammaRegularized[(ndata-npara)/2,chisq/2] to represent the goodness of the fit,
c1, .., cn are the estimated errors in parameters, and cov is the covariance matrix. A typical criterion
of the goodness is (good > 0.1).

   Options are

MaxIterations        Maximum number of iterations.
D                    If True (default), tries to use analytical derivative.
Cutoff               If nonzero, set the saturation point for each data as:

chi-suare = Sum_i ( Min[Cutoff, Max[-Cutoff, (d_i - f_ i) / sigma_i]]^2 ) ,

                     which is a sort of robust M-Estimates. By Cutoff, the fit
                     tends to ignore tail data which are beyond Cutoff.
                     If Cutoff is zero (default), it is ignored.</pre>
<pre>See also:
 <a href=#LFitPlot>FitPlot</a></pre>
<li><h3><a name=LFitEmit>FitEmit</a></h3>
<pre>Obtain the emittance, beta, alpha, etc. from data of particles x and px using FitGaussian.

  FitEmit[x, px] ,

where x and px are the lists of data of the particles in the phase space, returns a list

  {{xmean, pxmean, alpha, beta, emittance},
   {xmean, pxmean, alpha, beta, emittance}_conf},

where the second component is the confidence intervals of the results.</pre>
<pre>See also:
 <a href=#LFitGaussian>FitGaussian</a></pre>
<li><h3><a name=LFitGaussian>FitGaussian</a></h3>
<pre>Performs Gaussian fit of 1D list data:

  FitGaussian[data, [opt, ...]]

returns a list

  {sigma, mean, {sigma_conf, mean_conf}, chisq} ,

where sigma_conf and mean_conf are the confidence interval of the results sigma and mean, respectively.
The arguments opt... are options for Fit. If Plot -> True is specified as the option, a plot of the
fitting will be made.</pre>
<pre>See also:
 <a href=#LFit>Fit</a> <a href=#LFitEmit>FitEmit</a></pre>
<li><h3><a name=LNIntegrate>NIntegrate</a></h3>
<pre>NIntegrate returns numerical integration of a Real or Complex
function

Usage:   NIntegrate[f, {x, x0, x1}, options]

where f is a function containing Symbol x as the independent variable. The integral range is from
x0 and x1. The function f must contain the symbol x explicitly.

Options           Default      Description
-------------------------------------------------------------
AccuracyGoal      1e-13        Relative accuracy
InitialPoints     20           Number of initial points where
                               the function is evaluated.</pre>
<li><h3><a name=LPolynomialFit>PolynomialFit</a></h3>
<pre>Usage: PolynomialFit[data, n]

performs a 1D linear regression of data.

data: list of {xi,yi}
n: the order of the polynomial

Fit returns the result as a list:

{{c0, .., cn}, {Residual -> res}} ,

where c0 .. cn are the coefficients of the fitted polynomial, y = c0 + c1 x + .. + cn x^n . Res is
the rms residual of the fit.</pre>
<pre>See also:
 <a href=#LFitPlot>FitPlot</a></pre>
<li><h3><a name=LSpline>Spline</a></h3>
<pre>Spline returns data for cubic-spline interpolation.

Usage:   sp = Spline[list, [Derivative->{dy1,dy2}] ]

where list contains data in the form as {{x1,y1}, ..} or {{x1,{y11, y12, ..}}, ..}.
 Complex number can be allowed for y, but not for x.

 This spline assumes y''=0 at the boundary, unless Derivative->{dy1,dy2} is specified to constrain
the derivative at each end to dy1 or dy2. They can be Null to unspecify the constraint at one of
the boundary. The resulting data of the spline is assigned sp as a SplineData object. Then one can
calculate the interpolated data by

    sp[x]                     value of y at x.
    Derivative[1][sp][x]      value of y' at x.
    Derivative[2][sp][x]      value of y'' at x.
    Integrate[sp[x],{x, x0, x1}]   integral of sp[x] from x0 to x1.

Example:
   sp=Spline[{{1,2},{3,5},{4,2},{5,7}}];
   Plot[{sp[x],Derivative[1][sp][x],Derivative[2][sp][x],Integrate[sp[y],{y,1,#}]&[x]}, {x,1,5},
FrameLabel->{"x"}, Thickness->2, Legend->{"sp[x]","sp'[x]","sp''[x]","Int sp[x]"}];
   Update[];

<img src="SADHelp_img/Spline.png" align="middle" width=540>
</pre>
<pre>See also:
 <a href=#Ldefining-functions>defining-functions</a> <a href=#LPlot>Plot</a> <a href=#LNIntegrate>NIntegrate</a></pre>
</ul>
<li><h3><a name=LDownhillSimplex>DownhillSimplex</a></h3>
<pre>Usage: DownhillSimplex[initial, f, options]

minimizes a function f by the downhill simplex method, starting from an initial simplex initial.
 Suppose f is a function of n variables.   Then  initial is a list of n+1 elements, each of which
is a list of the form

   {f[vi], vi} ,

where vi is a list of n values corresponding to each variable. The initial must be sorted in ascending
order of f, i.e.,

   initial=Sort[Map[{f[#],#}&,vlist]]

generates initial from a list of variables vlist.
   DownhillSimplex returns the final simplex in the same form as initial.

Options:
   VariableRange -> {{min1 .. minn}, {max1 .. maxn}} gives the range of n
      variables.   The default is -Infinity to Infinity for all variables.
   MaxIteration -> maxi gives the limit of number of iterations.   The
      default is Max[100, 10*(n+1)].
   Output -> lfn sets the output file number for the intermediate results.
      the default is 6 (stdout).
   Tolerance -> tol sets the tolerance to judge the local minimum.
      If (fmax-fmin)/(abs(fmax)+abs(fmin)) becomes less than tol, the 
      iteration loop terminates.   The default is 10^-6.

Examples:
  f:=Apply[Function[{x,y},((x^2+y^2)-1)*(x^2+y^2)-(x-.5)/3.],#]&;
  v={{1.,1.},{0.,-1.},{0.,1.}};
  limit={{-0.5,-1.5},{0.65,1.5}};
  p=Sort[Map[{f[#],#}&,v]]
  DownhillSimplex[p,f,MaxIteration->100,
     Tolerance->1e-4,VariableRange->limit]</pre>
<pre>See also:
 FFS-dedicated-functions:OptimizeOptics</pre>
<li><h3><a name=Lfunctional-operations>functional-operations</a></h3>
<pre></pre>
<ul>
<li><h3><a name=LApply>Apply</a></h3>
<pre>   Apply[f, x [, level]] or f@@x [f@@[x, level]] 

takes the bod of a list x as the argument sequence of f, and returns the result:

f@@{a, b, c} ===> f[a, b, c]

An optional argument specifies the level-spec.</pre>
<pre>See also:
 <a href=#LApply (@@)>Apply (@@)</a> <a href=#LMap>Map</a> <a href=#LScan>Scan</a> <a href=#LMapThread>MapThread</a> <a href=#Llevel-spec>level-spec</a></pre>
<li><h3><a name=LCases>Cases</a></h3>
<pre>   Cases[l, pat [, level [,n]]]

returns a list of parts of l, which match a pattern pat. Optional level-spec l and the maximum number
of results n can be specified.</pre>
<pre>See also:
 <a href=#Llevel-spec>level-spec</a> <a href=#Lpattern>pattern</a> <a href=#LPosition>Position</a> Deletecases</pre>
<li><h3><a name=LDeleteCases>DeleteCases</a></h3>
<pre>   DeleteCases[l, pat [, level [,n]]]

returns a list of parts of l, which do not match a pattern pat. Optional level-spec l and the maximum
number of results n can be specified.</pre>
<pre>See also:
 <a href=#Llevel-spec>level-spec</a> <a href=#Lpattern>pattern</a> <a href=#LCases>Cases</a> <a href=#LPosition>Position</a></pre>
<li><h3><a name=LDifference>Difference</a></h3>
<pre>Difference[list] returns Rest[list] - Drop[list, -1] .</pre>
<li><h3><a name=LFixedPoint>FixedPoint</a></h3>
<pre>FixedPoint[f, e] starts from f[e] then applies f repeatedly until the result no longer changes. FixedPoint[f,
e, n] specifies the maximum number of iterations by n. An option SameTest->s specifies the test function.
Threshold->re, and AbsoluteThreshold->ae set the relative and absolute accuracy, respectively, when
SameTest->NearlySameQ (default).</pre>
<pre>See also:
 <a href=#LFixedPointList>FixedPointList</a></pre>
<li><h3><a name=LFixedPointList>FixedPointList</a></h3>
<pre>FixedPointList[f, e] returns the intermediate values of FixedPoint[f, e] as a list. FixedPointList[f,
e, n] and options for FixedPoint are valid.</pre>
<pre>See also:
 <a href=#LFixedPoint>FixedPoint</a></pre>
<li><h3><a name=Llevel-spec>level-spec</a></h3>
<pre>Functions Map, Apply, Scan, Cases, Position, Count, Level, DeleteCases takes an optional argument
level to specify which level to operate:

value               operates
n_Real              from level 1 through level n
{n_Real}            only on level n
{n1_Real, n2_Real}  from leveln1 through level n2


If n is negative, it counts from the deepest level of each element.

Examples: f@@[{{a, b}, {c, d}}, {1}] ===> {f[a, b], f[c, d]}</pre>
<pre>See also:
 <a href=#LMap>Map</a> <a href=#LApply>Apply</a> <a href=#LScan>Scan</a> <a href=#LCases>Cases</a> <a href=#LPosition>Position</a> Count Level <a href=#LDeleteCases>DeleteCases</a></pre>
<li><h3><a name=LMap>Map</a></h3>
<pre>   Map[f, x [, level]] or f/@x [f/@[x, level]] 

operates f over each element of a list x and returns the result as a list:

f/@{a, b, c} ===> {f[a], f[b], f[c]}

An optional argument specifies the level-spec.</pre>
<pre>See also:
 @/ <a href=#LScan>Scan</a> <a href=#LApply>Apply</a> <a href=#LMapThread>MapThread</a> <a href=#Llevel-spec>level-spec</a></pre>
<li><h3><a name=LMapThread>MapThread</a></h3>
<pre>   MapThread[f, l] ===> f@@[Thread[l], {1}]

Example: MapThread[f, {{1, 2}, {3, 4}}] ===> {f[1, 3], f[1, 4]}</pre>
<pre>See also:
 <a href=#LScanThread>ScanThread</a> <a href=#LThread>Thread</a> <a href=#LMap>Map</a> <a href=#LApply>Apply</a></pre>
<li><h3><a name=LPosition>Position</a></h3>
<pre>   Position[l, pat [, level [,n]]]

returns a list of indices of parts of l, which match a pattern pat. Optional level-spec l and the
maximum number of results n can be specified.</pre>
<pre>See also:
 <a href=#Llevel-spec>level-spec</a> <a href=#Lpattern>pattern</a> <a href=#LCases>Cases</a> <a href=#LDeleteCases>DeleteCases</a></pre>
<li><h3><a name=LScan>Scan</a></h3>
<pre>   Scan[f, x [, level]]

operates f over each element of a list without returning the result:

Scan[f, {a, b, c}] ===> {f[a], f[b], f[c]};Null 

An optional argument specifies the level-spec.</pre>
<pre>See also:
 <a href=#LMap>Map</a> <a href=#LApply>Apply</a> <a href=#LMapThread>MapThread</a> <a href=#Llevel-spec>level-spec</a></pre>
<li><h3><a name=LScanThread>ScanThread</a></h3>
<pre>   ScanThread[f, l] ===> (f@@[Thread[l], {1}];Null) ,

which is equivalent to MapThread without returning the results.</pre>
<pre>See also:
 <a href=#LMapThread>MapThread</a> <a href=#LThread>Thread</a> <a href=#LMap>Map</a> <a href=#LApply>Apply</a></pre>
<li><h3><a name=LSelectCases>SelectCases</a></h3>
<pre>Usage: SelectCases[list, {test1,..}]

returns a list {list1, .. }, where list1 is a list of subexpressions which makes test1 True, etc.
If the second argument is like {c1, .. , True&},  the last of the returned list contains subexpressions
which make none of c1, ... True.</pre>
<pre>See also:
 <a href=#LSwitchCases>SwitchCases</a></pre>
<li><h3><a name=LSwitchCases>SwitchCases</a></h3>
<pre>Usage: SwitchCases[list, {case1,..}]

returns a list {list1, .. }, where list1 is a list of subexpressions which match case1, etc. SwitchCases
does what are done by Cases and DeleteCases simultaneously. If the second argument is like {c1, ..
, _}, the last of the returned list contains subexpressions which match none of c1, ...</pre>
<pre>See also:
 <a href=#LSelectCases>SelectCases</a></pre>
<li><h3><a name=LThread>Thread</a></h3>
<pre> Thread[l] returns a threaded list of l:

   Thread[{{1, 2}, {3, 4}}] ===> {{1, 3}, {2, 4}}
   Thread[{{1, 2}, {3, 4}, 5}] ===> {{1, 3, 5}, {2, 4, 5}}

 If an optional second argument h is given, Thread operates only over on a structure whose head is
h:

   Thread[{{1, 2}, {3, 4}} , f] ===> {{1, 2}, {3, 4}}
   Thread[{f[1, 2], f[3, 4]} , f] ===> f[{1, 3}, {2, 4}]
   Thread[f[f[1, 2], f[3, 4]] , f] ===> f[f[1, 3], f[2, 4]]

 Thread is equivalent to Transpose if l is a matrix.</pre>
<pre>See also:
 <a href=#LMapThread>MapThread</a> Transpose</pre>
</ul>
<li><h3><a name=LFFS-dedicated-functions>FFS-dedicated-functions</a></h3>
<pre>Functions dedicated to the optics calculations and simulations in FFS.</pre>
<ul>
<li><h3><a name=LAccelerateParticles>AccelerateParticles</a></h3>
<pre>AccelerateParticles does TrackParticles with acceleration in a ring for a given number of turns.
The adiabatic damping is automatically taken cared.

Usage:    AccelerateParticles[beam_,mom_,{n_Symbol,nturn_},opt___]

where beam is a list of beam coordinates in the same format for TrackParticles. mom is an expression
to determine MOMENTUM in each turn as a function of turn number n. nturn is the total number of turns.
An option Synchronize specifies a routine to be executed at every turn of the tracking (e.g. changing
voltages and magnet settings, or storing the results.)

Example:
  AccelerateParticles[
    beam,
    Which[
      n < 100,  1e9,
      n <= 200, 1e9 + (n - 100) * 1e7,
      True, 2e9],
    {n, 300},
    Synchronize :> ((
      d = {d, MOMENTUM/1e9 * (1 + #2[[2,6,1]])})&)];</pre>
<pre>See also:
 <a href=#LTrackParticles>TrackParticles</a></pre>
<li><h3><a name=LBeamMatrix>BeamMatrix</a></h3>
<pre>BeamMatrix[i] returns a 6 by 6 beam-matrix (i.e., <x_k x_l>) at location i. The index i can have
a fraction to specify intermediate numbers (see LINE or Twiss). The calculation is based on linear
4 by 5 calculation in the present version, so the z-direction is meaningless. Flag GAUSS affects
the result.</pre>
<pre>See also:
 <a href=#LLINE>LINE</a> <a href=#LTwiss>Twiss</a> <a href=#LGAUSS>GAUSS</a></pre>
<li><h3><a name=LDynamicApertureSurvey>DynamicApertureSurvey</a></h3>
<pre>Usage: DynamicApertureSurvey[range,nturn,options]

where

range: a list of {xrange,yrange,zrange}, with
       xrange: {xmin, xmax},
       yrange: {ymin, ymax},
       zrange: {zmin, zmax},
       and for the horizontal plane, specified by the Axes option, 
       the corresponding range must be given as {v1, ..., vn}.
       These values are the initial amplitude divided by the equilibrium 
       values, i.e., Sqrt[2Jx,y/(EMITX+EMITY)], Sqrt[2Jz/EMITZ].
       See EMITTANCE(EMIT) command or Emittance function.
nturn: number of turns to track.
options: Output->lfn : output to the unit lfn (see OpenWrite).
         Axes->axes : one of "XY", "XZ", "YX", "YZ", "ZX", "ZY",
          where the first character specifies the horizontal axis, and
          the second the vertical, respectively. The default is "ZX".
         ReferenceOrbit->{x0, px0, y0, py0, z0, dp0} : Survey is done around
          this orbit.
         PhaseX->phix : The initial amplitude is rotated in (X, PX) phase space
          by phix. Default is zero.
         PhaseY->phiy : The initial amplitude is rotated in (Y, PY) phase space
          by phiy. Default is zero.
         PhaseZ->phiz : The initial amplitude is rotated in (Z, PZ) phase space
          by phiz. Default is -Pi/2.
         ExpandElementValues->True(default) : set the values of the components
          according to the values of elements. Machine errors may be reset.
          See machine-error-commands, CALCULATE(CALC).

   DynamicApertureSurvey returns the result as a list:

   {score,{{{xmin, xmax},{ymin, ymax},{z1, z2, .., zn}},
           {{z1,score1,{turn1_1,..,turn1_50}},..,
            {zn,scoren,{turnn_1,..,turnn_50}}}}} ,

where score = Sum[scorei,{i,n}], scorei is the "score" of i-th momentum, and turni_j is the lost
turn of the particle with i-th momentum and j-th initial amplitude.
   DynamicApertureSurvey tracks number of particles with different initial conditions in the range
given by range. It outputs a z-x diagram of the dynamic aperture of the ring. Fifty one initial conditions
are chosen in the range x-range for each point of z-range. The initial y-amplitude is linearly dependent
on the x-amplitude. It tracks from xmax to downward for each z-amplitude zn, until the particles
turns nturn with successive DAPWIDTH x-amplitudes. The default DAPWIDTH is 7.
  DynamicApertureSurvey does parallel processing up to NPARA processes.</pre>
<pre>See also:
 <a href=#LNPARA>NPARA</a> <a href=#LDAPWIDTH>DAPWIDTH</a> <a href=#LEMITTANCE(EMIT)>EMITTANCE(EMIT)</a> <a href=#LEmittance>Emittance</a></pre>
<li><h3><a name=LElement>Element</a></h3>
<pre>Element[key-string, {element-pattern-string | element-position}] returns values for key-string of
elements which match element-pattern-string or located at element-position. It returns a list if
more than one elements match. The key-string and element-pattern-string can be symbols, unless values
are not assigned to them.
   If the second argument is omitted, it means all elements.
   The element-position can be known by Element["POSITION"].
   Key-strings "VALUE" and element-keywords allows to be set (i.e., Element[a,b] = v) when element-pattern-string
chooses only one element. If a value is set to Element, it is automatically distributed to all components
those belong to the element. If the keyword is the default variable, the error given by machine-error-command
DK is applied.
   The arguments of Element can be lists. It automatically maps as

   Element[{a,b,c..},y]  means {Element[a,y],Element[b,y],Element[c,y]..}
   Element[x,{a,b,c..}]  means {Element[x,a],Element[x,b],Element[x,c]..},

where both x and y can be also a list.

   If an option Saved->True is given, Element refers the save-buffer which can be transferred to
other beam lines. Otherwise values set by Element are not saved when FFS is stopped, unless they
are the default-keyword or keywords once used in matching.</pre>
<pre>See also:
 <a href=#Lelements>elements</a> <a href=#Lwildcards>wildcards</a> <a href=#Lcomponents>components</a> <a href=#LLINE>LINE</a> <a href=#LSetElement>SetElement</a></pre>
<ul>
<li><h3><a name=Lkey-strings:Element>key-strings:Element</a></h3>
<pre>The key-string is not case-sensitive. Available key-strings are:

            
"LENGTH"    Number of elements in the beam line. No second argument.
"POSITION"  Position of the element in the element-list.
"NAME"      Name of the element.
"VALUE"     Current value of the default keyword of the element.
"KEYWORDS"  List of available keywords of the element.
"DEFAULT"   The default keyword of the element
"TYPE"      The internal code-number of the type of the element.
"TYPENAME"  The name of the type of the element.
keyword     If keyword is the default keyword, it means the current value. If not, it means the saved
            value. Changing the non-default keyword by Element does not affects the current setting
            of the components.
"EXPAND"    Distribute the value of the default-keywords and the keywords used in the matching to
            all components in the beam line. No second argument.

Setting by Element["VALUE",..] or Element[keyword,..] to the DEFAULT  keyword or a matching-variable
keyword changes the current value, and  distributed to the components in the succeeding calculation.</pre>
<pre>See also:
 <a href=#Lset-value-of-element>set-value-of-element</a> <a href=#Lelements>elements</a> <a href=#Lkeywords>keywords</a> <a href=#Ldefault-keyword>default-keyword</a>
 <a href=#Lcomponents>components</a></pre>
</ul>
<li><h3><a name=LEmittance>Emittance</a></h3>
<pre>Emittance[option] returns a set of rules as 

   {keyword1->value1, keyword2->value2, ..} .

Its options and default values are Matrix(False), Orbit(False), OneTurnInformation(False), Emittance(True),
ExpandElementValues(True), SaveEMIT(False), InitialOrbit(Null), InitialBeamMatrix(Null), Region({1,-1}),
and Output(0).

If Emittance->False is specified, the resulting keywords are:

                     
Stable               True if all modes are stable and the closed orbit is found.
Region               The region {begin, end} to calculate.
Tunes                {nux, nuy, nuz} .
EnergyLossU0         One turn energy loss in eV.
RfVoltageVc          The effective RF voltage (V).
EquilibriumPosition  dz in meter.
MomentumCompaction   -dz/dp
OrbitDilation        ds in meter.
BucketHeight         dV/E0
HarmonicNumber       The effective harmonic number
OrbitAtExit          physical c.o.d. at the end of line.

If None of the options is given, the following keywords are added:

                      
DampingRate           {T0/taux, T0/tauy, T0/tauz}
Emittances            {emitx, emity, emitz} *1)
MomentumSpread        sigma p/p0
BunchLength           sigma_z
Polarization          equilibrium polarization, if POL is on
Polarization2         equilibrium polarization by up to 2nd order calculation
Polarization4         equilibrium polarization by up to 4th order calculation
Polarization6         equilibrium polarization by up to 6th order calculation
PolarizationVector    direction of polarization AppendTo the entrance of the beam line
SpinTune              spin tune on the closed orbit
NominalSpinTune       spin tune calculated by MOMENTUM and electron g-2
TuneShiftByRadiation  {dnux, dnuy, dnuz}

If OneTurnInformation->True, or Orbit->True, or Matrix->True, the followings are added.

                         
OrbitAtEntrance          physical c.o.d. at the entrance of the ring.
OneTurnTransferMatrix    symplectic part of the one-turn transfer matrix.
OneTurnDampingMatrix     deviation of transfer matrix due to radiation.
NormalCoordinates        conversion matrix from physical to normal coords.
OneTurnExcitation        excitation matrix by radiation and intrabeam scattering (with INTRA).
EquilibriumBeamMatrix    equilibrium beam matrix.
ExtendedTwissParameters  list of rules giving the extended Twiss parameters at the entrance of the
                         ring.

If Orbit->True or Matrix->True, the following is added:

             
ClosedOrbit  List of physical closed orbit at every element in the ring.

If Matrix->True, the followings are added:

                     
TransferMatrices     List of physical transfer matrix from the beginning of the beam line to all
                     elements.
IntrabeamExcitation  List of the change of the 6 x 6 beam matrix due to the intrabeam scattering
                     (only when INTRA), converted to the beginning of the beam line.

   If the flag TRPT or NORING is set, the calculation assumes a transport line so that several quantities
such as damping rate, eigen modes, equilibrium beam matrix, etc. are meaningless. Use RING or NOTRPT
for such calculation. In the case of TRPT or NORING, the incoming beam envelope must be given by
the option InitialBeamMatrix with a 6 x 6 symmetric matrix. TRPT is useful for calculation of space
charge and intrabeam in a transport line.
   Please do not forget to put semicolon at the end of Emittance[] function, otherwise the output
will be huge especially when Orbit or Matrix is True.
 If ExpandElementValues->False, calculation is made using the present values of each component (i.e.,
including machine errors).

If SaveEMIT->True, the calculated values of emittances are stored in variables EMITX, EMITY, EMITZ,
SIGE, SIGZ. The default is SaveEMIT->False.

InitialOrbit->{x0,px0,y0,py0,z0,dp0/p0} specifies the incoming orbit which is valid when NOCOD is
set. The option Output->filenum enables the print out of EMITTANCE(EMIT) to filnum.

If Region is not the entire ring, parameters such as Emittances and DampingRate, etc., are not calculated,
and return NaNs.

*1) The values of Emittances with INTRA and MINCOUP correspond to the equilibrium with intrabeam
scattering weakened by MINCOUP.</pre>
<pre>See also:
 <a href=#LEMITTANCE(EMIT)>EMITTANCE(EMIT)</a> <a href=#LSymplecticJ>SymplecticJ</a> <a href=#LCOD>COD</a> <a href=#LEMITX>EMITX</a> <a href=#LEMITY>EMITY</a> <a href=#LEMITZ>EMITZ</a> <a href=#LSIGZ>SIGZ</a> <a href=#LSIGE>SIGE</a>
 <a href=#LPOL>POL</a> <a href=#LMINCOUP>MINCOUP</a> <a href=#Lequilibrium-beam-envelope>equilibrium-beam-envelope</a></pre>
<li><h3><a name=LExternalMap>ExternalMap</a></h3>
<pre>With MAP elements, ExternalMap defines a user-defined map of particles. It also allows a user to
do anything (doing statistics, etc.) at any point of a beam line during a tracking. 

Usage: First define a MAP element at MAIN level:

     MAP    name=(L=leng);

Right now L is the only keyword. Insert it at the location(s) 
where you want to use it.

1) Tracking
In FFS, define the function ExternalMap as

    ExternalMap["TRACK",n,nt_,x_]:=body;

The second argument n is the position of MAP counting from the beginning, which can be obtained using
LINE["POSITION","name.m"]. The third argument nt_ is used to receive the number of turns which is
incremented by the tracking. The last argument x_ is used to receive the coordinates of particles.
It is a (7, np) list of real numbers. The elements  (1..6, i) are (x, px ,y ,py ,z ,dp/p0) of the
i-th particle. The (7, i)  element is True(==1) if the i-th particle has been survived, and False(==0)
if it has been lost.

 You can define ExternalMap to change the coordinates of each particle as you like by returning a
new x in the same format as above. If you do not return it or you return in a different format, the
tracking routine does not change the particle coordinates. You can neither rebirth a lost particle
nor kill a surviving particle.

After defined ExternalMap, tracking calls it in every turn.

Example:

   MAP P1=();
   ....
   LINE A=(... P1 ... P1 ...);
   ....
   FFS USE=A;
     ExternalMap["TRACK",LINE["POSITION","P1.2"],nt_,x_]:=
(Print[x];x(Print[x];x*2);
....       ....
           
TRACK      USE=A ....;
           
This       example defines ExternalMap to print out the coordinates of all
particles  at the second P1 in the line A. It also makes all coordinates
of         all particles twice in every turn.
           
2)         Emittance
In         FFS, define the function ExternalMap as
           
ExternalMapExternalMap["EMIT",n,cod_]:=body;
           
The        second argument n is the position of MAP counting from the beginning, which can be obtained
           using LINE["POSITION","name.m"]. The last argument cod_ is used to receive the orbit at
           the entrance of the element, as a list of 6 real numbers. ExternalMap must return a list,
           either {cod1, trans} or  {cod1, trans, dtrans, dbeam}, where cod1 is the orbit at the
           exit, trans is the 6 by 6 transfer matrix of this element, dtrans is the radiation damping
           part of the transfer matrix (6 by 6), and dbeam is the radiation excitation of the beam
           matrix (6 by 6). Only j >= i parts of dbeam[[i, j]] are taken into account.
           
Example:   Example:
           
ExternalMapExternalMap["EMIT",LINE["POSITION","P1"],cod_]:=(
Print[cod];Print[cod];
{cod+{0,0.0{cod+{0,0.001,0,0,0,0},IdentityMatrix[6]});
           
3)         Optics
In         FFS, define the function ExternalMap as
           
ExternalMapExternalMap["OPTICS",n,cod_]:=body;
           
The        second argument n is the position of MAP counting from the beginning, which can be obtained
           using LINE["POSITION","name.m"]. The last argument cod_ is used to receive the orbit at
           the entrance of the element, as a list of 6 real numbers. ExternalMap must return a list
           {cod1, trans}, where cod1 is the orbit at the exit and trans is the 6 by 6 transfer matrix
           of this element. In the case of CACL4D (== ~CALC6D), only the 4 by 5 transfer matrix is
           effective.
           
Example:   Example:
           
ExternalMapExternalMap["OPTICS",LINE["POSITION","P1"],cod_]:=(
Print[cod];Print[cod];
{cod+{0,0.0{cod+{0,0.001,0,0,0,0},IdentityMatrix[6]});
           
4)         Geometry
In         FFS, define the function ExternalMap as
           
ExternalMapExternalMap["GEO",n,geo_,pos_]:=body;
           
The        second argument n is the position of MAP counting from the beginning, which can be obtained
           using LINE["POSITION","name.m"]. The argument geo_ receives the geometry of the beam line
           at the MAP element, in the same format as LINE["GEO",n], i.e., {{GX,GY,GZ},{CHI1,CHI2,CHI3}}.
           The last argument pos_ receives the orbit length S at the element. ExternalMap must return
           an updated list {geo1, pos1}, as { {{GX,GY,GZ},{CHI1,CHI2,CHI3}}, S} as the values at
           the exit of the element.
Example:   Example:
           
ExternalMapExternalMap["GEO",LINE["POSITION","P1"],geo_,pos_]:=(
Print[cod];Print[cod];
{          {geo[[1]]+{1,0,0}, geo[[2]]}, pos+0.1})</pre>
<pre>See also:
 MAP <a href=#LCALC4D>CALC4D</a></pre>
<li><h3><a name=LFFS>FFS</a></h3>
<pre>FFS[command-string] executes command-string as FFS commands. Any commands can be used. Some commands
CALCULATE(CAL), GO, VARIABLES(VAR), SHOW returns their result, otherwise Null is returned. All outputs
of the commands are suppressed.
   FFS[command-string,lo] directs the output of the commands to file-number lo. The file-number lo
may be given by OpenWrite or OpenAppend.
   The IF structure and REPEAT(REP) loop must complete within a single FFS.</pre>
<pre>See also:
 <a href=#LInput/Output>Input/Output</a> <a href=#LOpenWrite>OpenWrite</a> <a href=#LOpenAppend>OpenAppend</a></pre>
<li><h3><a name=LFFS$SHOW>FFS$SHOW</a></h3>
<pre>   FFS["SHOW"] or FFS$SHOW[] returns the current matching conditions as a list. Each element has
a form of

{component1, component2, function, goal-value, number-of-momentums, scale},

which corresponds to the format of the print-out by SHOW.</pre>
<pre>See also:
 <a href=#LSHOW>SHOW</a></pre>
<li><h3><a name=LFitValue>FitValue</a></h3>
<pre>Usage:

(1) FitValue[component, function, {id_,dp_}, goal_, now_] := body

modifies the goal of the matching of function at component. The argument id_ is the orbit id for
MatchingAmplitude or InitialOrbits. The argument dp_ receives the value of dp/p0. The argument goal_
is the value of the goal of the matching set by matching-function-commands. The argument now_ is
the current value of function.

Example: FitValue["$$$", "NX", {_,dp_}, goal_, now_] := goal + dp * xix * 2 * Pi

sets the tune NX to have chromaticity xix.

(2) FitValue[component1, component2, function, {id_,dp_}, goal_, now1_, now2_] := body

modifies the value of the function at component1 for a two-component matching. Component1 is assumed
upstream in the beam line. The value of body is used in place of the current value, now1. The argument
id_ is the orbit id for MatchingAmplitude or InitialOrbits. The argument dp_ receives the value of
dp/p0. The argument goal_ is the value of the goal of the matching set by matching-function-commands.
The argument now1 and now2 are the current values of the function at component1 and component2, respectively.

Example:
FitValue["QF1", "QF2", "NX", _, goal_, now1_, now2_] := 
   If[Abs[now2-(now1+goal)] < 0.01*2*Pi , Null, now1]

sets the tune difference between QF1 and QF2 gaol +- 0.01.

   During the matching process the matching routine calls FitValue with arguments, then if body returns
a number, it overrides the goal give by matching-function-commands. If body returns Null, the matching
of function is ignored.
   The matching-function-command is necessary besides FitValue to perform the matching. Only defining
FitValue does not do the matching.
   FitValue is cleared by USE. It is hidden by VISIT and restored by BYE</pre>
<pre>See also:
 <a href=#Lmatching-function-commands>matching-function-commands</a> <a href=#Loff-momentum-matching>off-momentum-matching</a></pre>
<li><h3><a name=LFitWeight>FitWeight</a></h3>
<pre> A defined function to modify the weight of matching of particular function at particular component
with particular momentum offset.

Usage:   FitWeight[component, function, {id_,dp_}, default_] := weight;

where

           
component  is the name of the location of the fit, like "QF.2", etc.
function   is the name of the matching-function, like "BX", "LENG", etc.
id_        is the id number of the orbit for MatchingAmplitude or InitialOrbits.
dp_        is a variable to receive the momentum deviation of the fit.
default_   is a variable to receive the default fit weight.
weight     is an expression which returns the desired weight.

Example: FitWeight["$$$","LENG",{_,dp_},ws_]:=ws*10;

makes the weight of LENG at $$$ 10 times (100 times in MatchingResidual) bigger than the default.</pre>
<pre>See also:
 <a href=#Lmatching-function-commands>matching-function-commands</a> <a href=#Lspecial-variables>special-variables</a> <a href=#LMatchingResidual>MatchingResidual</a>
</pre>
<li><h3><a name=LGaussianCoulomb>GaussianCoulomb</a></h3>
<pre><img  class="eqs" src="SADHelp_img/equ_200.svg" /></pre>
<li><h3><a name=LGeoBase>GeoBase</a></h3>
<pre>GeoBase[{chi1, chi2, chi3}] converts the rotation angles of the coordinate base vectors to a transformation
matrix {{x_gx,x_gy,x_gz}, {y_gx,y_gy,y_gz}, {z_gx,z_gy,z_gz}}</pre>
<pre>See also:
 <a href=#LGEO>GEO</a> <a href=#LOrbitGeo>OrbitGeo</a></pre>
<li><h3><a name=LLINE>LINE</a></h3>
<pre>LINE[key-string, {component-pattern-string | component-position}]

returns values for key-string of components which match component-pattern-string or located at component-position.
It returns a list if more than one components match. The key-string and component-pattern-string
can be symbols, unless values are not assigned to them. The second arg can be a fractional number
to denote an intermediate value of two components.
   If the second argument is omitted, it means all components.
   The component-position can be known by LINE["POSITION"].
   Key-strings "DIR" and component-keywords allows to be set (i.e.,
LINE[a,b] = v) when component-pattern-string chooses only one component.
   The arguments of LINE can be lists. It automatically maps as

   LINE[{a,b,c..},y]  means {LINE[a,y],LINE[b,y],LINE[c,y]..}
   LINE[x,{a,b,c..}]  means {LINE[x,a],LINE[x,b],LINE[x,c]..},

where both x and y can be also a list.</pre>
<pre>See also:
 <a href=#Lcomponents>components</a> <a href=#Lwildcards>wildcards</a> <a href=#Lelements>elements</a> <a href=#LElement>Element</a></pre>
<ul>
<li><h3><a name=Lkey-strings:LINE>key-strings:LINE</a></h3>
<pre>The key-string is not case-sensitive. Available key-strings are:

             
"LENGTH"     Number of components in the beam line. No second argument.
"POSITION"   Position of the component in the beam line.
"NAME"       Name of the component.
"TYPE"       The internal code-number of the type of the component.
"TYPENAME"   The name of the type of the component.
"ELEMENT"    The name of the corresponding element.
"DIR"        The orientation of the component, +-1.
"S"          The orbit length to the entrance from the beginning of the beam line.
"LENG"       Same as "S".
"GEO"        Geometric-functions at the entrance of the component, {{GX, GY, GZ}, {GCHI1, GCHI2,
             GCHI3}}.
"OGEO"       Geometric-functions of the orbit at the entrance of the component, {{OGX, OGY, OGZ},
             {OCHI1, OCHI2, OCHI3}}.
"GAMMA"      Lorentz factor gamma.
"GAMMABETA"  Lorentz factor gamma*beta = Sqrt[gamma^2 - 1].
"SIGab"      Beam matrix component, where a and b are one of X, PX, Y, PY, Z, DP. If b is omitted
             it returns Sqrt[SIGaa] is returned. Just "SIG" returns the entire 6 by 6 beam matrix.
"SIZEab"     Beam matrix component calculated by (CODPLOT;EMIT), where a and b are one of X, PX,
             Y, PY, Z, DP. If b is omitted it returns Sqrt[SIZEaa] is returned.- "SIZE" returns the
             entire 6 by 6 beam matrix.
"MULT"       The ordered number of each component belonging to the- same element, starting from 1.
keyword      The value of the keyword of the component (see below).
"EXPAND"     Distribute the value of the default-keywords and the keywords used in the matching to
             all components in the beam line. No second argument.
"GX", "GY", "GZ"  Geometric functions for the coordinate GX, GY, GZ.
"GCHI1", "GCHI2", "GCHI3"  Geometric functions for the coordinate CHI1, CHI2, CHI3
"OGX", "OGY", "OGZ", "OCHI1", "OCHI2", "OCHI3"  Geometrical functions for the orbit.
 Setting by LINE[keyword,..] to the DEFAULT keyword for the FIRST component changes the current value
of the corresponding element, because the value of an element is stored in the first component.</pre>
<pre>See also:
 <a href=#Lcomponents>components</a> <a href=#Lgeometric-functions>geometric-functions</a> <a href=#Lelements>elements</a> <a href=#Lkeywords>keywords</a> <a href=#Ldefault-keyword>default-keyword</a>
 <a href=#LElement>Element</a></pre>
</ul>
<li><h3><a name=LOptimizeOptics>OptimizeOptics</a></h3>
<pre>Usage: OptimizeOptics[options]

optimizes (1 + MatchingResidual) or any function using DownhillSimplex with variables specified by
FREE. Unlike GO, any keyword of any element can be a variable.
   OptimizeOptics returns the final simplex. The variables are set to the values which give the minimum
of the function so far at the end.

Options:
   All options for DownhillSimplex are valid.
   OptimizeFunction -> fun is the function to be minimized. The default is
      ((FFS["CALC"];1+MatchingResidual)&).
   InitialSimplex -> initial sets the initial simplex to initial. The
      default is Null, which mean to create initial from the current value
      of the variables. Its format is same as for initial of 
      DownhillSimplex
   SimplexSize -> size is the initial size of the simplex. Each variable
      is relatively shifted by this amount from the current value.

Example:
   free Q* Q* L
   fit nx .3 ny .2
   OptimizeOptics[]

optimizes the optics by changing the lengths of quads which are not allowed by GO, as well as K1
of quads.</pre>
<pre>See also:
 <a href=#LDownhillSimplex>DownhillSimplex</a></pre>
<li><h3><a name=LOrbitGeo>OrbitGeo</a></h3>
<pre>OrbitGeo[location] returns the geometry {GX, GY, GZ} of the current (not design) orbit.</pre>
<pre>See also:
 <a href=#LGEO>GEO</a> <a href=#LGeoBase>GeoBase</a></pre>
<li><h3><a name=LRadiationField>RadiationField</a></h3>
<pre>To calculate the field of the synchrotron radiation from particles, first record trajectories of
particles. This is done by the function TrackParticles with a new flag RADLIGHT on. When RADLIGHT
is on, TrackParticles returns a list

   {beam, trajectory} ,

where beam is a list as {location, coordinates}, and trajectory is a list

   { {t1 .. tm}, {x1 ..xm}, {y1 .. ym}, {z1 .. zm} }, ..

where {t,x,y,z}_i is the coordinates of the particle at i-th point in the trajectory. The origin
and the direction of the spatial coordinates are the same as GEO coordinate {GX, GY, GZ}. One can
track many particles at the same time by TrackParticles, so the trajectory has the dimensions {np,
m}, where np is the number of particles.

   After the trajectory is obtained, one can calculate the field in time domain
at any observation point. This is done by the function RadiationFiled as

   field = RadiationField[ trajectory[[i]], obs];

where trajectory[[i]] is the trajectory of the i-th particle, and obs is the spatial coordinate of
the observation point in the GEO coordinate. The output field is a list

   { {tau1 .. taum},
     {Ex1 .. Exm}, {Ey1 .. Eym}, {Ez1 .. Ezm},
     {Hx1 .. Hxm}, {Hy1 .. Hym}, {Hz1 .. Hzm},
     {Sx1 .. Sxm}, {Sy1 .. Sym}, {Sz1 .. Hzm} }

where H = (n x E)/(c mu0) and S = E x H , and tau is the observation time.
   RadiationField uses the Feynmann-Heviside formula

   E = (mu0 e*CHARGE/4pi) (c^2n/R^2 + R/c d(c^2n/R^2)/dt + d^2n/dt^2) ,
 where n and R are the direction vector and the distance from the electron at the retarded time to
an observation point. 
   The derivatives in the above formula is calculated using the spline
interpolation.

   Next one can calculate the spectrum of the field by RadiationSpectrum as

   spect = RadiationSpectrum[ {field[[1]], field[[k]]},
        {lambda1, lambda2, dlambda} ] ,

where filed[[k]] is one of the fields calculated by RadiationField. The range of the wavelength is
given as a list above. The output spectrum spect is a list as

   { {k1 .. kk}, {c1 .. ck}, {s1 .. sk} } ,

where k1 .. kk is the wave number k = omega/c, c1 .. ck and s1 .. sk are the cosine and sine integrals
of the field in tau1 .. taum , i.e.,

   ck + I sk = Integrate[ field[tau] Exp[I c k tau] dtau] .

   An example is seen in $(SAD_ROOTPATH)/sad/examples.sad .</pre>
<pre>See also:
 <a href=#LTrackParticles>TrackParticles</a> <a href=#LRADLIGHT>RADLIGHT</a></pre>
<li><h3><a name=LRadiationSpectrum>RadiationSpectrum</a></h3>
<pre>To calculate the field of the synchrotron radiation from particles, first record trajectories of
particles. This is done by the function TrackParticles with a new flag RADLIGHT on. When RADLIGHT
is on, TrackParticles returns a list

   {beam, trajectory} ,

where beam is a list as {location, coordinates}, and trajectory is a list

   { {t1 .. tm}, {x1 ..xm}, {y1 .. ym}, {z1 .. zm} }, ..

where {t,x,y,z}_i is the coordinates of the particle at i-th point in the trajectory. The origin
and the direction of the spatial coordinates are the same as GEO coordinate {GX, GY, GZ}. One can
track many particles at the same time by TrackParticles, so the trajectory has the dimensions {np,
m}, where np is the number of particles.

   After the trajectory is obtained, one can calculate the field in time domain
at any observation point. This is done by the function RadiationFiled as

   field = RadiationField[ trajectory[[i]], obs];

where trajectory[[i]] is the trajectory of the i-th particle, and obs is the spatial coordinate of
the observation point in the GEO coordinate. The output field is a list

   { {tau1 .. taum},
     {Ex1 .. Exm}, {Ey1 .. Eym}, {Ez1 .. Ezm},
     {Hx1 .. Hxm}, {Hy1 .. Hym}, {Hz1 .. Hzm},
     {Sx1 .. Sxm}, {Sy1 .. Sym}, {Sz1 .. Hzm} }

where H = (n x E)/(c mu0) and S = E x H , and tau is the observation time.
   RadiationField uses the Feynmann-Heviside formula

   E = (mu0 e*CHARGE/4pi) (c^2n/R^2 + R/c d(c^2n/R^2)/dt + d^2n/dt^2) ,
 where n and R are the direction vector and the distance from the electron at the retarded time to
an observation point. 
   The derivatives in the above formula is calculated using the spline
interpolation.

   Next one can calculate the spectrum of the field by RadiationSpectrum as

   spect = RadiationSpectrum[ {field[[1]], field[[k]]},
        {lambda1, lambda2, dlambda} ] ,

where filed[[k]] is one of the fields calculated by RadiationField. The range of the wavelength is
given as a list above. The output spectrum spect is a list as

   { {k1 .. kk}, {c1 .. ck}, {s1 .. sk} } ,

where k1 .. kk is the wave number k = omega/c, c1 .. ck and s1 .. sk are the cosine and sine integrals
of the field in tau1 .. taum , i.e.,

   ck + I sk = Integrate[ field[tau] Exp[I c k tau] dtau] .

   An example is seen in $(SAD_ROOTPATH)/sad/examples.sad .</pre>
<pre>See also:
 <a href=#LTrackParticles>TrackParticles</a> <a href=#LRADLIGHT>RADLIGHT</a></pre>
<li><h3><a name=LSetElement>SetElement</a></h3>
<pre>Create/set/read a MAIN-level element.

Usage: SetElement[ element-name, element-type, options]

where

   element-name: name of the element, either a symbol or a string
   element-type: type of the element, a symbol, a string, or a number
   options: one or more rules or list of rules of the form
            keyword -> value or keyword :> value, to set the corresponding
            value of keyword of the element.

   SetElement returns a list of information of the element, in the suitable form for applying SetElement
again.
   You can define a new element by SetElement.
   You can change the values of keywords of the element.
   You cannot, however, change the type of an existing element, nor cannot delete the element.
   The element-type can be Null. If so, a null type is assumed for a new element.

Examples:

   LINE A = ( .. );
   QUAD QF = (K1 = 0.2);
   ...
   FFS USE = A;
     ...
    SetElement["QF"]                     ! reads values of QF.
    SetElement["QF","QUAD"]              ! same as above.
    SetElement["QF","BEND"]              ! error because QF is QUAD.
    SetElement["QF",,{"K1"->0.1}]        ! set K1 of QF to 0.1 .
    SetElement["QF","QUAD",{"K1"->0.1}]  ! same as above.

 !Assuming QF1 and QF2 are undefined yet:

    SetElement["QF1","QUAD",{"K1"->0.1}] ! create a new QUAD QF1 with K1=0.1 .
    SetElement["QF2",,{"K1"->0.1}]       ! error because no type with key.
    SetElement["QF2"]                    ! This is OK.
    SetElement["QF2","QUAD"]             ! Now the type of QF2 is defined.</pre>
<pre>See also:
 <a href=#Lelements>elements</a> <a href=#Lkeywords>keywords</a> <a href=#LElement>Element</a></pre>
<li><h3><a name=LSurvivedParticles>SurvivedParticles</a></h3>
<pre>SurvivedParticles[x]

returns the list of 6 coordinates and the flag of the survived particles in x. The form of x is {x,
px/p0, y, py/p0, z, dp/p0, flag}, where each is a list of length of the number of particles. If all
particles are lost, it is a list of seven null lists.</pre>
<pre>See also:
 <a href=#LTrackParticles>TrackParticles</a></pre>
<li><h3><a name=LSymplecticJ>SymplecticJ</a></h3>
<pre>SymplecticJ[n] returns an n by n symplectic matrix:

<img  class="eqs" src="SADHelp_img/equ_212.svg" /></pre>
<li><h3><a name=LSynchroBetaEmittance>SynchroBetaEmittance</a></h3>
<pre>SynchroBetaEmittance calculates equilibrium emittance under influence of synchrotron motion and chromaticity.

Usage:


  SynchroBetaEmittance[{nus0, nus1, dnus},options]

or

   SynchroBetaEmittance[nus0,options]

where nus0, nus1, and dnus are the starting, ending and step size of synchrotron tune, respectively.
If only nus0 is given, calculation is done only for nus0. The returned value is a list:

   {{nus, emitx, emity, emitxp, emityp, conv}, ... }

where nus, emitx, emity, emitxp, emityp, conv are the synchrotron tune, equilibrium horizontal and
vertical emittances, horizontal and vertical projected emittances, and the convergence, respectively.
When conv is negative, calculation failed to converge, and the returned emittances are not reliable.

Options
              Type        Default     Meaning

-----------------------------------------------------------
AzimuthalModes        Real        9           Number of azimuthal modes</pre>
<pre>See also:
 SYNCHTOBETA(SYNCHROB) <a href=#Lequilibrium-beam-envelope>equilibrium-beam-envelope</a></pre>
<li><h3><a name=LTouschekLifetime>TouschekLifetime</a></h3>
<pre>TouschekLifetime interpolates the data calculated by EMIT or Emittance[]. There are three ways of
usage:

   TouschekLifetime[Infinity, Infinity, nz]: Touschek lifetime in seconds
     with momentum aperture nz * SIGE.

   TouschekLifetime[nx, Infinity, nz]: Touschek lifetime in seconds
     with acceptance 2Jx/(nx * (EMITX+EMITY)) + 2Jz/(nz * EMITZ) < 1.

   TouschekLifetime[Infinity, ny, nz]: Touschek lifetime in seconds
     with acceptance 2Jy/(ny * (EMITX+EMITY)) + 2Jz/(nz * EMITZ) < 1.

EMIT or Emittance[] with INTRA must precede TouschekLifetime.</pre>
<pre>See also:
 <a href=#LEMITTANCE(EMIT)>EMITTANCE(EMIT)</a> <a href=#LEmittance>Emittance</a> <a href=#LINTRA>INTRA</a> <a href=#LMINCOUP>MINCOUP</a> <a href=#Lequilibrium-beam-envelope>equilibrium-beam-envelope</a>
</pre>
<li><h3><a name=LTrackParticles>TrackParticles</a></h3>
<pre>TrackParticles[beam, destination-component, nbegin, nend]

returns a beam after the tracking at the entrance of the destination- component. The destination
can be specified by the name of the component or by a number obtained by LINE["POSITION", component].
If destination is omitted, the end of the line is assumed.

The argument nbegin is the initial turn number to be passed to tracking to indicate it is in the
n-th turn. The number is increased by 1 when it passes the end of beam line. If nbegin is omitted,
1 is assumed.

The argument nend is the last turn number. The default is nbegin.

   The variable beam and also the result of TrackParticles are lists of the form 

   {location, coordinates}

where location is the position-number of the starting point. If location is same as or in the downstream
of destination, the tracking is done by folding across the beginning of the beam line. The coordinates
are in a list of {7, np} form, where np is the number of particles. The first 6 elements of coordinates
specifies

   {x, px/p0, y, py/p0, z, dp/p0}

in this order. The {7, i} is the flag which is True(==1) when the particle is alive, and False(==0)
when lost.

   If the flag POL is on, TrackParticles performs spin tracking. Then the coordinates has two more
components sy and phis, which correspond to the y-component of the classical spin vector and the
angle ArcTan[sx, sz], respectively. If POL is on, another flag RADPOL turns on the Sokolov-Ternov
effect.

   When a flag RADLIGHT is on, TrackParticles returns the trajectories of particles which are used
to calculate the radiation fields. See RadiationField and RadiationSpectrum.

When PHOTONS is ON (default is OFF), TrackParticles generates a list of all photons radiated through
the tracking. The list is assigned to a symbol PhotonList.


When LOSSMAP is ON (default is OFF), TrackParticles returns the component and the turn where the
loss of each particle is detected.</pre>
<pre>See also:
 <a href=#Lcomponents>components</a> <a href=#LLINE>LINE</a> <a href=#LPHOTONS>PHOTONS</a> <a href=#LPhotonList>PhotonList</a> <a href=#LRADLIGHT>RADLIGHT</a> <a href=#LTouschekLifetime>TouschekLifetime</a>
 <a href=#LWakeFunction>WakeFunction</a> <a href=#LSurvivedParticles>SurvivedParticles</a> <a href=#LLOSSMAP>LOSSMAP</a> <a href=#LPOL>POL</a> <a href=#LRADPOL>RADPOL</a></pre>
<li><h3><a name=LTwiss>Twiss</a></h3>
<pre> Twiss[optical-function, component] returns the value of the optical-function at the entrance of
component. The values are those calculated by the last CALCULATE(CALC) or GO commands, or CalculateOptics
function.
 The second argument, component can be a name of component, a component number, or a list of them.
If the number has a fraction, the intermediate value in the component is calculated.
 Twiss["ALL",component] or Twiss["*",component] returns all 28 optical-functions at the entrance
of component as a list:

{AX, BX, GMX, NX, AY, BY, GMY, NY, EX, EPX, EY, EPY, R1, R2, R3, R4, DETR, DX, DPX, DY, DPY, DZ,
DDP, AZ, BZ, GMZ, NZ, ZX, ZPX, ZY, ZPY},

which can be directly used in CalculateOptics. In the current version, however, parameters after
AZ are uninteresting, because it always returns 1 for BZ and zeros for the others. "R"//optical-function
refers the reference optics. "D"//optical-function refers the difference between the current and
the referece optics. "RALL" and "DAL" mean the all optical functions for the reference optics and
the differences, respectively.
   Keywords "PEX", "PEPX", "PEY", "PEPY", "PZX", "PZPX", "PZY", "PZPY" return dispersions in the
physical coordinate.
   Keywords "LENGTH", "GAMMA", "GAMMABETA", "S", "SIGab" return the same results as for the function
LINE.
   The units of NX, NY, NZ are in radian.</pre>
<pre>See also:
 <a href=#LDRAW>DRAW</a> <a href=#Loptical-functions>optical-functions</a> <a href=#Lextended-Twiss-parameters>extended-Twiss-parameters</a> CalculateOptics <a href=#LLINE>LINE</a>
 <a href=#Lreference-optics>reference-optics</a></pre>
<li><h3><a name=LVariableRange>VariableRange</a></h3>
<pre>Usage:   VariableRange[element, keyword ,v_] := expression

where the current value of the element:keyword is passed in v_, and expression should give False
when the value is out of range.

Example: VariableRange["QF","ROTATE",v_]:= -0.1 < v < 0.1;

This restricts the range of the rotation angle of QF within +-100 mrad.

         VariableRange[_,"ROTATE",v_]:= -0.1 < v < 0.1;

This specifies the same for all elements.
   The expression can also return the range as a list {vmin, vmax}, which may give more chance of
solution-finding for the matching routine.
   VariableRange only acts for variables used in the matching with the FREE command.</pre>
<pre>See also:
 <a href=#LFREE>FREE</a> <a href=#Lset-value-of-element>set-value-of-element</a></pre>
<li><h3><a name=LVariableWeight>VariableWeight</a></h3>
<pre>Usage:   VariableWeight[element, keyword ,v_] := expression

where the default weight for matching with element:keyword is passed in v_, and expression should
return a modified value of weight. If non-real is returned, the default weight is used.

Example: VariableWeight["QF","K1",v_]:= 0.1*v;

reduces the weight of QF1:K1 to 1/10 of the default value.

   The weight also affects the step size of the numerical derivative of the response. A smaller weight
makes the step size larger.

   VariableWeight only acts for variables used in the matching with the FREE command.</pre>
<pre>See also:
 <a href=#LFREE>FREE</a> <a href=#Lset-value-of-element>set-value-of-element</a></pre>
<li><h3><a name=LWakeFunction>WakeFunction</a></h3>
<pre>   WakeFunction[Longitudinal, comp]={{z1, wl1}, ..., {zn, wln}};
   WakeFunction[Transverse,   comp]={{z1, wt1}, ..., {zn, wtn}};

specify longitudinal and transverse dipole wake functions at a component comp (string). Each functions
is a list of {z, w} where z is the distance (z>=0) and w is the value of the wake, in the unit of
either V/C or V/C/m.
   The wake functions are applied at the component comp, giving kicks to each orbit whose initial
conditions are given by InitialOrbits. The sufficient number of orbits depends on the situation.
   WakeFunction is valid only when TRPT and INS, and also either TWAKE or LWAKE is ON.
   For tracking, it is only valid in TrackParticles.</pre>
<pre>See also:
 <a href=#LTrackParticles>TrackParticles</a> <a href=#LTRPT>TRPT</a> <a href=#LINS>INS</a> <a href=#LTWAKE>TWAKE</a> <a href=#LLWAKE>LWAKE</a></pre>
</ul>
<li><h3><a name=LGraphics>Graphics</a></h3>
<pre>Graphics represents an object for 2D graphics with the form
Graphics[primitives, options]. Up to now available primitives are:

Circle[{cx,cy},rx, options]             : Circle. 
Circle[{cx,cy},{rx,ry}, options]        : Oval. 
Points[{{x1,y1} .. {x2,y2}}, options]   : Points.
Points[{{x1,y1,dx,dy} .. {x2,y2,dx,dy}}, options]  : Points with error bars.
Line[{{x1,y1} .. {x2,y2}}, options]     : Line.
Line[{{x1,y1,dx,dy} .. {x2,y2,dx,dy}}, options]    : Line with error bars.
Rectangle[{x1,y1}, {x2,y2}]             : A box.
Rectangle[{x1,y1}, {x2,y2}, graphic]    : Graphics in a box.
Polygon[{{x1,y1} .. {x2,y2}}, options]  : Polygon.
Text[{string, {x,y}}, options]          : Text-string at {x,y}.

Possible options and their defaults values of Graphics are:

option           default         optional values
------------------------------------------------
AspectRatio      GoldenRatio     any positive number
DisplayFunction  $DisplayFunction  Identity or Null to suppress display
Detach           False           True to run tdr asynchronously
Epilog           {}              List of primitives
Frame            True            False to erase outline, ticks, ticklabels.
FrameClick       True            to allow click on frame to change options.
FrameLabel       {"","","",""}   List of strings
FrameTicks       {Both,Both,Ticks,Ticks}
                                 None to turn off ticks and labels
                                 Both to turn on ticks and labels
                                 Ticks to turn on ticks only
                                 << For bottom tick >>
                                 False is same as Ticks
                                 True is same as Both
                                 << For top tick >>
                                 False is same as None
                                 True is same as Ticks
                                 << For left & right ticks >>
                                 False is same as None
                                 True is same as Both
                                 If a form {___, _List} is given where
                                 the List is a list of {coord, label, opt___}
                                 label is displayed at coord with option opt.
                                 If a form {___, fun} is given and 
                                 fun[coord,exp,org] returns a list of options
                                 for Canvas[Create$Text], it is displayed at major
                                 ticks at coord. exp is the exponent and org is the
                                 original label.
GridLines        Automatic       Automatic to draw grid lines at major ticks
                                 {Automatic,None} for only x
                                 {None,Automatic} for only y
                                 Both, Minor, and Major can be also used.
PlotLabel        ""              string
PlotRange        Automatic       {ymin,ymax} or {{xmin,xmax},{ymin,ymax}}
Prolog           {}              List of promitives
Scale            {Linear,Linear} Log, Date
TickSize         1               relative size of ticks.
FrameThickness   Automatic       thickness of the frame line incl. ticks.
Legend           ""              shows legend-string.
FontScale        1               Relative size of fonts for FrameLabel, FrameTicks.
FrameFontScale   1               Relative size of fonts for FrameLabel.
                                 If Real, applied to all frames. If List, applied to
                                 bottom, left, top, right, supplemented 1s to the right.
TickFontScale    1               Relative size of fonts for FrameTicks.
                                 If Real, applied to all frames. If List, applied to
                                 bottom, left, top, right, supplemented 1s to the right.
LegendFontScale  1               Relative size of fonts for Legend.

Options for primitives:

For Text:
option           default         optional values
------------------------------------------------
TextAlign        ""              "CENTER"
TextCases        ""              string to represent CASES of TopDrawer
TextPosition     ""              "DATA" to represent the position by data
                                 coordinates
TextRotate       0
TextSize         1               relative size of a character
PlotColor        "Black"         one of "White", "Black", "Red",
                                 "Green","Blue","Yellow",
                                 "Magenta","Cyan"

For Point
option           default         optional values
------------------------------------------------
PointSize        1               relative size of a point
PointSymbol      "1O"            Symbol for PLOT of TopDrawer, or Bar
                                 "6O","7O","8O","9O" are triangles
                                 in CanvasDrawer.
PlotColor        "Black"         one of "White", "Black", "Red",
                                 "Green","Blue","Yellow",
                                 "Magenta","Cyan"
ErrorBarTickSize 1               length of error bar ticks.

For Line
option           default         optional values
------------------------------------------------
Dashing          "1"             character string or a list of numbers to
                                 represent the dashing of the line.
Plot             True            whether plot symbols at data points.
                                 If True, PointSize and PointSymbol are
                                 effective (see above).
PlotColor        "Black"         one of "White", "Black", "Red",
                                 "Green","Blue","Yellow",
                                 "Magenta","Cyan"
ErrorBarTickSize 1               length of error bar ticks.
Thickness        1               thickness of line

For Polygon
option           default         optional values
------------------------------------------------
Plot             False           whether plot symbols at data points.
                                 If True, PointSize and PointSymbol are
                                 effective (see above).
PointSize        1               relative size of a point
PointSymbol      "1O"            Symbol for PLOT of TopDrawer, or Bar
                                 "6O","7O","8O","9O" are triangles
                                 in CanvasDrawer.
PointColor       "forest green"  point fill color.
PointBorderColor Automatic       point border color.
                                 Automatic measn PointColor.
PointTags        Null            points tag string or list of tag strings.
PlotJoined       True            whether plot border line of polygon.
Thickness        1               thickness of border line

Dashing          "1"             character string or a list of numbers to
                                 represent the dashing of the line.
PlotColor        "black"         border line color.
LineTags         Null            border line tag string.
FillColor        Null            polygon fill color.
                                 Null means empty polygon.
Tags             False           polygon tag string.

   ListPlot accepts options for Graphics, Point, and Line.   Show accepts
options for Graphics.   The output is written to file #9 (fort.9 in OSF1 and
ftn09 in HP-UX) in TopDrawer commands.   If SAD is running on X, the plot is
also done immediately.

Examples:
  g1=ListPlot[{{1,2},{10,20}},Scale->Log,PlotJoined->True,
    DisplayFunction->Identity];
  g2=ListPlot[{{1,15},{10,3}},Scale->Log,PlotJoined->True,Dashing->"1 0.3",
    DisplayFunction->Identity,Plot->False];
  g3=ListPlot[{{1,2.5},{5,10},{10,12}},Scale->Log,
    DisplayFunction->Identity];
  Show[g1,g2,g3,FrameLabel->{"X (mm)","Log(Y)"},PlotLabel->"Test Plot",
      AspectRatio->1];</pre>
<ul>
<li><h3><a name=LBeamPlot>BeamPlot</a></h3>
<pre>Usage: BeamPlot[loc, axes, options]

plots a beam ellipse at a location loc, for axes. Axes are given by a list 
{ax, ay}, where ax and ay are one of "X", "PX", "Y", "PY", "Z", "DP".
The beam envelope should be calculated by (CODPLOT;EMIT) or BEAM commands before
BeamPlot.

options       defaults
-----------------------------------------
Orbit         True                Uses Twiss["DX",loc], etc. as the center of
                                  ellipse.
SizeFunction  "SIZE"              If "SIG", LINE["SIG"] is used.
                                  LINE["SIZE"] is the default.
AspectRatio   1
DataRange     Default             If Default, PlotRange becomes square for
                                  axes = {"X", "Y"} or {"PX", "PY"}</pre>
<pre>See also:
 <a href=#LBEAMSIZE(BEAM)>BEAMSIZE(BEAM)</a> <a href=#LEMITTANCE(EMIT)>EMITTANCE(EMIT)</a> <a href=#LCODPLOT>CODPLOT</a></pre>
<li><h3><a name=LColumnPlot>ColumnPlot</a></h3>
<pre>Usage:  ColumnPlot[data, options, ...]

plots a column plot.
1) If data is a 1D vector, it makes a simple column plot.
2) If data is a 2D matrix, it makes a multiple-column plot.
3) If data is a 3D list, it makes a stacked, multiple-column plot.

Besides options common for all plotting functions, ColumnPlot has its own
options:

Option           Value          Default             Action
---------------------------------------------------------------------------
ColumnOffset    0 < number < 1  0.15            Ratio of spacing of columns
Reference        number         0               Where column starts
Orientation     Vertical        Vertical        Orientation of columns
                Horizontal
ColumnLabel     List of Str.    Automatic       Labels for each column
                Function                        Scale for column number
                None                            No labels
FillColor       color                           Colors to fill columns
                list of colors
MeshStyle       bitmap                          Bitmap to fill columns
                list of bitmaps                 to distinguish stacking
TextSize        positive number 1               relative label size
PlotNull        True or False   False           plot a minimal rect for 0 occurrence

Example:
  g=ColumnPlot[{{{1,1,2},{2,2,3}}, {{1,4,2},{2,2,3}}, {{1,3,2},{2,2,3}}}, Orientation->Horizontal];

 Update[];

<img src="SADHelp_img/ColumnPlot.png" align="middle" width=540>
</pre>
<pre>See also:
 <a href=#LGraphics>Graphics</a></pre>
<li><h3><a name=LFitPlot>FitPlot</a></h3>
<pre>Usage: FitPlot[data, fun, var, {par1,ini1}, .. , {parn, inin}, opt].</pre>
<pre>See also:
 <a href=#LFit>Fit</a></pre>
<li><h3><a name=LGeometryPlot>GeometryPlot</a></h3>
<pre>Usage: GeometryPlot[options]

plots a geometry of beam line.

options       defaults
-----------------------------------------
Region        {1,LINE["LENGTH"]}  {begin, end}, begin and end can be strings.
                                  Both begin and end point of drawing region
                                  could be given by "S" unit by using S[begin|end] form.
Names         "*"                 A pattern of component names to be plotted.</pre>
<pre>See also:
 <a href=#LGraphics>Graphics</a> <a href=#LOpticsPlot>OpticsPlot</a></pre>
<li><h3><a name=LHistoPlot>HistoPlot</a></h3>
<pre>Usage:  HistoPlot[data, options, ...]

plots a histogram using ColumnPlot(default) or ListPlot.
Data can be a single list, or list of lists, which results in a multi-column histogram on a common
axis.
Besides options common for all plotting functions and ColumnPlot, it has its own options:

Option           Value          Default             Action
---------------------------------------------------------------------------
Bins            number          Automatic           number of bins
BinRange        {min,max}       Automatic           Range of bins
PlotStyle       ColumnPlot      ColumnPlot          plot function
                ListPlot
                FitPlot
Orientation     Vertical        Vertical            orientation of columns
                Horizontal
FitParameters   args for FitPlot in a list</pre>
<pre>See also:
 <a href=#LGraphics>Graphics</a> <a href=#LColumnPlot>ColumnPlot</a> <a href=#LListPlot>ListPlot</a> <a href=#LFitPlot>FitPlot</a></pre>
<li><h3><a name=LListContourPlot>ListContourPlot</a></h3>
<pre>Usage:  ListContourPlot[list, options, ...]

plots a contour plot by list which is a 2D List of Real data.

Option           Value            Default         Action
---------------------------------------------------------------------------
Contours         Real             10              number of contours
PlotRange        {min,max}, {prxy, prz}, or {prx, pry, prz}
                                  Automatic       depth of contours (prz) and PlotRange for x-y (prxy)
AspectRatio
     Real             1
MeshRange        ({x1,xn},{y1,yn}} or {{x1,..,xn},{y1,..,y1n}}
                                  Automatic       Range of x and y axes
ColorFunction    Color scheme (Blue, Purple, Pink, Yellow, Green, Cyan),Function, or String
                                  Blue            Null or None means "white"
ContourColorFunction
                 Function or String
                                  Automatic       Null or None to hide
ColorScale       True or False    True            displays a color scale on the right
Smoothing        integer >= 0     1               number of linear interpolations

Example:
 xr0=0;xr=Table[xr0+=Sin[i*Pi/21],{i,20}];xr-=(xr[[1]]+xr[[-1]])/2;
 yr=xr;
 table=Outer[Cos[Sqrt[(#^2+#2^2)/2]]&,xr,yr];

 gc=Graphics[MapThread[
  Rectangle[#2,#3,
    ListContourPlot[table, MeshRange->{xr, yr}, AspectRatio->1,
      DisplayFunction->Identity, ColorFunction->#,
      FrameLabel->{"x", "y", ToString[#]}]]&,
   {{ Blue,        Pink,       Green,      Purple,      Yellow,     Cyan},
     {{-0.15,0.65},{0.25,0.65},{0.65,0.65},{-0.15,0   },{0.25,0   },{0.65,0}},
     {{ 0.2, 1.1 },{0.6, 1.1 },{1,   1.1 },{ 0.2, 0.45},{0.6 ,0.45},{1.0, 0.45}}}]];
 Show[gc];Update[];
<img src="SADHelp_img/ListContourPlot.png" align="middle" width=540>
</pre>
<pre>See also:
 <a href=#LGraphics>Graphics</a> <a href=#LListPlot>ListPlot</a> <a href=#LListDensityPlot>ListDensityPlot</a></pre>
<li><h3><a name=LListDensityPlot>ListDensityPlot</a></h3>
<pre>Usage:  ListDensityPlot[list, options, ...]

plots a density plot by list which is a 2D List of Real data.

Option           Value            Default         Action
---------------------------------------------------------------------------
PlotRange        {min,max}, {prxy, prz}, or {prx, pry, prz}
                                  Automatic       depth of contours (prz) and PlotRange for x-y (prxy)
AspectRatio
     Real             1
MeshRange        ({x1,xn},{y1,yn}} or {{x1,..,xn},{y1,..,y1n}}
                                  Automatic       Range of x and y axes
ColorFunction    Color scheme (Blue, Purple, Pink, Yellow, Green, Cyan),Function, or String
                                  Blue            Null or None means "white"
Mesh             True or False    False           True to draw mesh
MeshColor        Function or String
                                  Automatic       Null or None to hide
ColorScale       True or False    True            displays a color scale on the right
Smoothing        integer >= 0     1               number of linear interpolations

Example:
   data = Table[Sin[x]/Cos[x^2 + y^2], {x, -2, 2, 0.1}, {y, -2, 2, 0.1}];
   ListDensityPlot[data,PlotRange->{-5,5}, MeshRange->{{-2,2},{-2,2}}, FrameLabel->{"x","y"}];
   Update[];

<img src="SADHelp_img/ListDensityPlot.png" align="middle" width=540>
</pre>
<pre>See also:
 <a href=#LGraphics>Graphics</a> <a href=#LListPlot>ListPlot</a> <a href=#LListContourPlot>ListContourPlot</a></pre>
<li><h3><a name=LListPlot>ListPlot</a></h3>
<pre>Usage: ListPlot[{{x1,y1},..,{xn,yn}}, options]

makes a graphic with points.
ListPlot[{y1,..,yn}, options] assumes 1,..n for the x-xoordinate.
ListPlot[{{x,y,dy}, ..}, options ] plots error bars of length dy in y.
ListPlot[{{x,y,dx,dy}, ..}, options ] plots error bars in x and y.

option           default         optional values
------------------------------------------------
PlotJoined       False           True
                                 Step
StepRatio        1               ratio of stepping position
                                 between two data points

Type ? to see other options for Graphics.

Example:
  data1={{1,2},{3,5},{4,-1}};
  data2={{1,4},{2,-2},{3.5,3},{5,3}};
  g1=ListPlot[data1, PointColor->"dark slate blue",PlotJoined->True, Thickness->2, PlotColor->"dark
slate blue", FrameLabel->{"x","y"}, Legend->"data1", DisplayFunction->Identity];
  g2=ListPlot[data2, PointColor->"tomato", Legend->"data2", DisplayFunction->Identity];
  Show[g1,g2];
  Update[];

<img src="SADHelp_img/ListPlot.png" align="middle" width=540>
</pre>
<pre>See also:
 <a href=#LGraphics>Graphics</a> <a href=#LPlot>Plot</a></pre>
<li><h3><a name=LOpticsPlot>OpticsPlot</a></h3>
<pre>Usage: OpticsPlot[fun_list, options]

makes a plot of built-in optical functions, user-defined functions, or
list of data at components on the beam line.   The parameters are:

            
fun_list:   a list of objects to be plotted in a window. The number of windows in a plot is the length
            of fun_list object plotted in a window MUST have same dimensions. An element of fun_list
            is one of fun_label, fun, list_data or a list as {object, options}, where
fun_label:  one of "AX", "BX", "GMX", "NX", "EX", "EPX", "DX", "DPX", "AY", "BY", "GMY", "NY", "EY",
            "EPY", "DY", "DPY", "R1", "R2", "R3", "R4", "DETR", "AZ", "BZ", "GMZ", "NZ", "ZX", "ZPX",
            "ZY", "ZPY", "DZ","DDP","PEX", "PEPX", "PEY", "PEPY", "GAMMA", "GAMMABETA","SIGab", where
            a and b in "SIGab" are one of X, PX, Y, PY, Z, DP. "R"//fun_label refers the reference
            optics. "D"//fun_label refers the difference between the current and reference optics.
fun:        Any function of the component number.   A fractional number may be used to obtain the
            intermediate value.
list_data:  a list of {{pos1, val1}..{posn,valn}}.

options       defaults
-----------------------------------------
Region        {1,LINE["LENGTH"]}  {begin, end}, begin and end can be strings.
                                  Both begin and end point of drawing region
                                  could be given by "S" unit by using S[begin|end] form.
Lattice       True                False to turn of drawing lattice
LatticeRegion Automatic           {low,high}, the region where lattice is drawn
FrameHeight   Automatic           List of relative heights of each frame
InfoLabel     False               If True, pressing Button shows Twiss, etc.
Names         "*"                 A pattern of component names to be plotted.
RemoveOverlap "L$NAME"            If not "L$NAME", overlapping of lattice names
                                  remain untouched.
Tags          False               True to attach tags "C$"//(component name)
                                  to each rectangle for the lattice, and
                                  "L$"//(component name) to the component 
                                  label (CanvasDrawer only).
Legend        False               If Automatic, Legend is composed from FrameLabel
                                  Automatically.

options in a fun_list element:
options       defaults
-----------------------------------------
Unit          1                  Unit of the object. "Meter", "InvMeter",etc.
FrameLabel    ""                 Left frame label.
Legend        False               If Automatic, Legend is composed from FrameLabel
                                  Automatically.

Example:
   p2=OpticsPlot[{{"BX","BY"}, {"DX",{{{10,0.001},{20,0.002}}, FrameLabel->"DX meas.", Unit->Meter,
Thickness->2, Names->"Q*"}}}];
   Update[];

<img src="SADHelp_img/OpticsPlot.png" align="middle" width=540>
</pre>
<pre>See also:
 <a href=#LGraphics>Graphics</a> <a href=#LListPlot>ListPlot</a> <a href=#LTwiss>Twiss</a> <a href=#Lreference-optics>reference-optics</a></pre>
<li><h3><a name=LPlot>Plot</a></h3>
<pre>Usage: Plot[fun, range, options] or Plot[{fun1, .. }, range, options],

where fun is a function and range is a list given as {x, xmin, xmax}.

options        defaults
-----------------------------------------
MaxBend        0.04
PlotPoints     25
PlotDivision   250
Dashing        {"1","0.8 0.24","0.4 0.12","0.2 0.08","0.1 0.08",
                  "0.8 0.08 0.08 0.08","0.4 0.08 0.08 0.08"}
Options for ListPlot and Graphics are also available

The independent variable should have been cleared (i.e., no value should
not be set) when Plot is called. 

Example:
  ff[x_]:=Sin[x]/x;

  ff[0]=1;
  Plot[{Cos[x],ff[x]}, {x,0,10}, Thickness->2];
  Update[];

<img src="SADHelp_img/Plot.png" align="middle" width=540>
</pre>
<pre>See also:
 <a href=#LGraphics>Graphics</a> <a href=#LListPlot>ListPlot</a></pre>
</ul>
<li><h3><a name=LInput/Output>Input/Output</a></h3>
<pre></pre>
<ul>
<li><h3><a name=L$FORM>$FORM</a></h3>
<pre>$FORM is a character-string to specify the format of the output of a real number.

Usage: $FORM="w.f"
       $FORM="Sw.f"
       $FORM="Fw.f"
       $FORM="Mw.f"

where w is the width of the output, and f is the length of the fractions. If S is attached, trailing
zeroes are omitted. If F is attached, it becomes same as FORTRAN's F-format. If M is attached, the
exponent is expressed as 10^n. If w and f are omitted, 17.15 is assumed.
   The default is S17.15 .</pre>
<li><h3><a name=L$Input>$Input</a></h3>
<pre>$Input holds the file number for console input stream. The default is -1.</pre>
<pre>See also:
 <a href=#L$Output>$Output</a></pre>
<li><h3><a name=L$Output>$Output</a></h3>
<pre>$Output holds the file number for console output. The default is -1.</pre>
<pre>See also:
 <a href=#L$Input>$Input</a></pre>
<li><h3><a name=LClose>Close</a></h3>
<pre> Close[f] closes file number [f]. It is necessary to complete the output to an external file.
 Close[f1, ...] and Close[{f1, ...}] close all files f1, ...</pre>
<pre>See also:
 <a href=#LOpenRead>OpenRead</a> <a href=#LOpenWrite>OpenWrite</a> <a href=#LOpenAppend>OpenAppend</a> <a href=#LOpenShared>OpenShared</a> <a href=#LStringToStream>StringToStream</a>
</pre>
<li><h3><a name=LOpenAppend>OpenAppend</a></h3>
<pre>f = OpenAppend[file]

opens file (_String) for write and returns the file number (_Real)</pre>
<pre>See also:
 <a href=#LClose>Close</a> <a href=#LOpenRead>OpenRead</a> <a href=#LOpenWrite>OpenWrite</a></pre>
<li><h3><a name=LOpenRead>OpenRead</a></h3>
<pre>f = OpenRead[file]

opens file (_String) for read and returns the file number (_Real)</pre>
<pre>See also:
 <a href=#LClose>Close</a> <a href=#LOpenWrite>OpenWrite</a> <a href=#LOpenAppend>OpenAppend</a></pre>
<li><h3><a name=LOpenWrite>OpenWrite</a></h3>
<pre>f = OpenWrite[file]

opens file (_String) for write and returns the file number (_Real)</pre>
<pre>See also:
 <a href=#LClose>Close</a> <a href=#LOpenRead>OpenRead</a> <a href=#LOpenAppend>OpenAppend</a></pre>
<li><h3><a name=LPageWidth>PageWidth</a></h3>
<pre>PageWidth is the number of columns of the output. The default is set from GetEnv["WIDTH"].</pre>
<li><h3><a name=LPrint>Print</a></h3>
<pre>
   Print[expr1 [,expr2 ...]]

converts expr1... to _String then write them to $Output. A newline character is appended at the end.</pre>
<pre>See also:
 <a href=#LWrite>Write</a> <a href=#LWriteString>WriteString</a></pre>
<li><h3><a name=LRead>Read</a></h3>
<pre>Read[f, item [, item1...] [, opts..]]

reads item from file number f. If f is $Input, it reads from the current input stream. item can be
one of or a list of:
Word        a word, delimited by WordSeparators
Real        a real expression
Expression  an expression
Character   a single character

 A format n*item is possible with a positive integer n.
 A list {item1,.., itemn} is possible. The result is also a list.

 opts are options given by a Rule:
Option         Value       Default    Effect
WordSeparator  _String     " ,\t"     the delimiters for Word
ReadNewRecord  True/False  True       If true, read the next record of the file beyond the end of
line
NullWords      True/False  False      If True, "" is returned when the input contains adjavent word
separators</pre>
<pre>See also:
 <a href=#LOpenRead>OpenRead</a> <a href=#LClose>Close</a></pre>
<li><h3><a name=LReadString>ReadString</a></h3>
<pre>ReadString[f]

reads the next record from file number f, and returns it as a _String.</pre>
<pre>See also:
 <a href=#LRead>Read</a> <a href=#LOpenRead>OpenRead</a> <a href=#LClose>Close</a></pre>
<li><h3><a name=LStandardForm>StandardForm</a></h3>
<pre>StandardForm[expr]

resets $FORM and PageWidth to their defaults, then evaluate expr, returns the result, and resets
$FORM and PageWidth to those at the beginning of StandardForm.</pre>
<pre>See also:
 <a href=#L$FORM>$FORM</a> <a href=#LPageWidth>PageWidth</a></pre>
<li><h3><a name=LStringToStream>StringToStream</a></h3>
<pre>f = StringToStream[string]

opens a character string for read and returns the file number (_Real)</pre>
<pre>See also:
 <a href=#LClose>Close</a></pre>
<li><h3><a name=LWrite>Write</a></h3>
<pre>   Write[f, expr1 [,expr2 ...]]

converts expr1... to _String then write them to file number f. A newline character is appended at
the end.</pre>
<pre>See also:
 <a href=#LWriteString>WriteString</a> <a href=#LPrint>Print</a> <a href=#LOpenWrite>OpenWrite</a> <a href=#LOpenAppend>OpenAppend</a> <a href=#LClose>Close</a> <a href=#L$FORM>$FORM</a> <a href=#LPageWidth>PageWidth</a>
 <a href=#LStandardForm>StandardForm</a></pre>
<li><h3><a name=LWriteString>WriteString</a></h3>
<pre>WriteString[f, expr1 [,expr2 ...]]

converts expr1... to _String then write them to file number f. No newline character is appended.</pre>
<pre>See also:
 <a href=#LWrite>Write</a> <a href=#LOpenWrite>OpenWrite</a> <a href=#LOpenAppend>OpenAppend</a> <a href=#LClose>Close</a> <a href=#L$FORM>$FORM</a> <a href=#LPageWidth>PageWidth</a> <a href=#LStandardForm>StandardForm</a>
</pre>
</ul>
<li><h3><a name=LMultiprocessing>Multiprocessing</a></h3>
<pre></pre>
<ul>
<li><h3><a name=LFork>Fork</a></h3>
<pre>Forks the process into a parent and a child processes.

   Fork[]

returns 0 and the child's pid for the child and the parent, respectively.</pre>
<li><h3><a name=LOpenShared>OpenShared</a></h3>
<pre>Allocated shared memory of n bytes.


   s = OpenShared[n] ,

where s is a file number to be used by Shared function. The allocated memory can be released by Close[s].</pre>
<li><h3><a name=LShared>Shared</a></h3>
<pre>Read/Write to the shared memory.

   Shared[s]
   Shared[s] = x
   Shared[s] := x

where s is given by OpenShared, and x is Real, built-in function, String, defined symbol, or list
of them.</pre>
<li><h3><a name=LSharedSize>SharedSize</a></h3>
<pre>Returns the size of an object for OpenShared.

   n = SharedSize[x] </pre>
</ul>
<li><h3><a name=LObject-oriented-programing>Object-oriented-programing</a></h3>
<pre>Environment for an object-oriented-programming is supplied by:

Class:          The function to define a class.
context:        A class defines a context to define its all symbols for
                the variables and methods within the context.
                This automatically avoids conflicts of symbols between 
                classes, Global, and System. When c = Class[ ... ] is
                done, a context c` is defined.

members:        The set of Members of a class is a union of class variables,
                instance variables, and class methods of the class.

operator @:     A special operator to access class member. In a notation 
                f@g, g's context defaults the class of the class of f. 
                f@g@h[x] is recognized as ((f@g)@h)[x] , thus the context of
                h defaults the class of f.

superclasses:   A class inherits all class variables, instance variables,
                class methods from its superclasses which are give by the
                first argument of Class. If a null list is given, Object` 
                is set as the default superclass. Multiple inheritance is
                allowed.

class variable: Class variables are given by the second argument of Class
                as a list of symbols. They are unique in the class.
                They can be initialized by declaring in a way such as 
                {a=1, {b, c} = {2, 3}} like Module. A form like
                {a = b = c =1} is allowed.

instance variable: 
                Instance variables are given by the third argument of Class
                as a list of symbols. An instance has those symbols
                separately. They can be initialized by declaring in a way
                such as {a=1, {b, c} = {2, 3}} like as Module. A form like as
                {a = b = c =1} is allowed. Also they
                are initialized at the creation of instance by rules as
                x = c[ a->1, b:>Print[d]], etc.

class methods:  Class methods are given by the fourth(last) argument of
                Class. They must be in the form of either one of

                f_[arg___] := g_;
                With[_, f_[arg___] := g_];
                With[_, f_[arg___] := g_; .. ];
                If[_,
                  ft_[argt___] := gt_; ..,
                  ft_[argf___] := gf_; ..,];
                h_[f_[arg___], b___] ^:= g_; .

                where f is the symbol for the method to be defined.
                Set may be used instead of SetDelayed if necessary.

This:           A symbol This in the definition of the method, it is 
                translated to the object (the instance or the class) which 
                refers the member.

default reference:
                In the definition of the class methods, whenever a member of
                the class is appeared, it is recognized as This@member.
                When a symbol of the member conflicts the symbol in System`,
                the system symbol should be wrapped by Literal.

reference of member of superclasses:
                Members of the superclasses (denote cc) are referred by 
                cc`member in the definition of the method.

copying an instance:
                An instance c of a class can be copied to another symbol
                by c1 = c. After the copying, c1 and c refer the identical
                instance. Destructing one of them by such as c1=. clears
                the instance and also all the assigned symbols.

Constructor:    When an instance is defined, by x = c[arg], a method
                x@Constructor[arg] is always invoked.
                In evaluation of instance definition under class scope,
                class member symbol appeared 1st slot of Rule or RuleDelayed
                argument is sent to Constructor of new class instance
                without evaluation. (In other term, class member symbol on
                1st slot of Rule or RuleDelayed argument behaves like
                evaluating with implicit Literal[]) One can configure
                Constructor[] in the definition of the class.
                x = c[arg] returns the returned value of Constructor[arg].
                The rules in the argument work in two ways: (1) A rule for an
                instance variable or a class variable sets the initial value
                of the variable, (2) Other rules are stored in an instance
                variable Options as a list.

Destructor:     An instance x is cleared by (x=.), which invokes 
                x@Destructor[]. The default Destructor is Object`Destructor,
                but one can reconfigure it in the definition of the class.

Short:          When an instance x is returned as the result of expression
                for Out[], x@Short[] is invoked to show the result. The 
                default Short is Object`Short, but one can reconfigure it
                in the definition of the class.

other methods:  Class[] gives the class of the instance.
                Parents[] gives the immediate superclasses.
                AllParents[] gives the all superclasses.
                Members[] gives a list of class variables, class methods,
                and instance variables of the class.
                AllMembers[] gives a list of class variables, class methods,
                and instance variables of the class and its all parents.</pre>
<pre>See also:
 <a href=#LMember(@)>Member(@)</a></pre>
<ul>
<li><h3><a name=LClass>Class</a></h3>
<pre>Class sets up a class of objects.

Usage:   a = Class[
               list of superclasses,
               list of class-variables,
               list of instance-variables,
               class-methods];

Example: a = Class[
               {aa, bb},      (* aa and bb are superclasses *)
               {a1, a2},      (* class-variables *)
               {v1, v2},      (* instance-variables *)
               Constructor[arg__] := (Print[{arg}]; v1 = Plus[arg]);
               sum[] := v1 + v2 (* defining Constructor and method "sum"*)
             ];

         a1 = a[1, 2]          (* creating an instance of a *)
         a1@v1                 (* accessing an instance variable *)
         a1@v2 = 3             (* setting an instance variable *)
         a1@sum[]              (* calling a method "sum" *)
         a1=.                  (* delete an instance *)</pre>
</ul>
<li><h3><a name=LRandom-number-functions>Random-number-functions</a></h3>
<pre>The random number functions use common seed given by SEED command or SeedRandom function. It has
an initial value 17 at the beginning of FFS. The cut-off value of GaussRandom[] is given by variable
GCUT.</pre>
<pre>See also:
 special-variables: <a href=#LGCUT>GCUT</a></pre>
<ul>
<li><h3><a name=LRandom>Random</a></h3>
<pre>Random[]           gives a uniform random number between 0 and 1.
Random[n]          gives a list of n uniform random numbers.
Random[n1, n2, ..] gives a (n1 * n2 * .. ) tensor of uniform random numbers.</pre>
<pre>See also:
 <a href=#LGaussRandom>GaussRandom</a> <a href=#LParabolaRandom>ParabolaRandom</a> <a href=#LSeedRandom>SeedRandom</a></pre>
<li><h3><a name=LGaussRandom>GaussRandom</a></h3>
<pre>GaussRandom[]           gives a Gaussian random number with average 0, 
                        standard deviation 1, cutoff at GCUT.
GaussRandom[n]          gives a list of n Gaussian random numbers.
GaussRandom[n1, n2, ..] gives a (n1 * n2 * .. ) tensor of Gaussian random
                        numbers.</pre>
<pre>See also:
 <a href=#LRandom>Random</a> <a href=#LParabolaRandom>ParabolaRandom</a> <a href=#LSeedRandom>SeedRandom</a></pre>
<li><h3><a name=LParabolaRandom>ParabolaRandom</a></h3>
<pre>ParabolaRandom[]           gives a parabola random number between -1 and 1. 
ParabolaRandom[n]          gives a list of n parabola random numbers.
ParabolaRandom[n1, n2, ..] gives a (n1 * n2 * .. ) tensor of parabola random
                           numbers.</pre>
<pre>See also:
 <a href=#LRandom>Random</a> <a href=#LGaussRandom>GaussRandom</a> <a href=#LSeedRandom>SeedRandom</a></pre>
<li><h3><a name=LSeedRandom>SeedRandom</a></h3>
<pre>SeedRandom[plugin_String] selects new pseudo random-number generator
                          plugin named as plugin.
SeedRandom[seed_Real]     initializes the internal state of the current
                          pseudo random-number generator plugin by seed.
SeedRandom[{seeds__Real}] initializes the internal state of the current
                          pseudo random-number generator plugin by {seeds}.
SeedRadnom[state_List]    restores both the selection of the pseudo random-number
                          generator plugin and the internal state of the selected
                          plugin by using state dumped by SeedRandom[].
SeedRandom[]              returns List containing both the current selected pseudo
                          random-number generator plugin name and its internal state.</pre>
<pre>See also:
 <a href=#LListRandom>ListRandom</a> <a href=#LRandom>Random</a> <a href=#LGaussRandom>GaussRandom</a> <a href=#LParabolaRandom>ParabolaRandom</a></pre>
<li><h3><a name=LListRandom>ListRandom</a></h3>
<pre>ListRandom[] returns List of available pseudo random-number generator plugins.</pre>
<pre>See also:
 <a href=#LSeedRandom>SeedRandom</a></pre>
</ul>
<li><h3><a name=LSystem-interface>System-interface</a></h3>
<pre></pre>
<ul>
<li><h3><a name=LSystem>System</a></h3>
<pre>System[string] executes string as a shell command. It returns the system return code.</pre>
<li><h3><a name=LTemporaryName>TemporaryName</a></h3>
<pre>TemporaryName[] returns a unique file name for a temporary use.</pre>
</ul>
<li><h3><a name=LUtilities>Utilities</a></h3>
<pre></pre>
<ul>
<li><h3><a name=LDateString>DateString</a></h3>
<pre> DateString[] returns the current date and time as string  "mm/dd/CCYY HH:MM:SS".
 DateString[date] converts date to string as above. The date can be either a real number (in second,
date=0 is 1/1/1900 0:0:0) or a list of 6 reals {Y,m,d,H,M,S}.</pre>
<li><h3><a name=LMemoryCheck>MemoryCheck</a></h3>
<pre>MemoryCheck[n]

checks the consistency of the memory allocation by SAD. The range of the check and the output depend
on n:

                
MemoryCheck[]   : checks the consistency of the free area and returns the allocation info,
MemoryCheck[1]  : checks the consistensy of the free and used areas. Returns the allocation info.
MemoryCheck[2]  : checks the consistensy of the free and used areas. Returns the allocation info.
                and a list of free segments.

 The returned value is {used, allocated from system, # of free segments, missing size[, list of free
segments]} in units of word (= 8 bytes).
 If an inconsistency is found, messages are printed out.</pre>
<li><h3><a name=LTimeUsed>TimeUsed</a></h3>
<pre>TimeUsed[] returns the cputime since the start of SAD in seconds.</pre>
<pre>See also:
 <a href=#LTiming>Timing</a></pre>
<li><h3><a name=LTiming>Timing</a></h3>
<pre>Timing[fun]

evaluates fun and returns {cputime, result}. cputime is in seconds.</pre>
<pre>See also:
 <a href=#LTimeUsed>TimeUsed</a></pre>
<li><h3><a name=LTracePrint>TracePrint</a></h3>
<pre>TracePrint[fun]

prints out all function calls and each expression compound in ";" in the evaluation of fun.</pre>
</ul>
</ul>
<h3><a name=LFIT>FIT</a></h3>
<pre>Usage: (1) FIT [component]
       (2) FIT component1 component2

sets the current location where the matching condition is applied. The component is given with the
form name[.order][{+-}offset] (see components). If component is omitted, the end of the beam line
is chosen.
   If two components are given, it means a relative-fitting or zone-fitting. If the fitting condition
is not maximum-fitting, the condition means to make values at two components equal (for AX, BX, GMX,
AY, BY, GMY, EX, EPX, EY, EPY, R1, R2, R3, R4, DX, DPX, DY, DPY, PEX, PEPX, PEY, PEPY, CHI1, CHI2,
CHI3),  or have the specified difference (for NX, NY, LENG, GX, GY, GZ). If the fitting condition
is maximum-fitting, the condition means a zone-fitting (for AX, BX, GMX, AY, BY, GMY, EX, EPX, EY,
EPY, R1, R2, R3, R4, DX, DPX, DY, DPY, PEX, PEPX, PEY, PEPY, CHI1, CHI2, CHI3), which suppress the
maximum of the function in the region between component1 and component2, or maximum-fitting for the
difference of the function (for NX,  NY, LENG, GX, GY, GZ). The fit region is shown in the first
part of the prompt when FFSPRMPT is ON.

Examples: (1) FIT QF.2-10

sets the current fit point at  10 components upstream from the entrance of the second QF.

          (2) FIT QF QD NX 0.5 BXM 10

sets the two-point fitting between QF and QD, then set the difference of NX between QF and QD to
be 0.5, and the maximum of BX to be 10 in the region between QF and QD.</pre>
<pre>See also:
 <a href=#Lmatching-function-commands>matching-function-commands</a> <a href=#Lcomponents>components</a> <a href=#LSHOW>SHOW</a> <a href=#LGO>GO</a> <a href=#LCALCULATE(CAL)>CALCULATE(CAL)</a>
</pre>
<h3><a name=LFITPOINTS(FITP)>FITPOINTS(FITP)</a></h3>
<pre>Usage: FITP n

 sets n to the number of off-momentum points in the off-momentum matching. If the fitting condition
is on-momentum only, it is not affected.</pre>
<pre>See also:
 <a href=#Lmatching-function-commands>matching-function-commands</a></pre>
<h3><a name=LFIX>FIX</a></h3>
<pre>Usage: (1) FIX element-pattern [keyword] [element-pattern1 [keyword1]..]

removes elements which match element-pattern from the matching variables. The optional keyword specifies
the non-default variables. If the keyword is omitted, all keywords are removed.
   For the MARK element at the beginning of the beam line, a special form can be used for the FIX
command. That is a form <matching-function>I (appending "I" to a matching-function name).

Example: FIX AXI BXI AYI BYI

removes incoming AX, BX, AY, and BY from the matching variables.

Usage: (2) FIX

sets the standard optics for the orbit correction commands.</pre>
<pre>See also:
 <a href=#LFREE>FREE</a> <a href=#LFIT>FIT</a> <a href=#LSHOW>SHOW</a> <a href=#LGO>GO</a> <a href=#LCALCULATE(CAL)>CALCULATE(CAL)</a> <a href=#Lwildcards>wildcards</a> <a href=#Lelements>elements</a></pre>
<h3><a name=LFREE>FREE</a></h3>
<pre>Usage: FREE element-pattern [keyword] [element-pattern1 [keyword1]..]

specifies elements which match element-pattern as the matching variables. The optional keyword specifies
the non-default variables. See default-keyword. 
   For the MARK element at the beginning of the beam line, a special form can be used for the FREE
command. That is a form <matching-function>I  (appending "I" to a matching-function name) which means
the incoming condition of the matching-function is varied in the matching.

Example: FREE AXI BXI AYI BYI

changes incoming AX, BX, AY, and BY to find the solution.</pre>
<pre>See also:
 <a href=#LFIX>FIX</a> <a href=#LFIT>FIT</a> <a href=#LSHOW>SHOW</a> <a href=#LGO>GO</a> <a href=#LCALCULATE(CAL)>CALCULATE(CAL)</a> <a href=#Lwildcards>wildcards</a> <a href=#Lelements>elements</a></pre>
<ul>
<li><h3><a name=Ldefault-keyword>default-keyword</a></h3>
<pre>The default and available non-default variable keywords are:

type    default-keyword  non-default variable keyword
DRIFT   L                -
BEND    ANGLE            K1,K0,E1,E2
QUAD    K1               ROTATE
SEXT    K2               ROTATE
OCT     K3               ROTATE
DECA    K4               ROTATE
DODECA  K5               ROTATE
MULT    K1               K0,K2..K21,SK0,SK1,SK2..SK21,ROTATE,ANGLE
MARK    -                AX,BX,EX,EPX,AY,BY,EY,EPY,R1,R2,R3,R4,DETR,
                         DX,DPX,DY,DPY,DZ,DDP,AZ,BZ,ZX,ZPX,ZY,ZPY</pre>
<pre>See also:
 <a href=#Lkeywords>keywords</a></pre>
</ul>
<h3><a name=Lgeometric-functions>geometric-functions</a></h3>
<pre>Available geometric-functions are:

GX      geometrical coordinate xi
GY      geometrical coordinate eta
GZ      geometrical coordinate zeta
CHI1    geometrical rotation angle ch1_1
CHI2    geometrical rotation angle ch1_2
CHI3    geometrical rotation angle ch1_3

The geometrical coordinate {xi, eta, zeta} is set by the ORG command, and its default origin is at
the entrance of the beam line, and the default directions are xi in s-direction, eta in -(x-direction),
and zeta in -(y-direction) at the entrance. The set {xi, eta, zeta} forms a right-hand system.
   The rotation angles are defined so as to give the local {x,y,s} is written

    {x, y, s}_local
   = rotate[s, chi3] rotate[x, chi2] rotate[y, -chi1]{x, y, s}_origin,

where rotate[a, b] reads "rotate around the new-a vector by b right-handedly.

geometric functions disignate the geometry of the coordinate. If the geometry of orbit is needed,
use LINE["OGEO"], etc., or DISP OG.</pre>
<pre>See also:
 <a href=#Loptical-functions>optical-functions</a> <a href=#Lmatching-function-commands>matching-function-commands</a> <a href=#LDISPLAY(DISP)>DISPLAY(DISP)</a>
 <a href=#LGEOCAL>GEOCAL</a> <a href=#LGEOFIX>GEOFIX</a> <a href=#LORG>ORG</a> <a href=#LLINE>LINE</a></pre>
<h3><a name=LGO>GO</a></h3>
<pre>Usage: GO [[NO]EXPAND]

Does matching for fitting conditions given by matching-function-commands with variables specified
by FREE.

If an option EXPAND is given (default), it expands the beam line before the calculation. If NOEXPAND
is given, it avoids any expansion.   FFS["CAL"] and FFS["GO"] returns the result as a list, whose
format is

   {dp, kind, reslist, function-values},

where

          
dp:       a list contains dp/p0 .
kind:     a list of kind of the orbit (usually 0, but 1 to 6 for the finite amplitude matching, see
          MatchingAmplitude).
reslist:  a list of {residual, xstab, ystab}, where
       residual: matching residual,
       xstab:    True when the matrix is stable in X,
       ystab:    True when the matrix is stable in Y, for each orbit.

Above are lists with length nf (== number of orbits).

function-values: a list of length nc (== number of calculated items). Each element has the form:

       {component1, component2, function, list-of-values},

       where

       component1, component2: fit locations (see FIT).
       function: name of the function (see matching-function-commands).
       list-of-values: list of the value of the function for each orbit Length nf.
       The central orbit comes at the Floor[(n+1)/2]-th element.</pre>
<pre>See also:
 <a href=#LFIT>FIT</a> <a href=#LSHOW>SHOW</a> <a href=#Lmatching-function-commands>matching-function-commands</a> <a href=#Loff-momentum-matching>off-momentum-matching</a>
 <a href=#LFREE>FREE</a> <a href=#LFIX>FIX</a> <a href=#LVARIABLES(VAR)>VARIABLES(VAR)</a> <a href=#LCOUPLE(COUP)>COUPLE(COUP)</a> <a href=#LATTRIBUTE(ATTR)>ATTRIBUTE(ATTR)</a> <a href=#LCALCULATE(CAL)>CALCULATE(CAL)</a>
 <a href=#LVARY>VARY</a> <a href=#LSHOW>SHOW</a> <a href=#LCONV>CONV</a> <a href=#LCONVERGENCE>CONVERGENCE</a> <a href=#LMatchingResidual>MatchingResidual</a> <a href=#LMatchingAmplitude>MatchingAmplitude</a>
 <a href=#LFitFunction>FitFunction</a> <a href=#LFFS>FFS</a> <a href=#LOptimizeOptics>OptimizeOptics</a></pre>
<h3><a name=LIF>IF</a></h3>
<pre>Usage: IF expr1 body1 [ELSEIF expr2 body2 [ELSEIF ..]] [ELSE body3] ENDIF

This is a FORTRAN77 like IF-structure. If the expression expr1 is True(==1) or nonzero, executes
commands in body1. If it is False(==0), skip commands until ELSE, ELSEIF or ENDIF appears at the
same level of the IF-structure, and executes commands after ELSE or ENDIF, or executes the ELSEIF
command. If expr1 is not a real number, an error message is printed and ignores the command line.</pre>
<pre>See also:
 <a href=#LELSE>ELSE</a> <a href=#LELSEIF>ELSEIF</a> <a href=#LENDIF>ENDIF</a> <a href=#Lexpression>expression</a> <a href=#Lcommand-syntax>command-syntax</a> If</pre>
<h3><a name=LINPUT(IN)>INPUT(IN)</a></h3>
<pre>IN {filename | file-number} switches the input stream to the specified file or the file-number. The
original stream is kept and to be returned by TERMINATE(TERM). The input file is not rewound.</pre>
<pre>See also:
 <a href=#LTERMINATE(TERM)>TERMINATE(TERM)</a> <a href=#LCLOSE(CLO)>CLOSE(CLO)</a> <a href=#LREAD>READ</a> <a href=#LOUTPUT(OUT)>OUTPUT(OUT)</a> <a href=#LAPPEND(APP)>APPEND(APP)</a>
 <a href=#LEND>END</a></pre>
<h3><a name=Lmachine-error-commands>machine-error-commands</a></h3>
<pre>Usage: machine-error-command [options] amount component-pattern ..

where machine-error-command is one of

command    keyword affected     applicable types
DELX       DX                   BEND QUAD SEXT OCT DECA DODECA SOL CAV
DELY       DY                   BEND QUAD SEXT OCT DECA DODECA SOL CAV
DL         L                    DRIFT SOL
DTHETA     ROTATE               QUAD SEXT OCT DECA DODECA CAV
DTHETA     DROTATE              BEND
DK         default-keyword      DRIFT BEND QUAD SEXT OCT DECA DODECA MULT SOL CAV
DDK        K0 or DBZ            BEND SOL

   amount is the amount of the error,
   component-pattern is the pattern to specify the components to be applied.

   Options are

                 
RANDOM(R)        Set amount*GaussRandom[] to the keyword.
UNIFORM(U)       Set the specified amount to the keyword without random number.
INCOHERENT(INC)  GaussRandom[] is called for each component. Default.
COHERENT(C)      GaussRandom[] is called once for each component-pattern.
PUT(P)           Set the error to the keyword. Default.
ADD(A)           Add the error to the keyword.</pre>
<pre>See also:
 <a href=#Lcomponents>components</a> <a href=#Lwildcards>wildcards</a> <a href=#Lkeywords>keywords</a> <a href=#Ldefault-keyword>default-keyword</a> <a href=#LDUMP>DUMP</a> <a href=#LSEED>SEED</a>
</pre>
<h3><a name=Lmatching-function-commands>matching-function-commands</a></h3>
<pre>Usage: (1) matching-function  goal-value [off-momentum-points]
       (2) matching-functionM goal-value [off-momentum-points]
       (3) matching-functionI incoming-value
       (4) matching-functionSCALE scale

(1) sets the matching condition for matching-function at the current fitting point or region with
the goal-value and the off-momentum-points (see off-momentum-matching).
   If off-momentum-points is omitted, the previous value for this matching-function at this fitting-point
is assumed. If the previous value is not defined, 1 is assumed. If -1 is given for off-momentum-points,
the matching-function is rejected from the matching (see REJECT(REJ)).
   If "*" is given for goal-value, the previous value is used if exists.

Example:   BX 10 3    (beta_x to be 10 at 3 momenta) 
           BX 20      (now beta_x to be 20 at 3 momenta (previous setting))
           BX *  5    (now beta_x to be 20 (previous setting) at 5 momenta)

(2) If the letter "M" is appended to matching-function, it means the maximum-fitting for the function.
The maximum of either the value (for positive-definite functions) or the absolute value (for bipolar
functions) are to be limited in the matching.

(3) If the letter "I" is appended to matching-function, it specifies the value of the incoming beam.

(4)
If SCALE is appended to matching-function, it sets the scale of the input/output of the function
to scale. This scale is used in the matching-function commands, DISPLAY(DISP), SHOW, etc.
(5) If the current fit location is at a MARK, @ for the goal value refers the save value at the MARK.
@- refers -(save value). These are useful to match between two beam lines.

   Available matching-functions are:
optical-functions (see optical-functions):
AX BX GMX NX AY BY GMY NY EX EPX EY EPY R1 R2 R3 R4 DETR DX DPX DY DPY DZ DDP PEX PEPX PEY PEPY TRX
TRY LENG
geometric-functions (see geometric-functions):
GX GY GZ CHI1 CHI2 CHI3</pre>
<pre>See also:
 <a href=#LFIT>FIT</a> <a href=#LGO>GO</a> <a href=#LSHOW>SHOW</a> <a href=#LMARK>MARK</a> <a href=#Loptical-functions>optical-functions</a> <a href=#Lgeometric-functions>geometric-functions</a>
 <a href=#Loff-momentum-matching>off-momentum-matching</a> <a href=#Lx-y-coupling>x-y-coupling</a> <a href=#LREJECT(REJ)>REJECT(REJ)</a> <a href=#Lspecial-variables>special-variables</a>
 <a href=#LDP>DP</a> <a href=#Lfunctions>functions</a> <a href=#LFitValue>FitValue</a> <a href=#LMatchingAmplitude>MatchingAmplitude</a></pre>
<h3><a name=Lmulti-turn-tracking>multi-turn-tracking</a></h3>
<pre>The multi-turn tracking can be done by the TRACK command of the MAIN level, the TRACK command in
FFS, or the DynamicApertureSurvey[] function in FFS. The latter only perform the DAPERT mode.

   The multi-turn tracking uses the closed orbit, normal coordinate, and the equilibrium emittances.
Therefore One of EMITTANCE(EMIT), the Emittance[] function, or the EMIT command in the MAIN level
are necessary to be done once in prior to the multi-turn-tracking. The values of EMITX, EMITY, EMITZ,
SIGE can be changed between EMITs and the multi-turn-tracking.</pre>
<pre>See also:
 <a href=#LEMITTANCE(EMIT)>EMITTANCE(EMIT)</a> <a href=#LRFSW>RFSW</a> <a href=#LRAD>RAD</a> <a href=#LFLUC>FLUC</a> <a href=#LRADCOD>RADCOD</a> <a href=#LSPAC>SPAC</a> <a href=#LWSPAC>WSPAC</a> <a href=#Lspecial-variables>special-variables</a>
 <a href=#Lequilibrium-beam-envelope>equilibrium-beam-envelope</a></pre>
<h3><a name=LMATRIX(MAT)>MATRIX(MAT)</a></h3>
<pre>Usage: MATRIX [{SYMPLECTIC(S) | PHYSICAL(P)}] [from to]

prints out the 4 by 5 (w/CALC4D) or 6 by 6 (w/CALC6D) transfer matrix from from-component to to-component.
If SYMPLECTIC(S) is specified (default), the symplectic transfer matrix on {x,px/p0,y,py/p0,dp/p0}
where p0 is the nominal momentum at the entrance, is given. Otherwise, in the case of TRPT, the transfer
matrix on {x,px/p0(s),y,py/p0(s),dp/p0(s)} is printed out.
   If the from- and to- components are omitted, entire beam line is assumed.
If to-component is upstream the from-component, it gives the inverse matrix (TRPT) or one-turn-wrapped
matrix (RING).</pre>
<pre>See also:
 <a href=#LDISPLAY(DISP)>DISPLAY(DISP)</a> <a href=#LTRPT>TRPT</a> <a href=#LRING>RING</a> <a href=#LCALC4D>CALC4D</a> <a href=#LCALC6D>CALC6D</a> TransferMatrix</pre>
<h3><a name=LMEASURE(MEA)>MEASURE(MEA)</a></h3>
<pre>Usage: MEA [end-component] [OUT file plot-spaces]

tracks particles from the entrance to end-component and prints out the statistics at the end. If
end-component is omitted, the component end used in the last MEASURE(MEA) (default: end of the beam
line) is assumed.
   If OUT file plot-spaces are attached, it plots phase space distribution on file. The phase-spaces
are specified like as X-PX, 
or X-Y, etc., (up to any numbers).
   Parameters for the tracking are specified by special-variables and flags:

seed for the random-number generator:
     SeedRandom[seed_Real] or SeedRandom[{seeds__Real}]

special-variables (can be set with =):
     NP        number of particles 
     EMITX     horizontal emittance
     EMITY     vertical emittance
     DP        relative momentum spread
     DP0       relative momentum offset dp/p0
     GCUT      cut-off value of the Gaussian tail
flags:
     GAUSS/UNIFORM    Gaussian/uniform(default) momentum distribution
     JITTER/NOJITTER  off(default)/on nullifying the incoming centroid offset
     RFSW/NORFSW      switch on(default)/off the rf-cavities
     RAD/NORAD        synchrotron radiation on/off
     RADCOD/NORADCOD  off/on compensation of energy loss due to radiation
     FIXSEED/MOVESEED keep(default)/unkeep the initial random-number seed

   The initial transverse distribution is Gaussian.</pre>
<pre>See also:
 <a href=#Lspecial-variables>special-variables</a> <a href=#LTrackParticles>TrackParticles</a> <a href=#LSeedRandom>SeedRandom</a> RESULTOFTRACKING</pre>
<h3><a name=Loff-momentum-matching>off-momentum-matching</a></h3>
<pre>FFS matches the optical functions for an orbit with finite momentum deviation.

Example: 
   DP=0.01;      sets the range of momentum to DP0-0.01 < dp/p0 < DP0+0.01 .
   BX 10 9;      sets the goal of betax to 10 m, at 9 points.
                 in the range above, i.e.,
                 dp/p0 = {-0.01,-0.0075,-0.005,-0.0025,0,
                          0.0025,0.005,0.0075,0.01} + DP0 .
   GO starts the matching.

As this example, the off-momentum points are chosen with equal separation. If the off-momentum point
n is an even number, the chosen points are same as the case of n+1, but the on-momentum point (==DP0)
is excluded.</pre>
<pre>See also:
 <a href=#Lmatching-function-commands>matching-function-commands</a> <a href=#LDP>DP</a> <a href=#LDP0>DP0</a></pre>
<h3><a name=Loptical-functions>optical-functions</a></h3>
<pre>Available optical functions for matching are:

      
AX    alpha_X
BX    beta_X
GMX   gamma_X
NX    psi_X, the default scale is 1/(2Pi)
AY    alpha_Y
BY    beta_Y
GMY   gamma_Y
NY    psi_Y, the default scale is 1/(2Pi)
EX    eta_X   (dispersion_X)
EPX   eta_Px  (dispersion_PX)
EY    eta_Y   (dispersion_Y)
EPY   eta_Py  (dispersion_PY)
R1    R_1     (see x-y-coupling)
R2    R_2     (see x-y-coupling)
R3    R_3     (see x-y-coupling)
R4    R_4     (see x-y-coupling)
DETR  R_1*R_4 - R_2*R_3 (see x-y-coupling)
DX    dx
DPX   dpx
DY    dy
DPY   dpy
DZ    dz
DDP   delta=dp/p0
AZ    alpha_Z
BZ    beta_Z
GMZ   gamma_Z
NZ    psi_Z, the default scale is 1/(2Pi)
ZX    zeta_X  (z-dispersion_X)
ZPX   zeta_Px (z-dispersion_PX)
ZY    zeta_Y  (z-dispersion_Y)
ZPY   zeta_Py (z-dispersion_PY)
PEX   eta_x   (dispersion_x)
PEPX  eta_px  (dispersion_px)
PEY   eta_y   (dispersion_y)
PEPY  eta_yy  (dispersion_py)
TRX   trace(T_X), only defined at the end of the beam line.
TRY   trace(T_Y), only defined at the end of the beam line.
LENG  length of the design orbit

In the above, upper case X, Px, Y, Py represents the x-y decoupled coordinate. EX, EPX, EY, EPY refer
the decoupled coordinate, while PEX, PEPX, PEY, PEPY are in the physical coordinate. On the other
hand,  DX, DPX, DY, DPY refer the physical coordinate.</pre>
<pre>See also:
 <a href=#Lgeometric-functions>geometric-functions</a> <a href=#Lx-y-coupling>x-y-coupling</a> <a href=#Lmatching-function-commands>matching-function-commands</a>
 <a href=#LGO>GO</a> <a href=#LCALCULATE(CAL)>CALCULATE(CAL)</a> <a href=#LDISPLAY(DISP)>DISPLAY(DISP)</a> <a href=#LSHOW>SHOW</a></pre>
<h3><a name=LORG>ORG</a></h3>
<pre>Usage: ORG location, dgx, dgy, dgz, dchi1, dchi2, dch3

sets the origin of the geometrical coordinate relative to the location with a relative shift (dgx,
dgy, dgz) and rotation (dchi1, dchi2, dchi3).</pre>
<h3><a name=LOUTPUT(OUT)>OUTPUT(OUT)</a></h3>
<pre>OUT {filename | file-number} switches the output stream to the specified file or the file-number.
The file is written from the beginning.</pre>
<pre>See also:
 <a href=#LTERMINATE(TERM)>TERMINATE(TERM)</a> <a href=#LCLOSE(CLO)>CLOSE(CLO)</a> <a href=#LINPUT(IN)>INPUT(IN)</a> <a href=#LREAD>READ</a> <a href=#LAPPEND(APP)>APPEND(APP)</a>
 <a href=#LEND>END</a></pre>
<h3><a name=Lpattern>pattern</a></h3>
<pre> Pattern is a special expression for mathing arguments in function definitions and rules with several
forms:

_           matches any single argument.
__          matches a sequence of 1 or more arguments.
___         matches a sequence of 0 or more arguments.
x_          matches any single argument, which is names x.
x__         matches a sequence of 1 or more arguments, which is named x.
x___        matches a sequence of 0 or more arguments, which is named x.
x:pattern   a pattern which is named x.
pattern:v   a pattern which has a default value v when matching is failed.
pattern..   a non-null sequence of arguments each of which matches pattern.
pattern...  a sequence, which can be null, of arguments each of which matches pattern.
expression  matches expression.</pre>
<pre>See also:
 <a href=#LMatchQ>MatchQ</a> <a href=#Ldefining-functions>defining-functions</a> rules</pre>
<ul>
<li><h3><a name=LMatchQ>MatchQ</a></h3>
<pre> MatchQ[x, pat] returns True if x matches pat</pre>
</ul>
<h3><a name=Lphysical-constants>physical-constants</a></h3>
<pre><img  class="eqs" src="SADHelp_img/equ_213.svg" /></pre>
<pre>See also:
 <a href=#Lconstants>constants</a> <a href=#Lexpression>expression</a> <a href=#Lspecial-variables>special-variables</a></pre>
<h3><a name=LPRINT(PRI)>PRINT(PRI)</a></h3>
<pre>PRI expression evaluates expression and prints out the result.</pre>
<pre>See also:
 <a href=#Lexpression>expression</a> <a href=#LPrint>Print</a></pre>
<h3><a name=LQUIT>QUIT</a></h3>
<pre>Exits FFS and return to SAD/MAIN level, without saving the values of the elements.</pre>
<pre>See also:
 <a href=#LSTOP>STOP</a> <a href=#LSAVE>SAVE</a> <a href=#LABORT>ABORT</a> <a href=#LUSE>USE</a> <a href=#LVISIT>VISIT</a> <a href=#LBYE>BYE</a></pre>
<h3><a name=LRADINT>RADINT</a></h3>
<pre>RADINT prints out the radiation integrals involving the x-coupling for all components of the beam
line.</pre>
<h3><a name=LREAD>READ</a></h3>
<pre>READ {filename | file-number} switches the input stream to the specified file or the file-number.
The original stream is kept and to be returned by TERMINATE(TERM). The input file is rewound.</pre>
<pre>See also:
 <a href=#LTERMINATE(TERM)>TERMINATE(TERM)</a> <a href=#LCLOSE(CLO)>CLOSE(CLO)</a> <a href=#LINPUT(IN)>INPUT(IN)</a> <a href=#LOUTPUT(OUT)>OUTPUT(OUT)</a> <a href=#LAPPEND(APP)>APPEND(APP)</a>
 <a href=#LEND>END</a></pre>
<h3><a name=LRECOVER(REC)>RECOVER(REC)</a></h3>
<pre>REC exchanges the values of FREEd elements with those when the last GO command was issued. FIXed
elements are not affected.</pre>
<pre>See also:
 <a href=#LGO>GO</a> <a href=#LFREE>FREE</a> <a href=#LFIX>FIX</a> <a href=#LRESET>RESET</a> <a href=#LSAVE>SAVE</a></pre>
<h3><a name=LREFERENCE(REF)>REFERENCE(REF)</a></h3>
<pre>REFERENCE(REF) sets the current optics as the reference optics.</pre>
<pre>See also:
 <a href=#Lreference-optics>reference-optics</a></pre>
<ul>
<li><h3><a name=Lreference-optics>reference-optics</a></h3>
<pre>Optics stored as a reference. Can be refered by DISP REF (mode), DRAW, Twiss, OpticsPlot. Set automatically
by the first CALC or GO after USE. Can be updated by REFERENCE(REF).</pre>
<pre>See also:
 <a href=#LREFERENCE(REF)>REFERENCE(REF)</a> <a href=#LDISPLAY(DISP)>DISPLAY(DISP)</a> <a href=#LDRAW>DRAW</a> <a href=#LTwiss>Twiss</a> <a href=#LOpticsPlot>OpticsPlot</a></pre>
</ul>
<h3><a name=LREJECT(REJ)>REJECT(REJ)</a></h3>
<pre>Usage: (1) REJ matching-function-pattern [matching-function-pattern1..]
       (2) REJ TOTAL
       (3) REJ TOTALFIT

rejects the matching-functions which match matching-function-pattern at the current FIT location.
If TOTAL or TOTALFIT is given, the entire matching conditions in all locations are rejected, then
output parameters by CALCULATE are reset when TOTAL is given.</pre>
<pre>See also:
 <a href=#Lmatching-function-commands>matching-function-commands</a> <a href=#LFIT>FIT</a> <a href=#Lwildcards>wildcards</a></pre>
<h3><a name=LRENUMBER(RENUM)>RENUMBER(RENUM)</a></h3>
<pre>RENUM comp renumbers the component number starting from a component comp.</pre>
<pre>See also:
 <a href=#Lcomponents>components</a></pre>
<h3><a name=LREPEAT(REP)>REPEAT(REP)</a></h3>
<pre>Usage: REP [n] body UNTIL [expr1]

executes commands in body n times until expr1 gives nonzero. The number n can be any expression which
gives a number. If n is omitted, infinity is assumed. If expr1 is omitted, False(==0) is assumed.</pre>
<pre>See also:
 <a href=#LUNTIL>UNTIL</a></pre>
<h3><a name=LRESET>RESET</a></h3>
<pre>Usage: RESET [ALL] [element-pattern]

restores the value of the elements. What are restored are the value of the default keyword of all
elements, the values of the non-default keywords which have been changed manually or by the matching.
If ALL is given, it resets all keywords. If element-pattern is given, reset is limited to the elements
which match the pattern.</pre>
<pre>See also:
 <a href=#LSAVE>SAVE</a> <a href=#LUSE>USE</a> <a href=#LVISIT>VISIT</a> <a href=#Lwildcards>wildcards</a> <a href=#LRECOVER(REC)>RECOVER(REC)</a></pre>
<h3><a name=LRESUME(RES)>RESUME(RES)</a></h3>
<pre>Resumes reading from the previous input stream suspended by SUSPEND(SUSP) or END.</pre>
<pre>See also:
 <a href=#LSUSPEND(SUSP)>SUSPEND(SUSP)</a> <a href=#LEND>END</a></pre>
<h3><a name=LREVERSE(REV)>REVERSE(REV)</a></h3>
<pre>REV changes the sign of AX, AY, EPX, EPY, R2, R3, DPX, DPY at the
entrance of the beam line.</pre>
<pre>See also:
 <a href=#Lmatching-function-commands>matching-function-commands</a></pre>
<h3><a name=Lset-value-of-element>set-value-of-element</a></h3>
<pre>Usage: element-pattern [keyword] [{MIN | MAX | MINMAX | MAXMIN}] value

sets value to the specified keyword of the elements which match element-pattern. If keyword is omitted,
the default-keyword is assumed. keyword can be a wildcard to apply all matching keywords.
   If MIN, MAX, MINMAX, MAXMIN are specified, it sets the limit of the default-keyword. Both MINMAX
and MAXMIN means MIN=-Abs[value] and MAX=+Abs[value].
   If the keyword is not the default-keyword, it affects both the current and the saved value.</pre>
<pre>See also:
 <a href=#LATTRIBUTE(ATTR)>ATTRIBUTE(ATTR)</a> <a href=#LSAVE>SAVE</a> <a href=#Lelements>elements</a> <a href=#Ldefault-keyword>default-keyword</a> <a href=#Lwildcards>wildcards</a>
 <a href=#LElement>Element</a></pre>
<ul>
<li><h3><a name=Lkeywords>keywords</a></h3>
<pre>Available keywords are:

        
type    keywords
DRIFT   L RADIUS
BEND    L ROTATE DROTATE DX DY ANGLE K0 K1 E1 E2 AE1 AE2 F1 FB1 FB2 FRINGE DISFRIN DISRAD EPS RANKICK
QUAD    L ROTATE DX DY K1 F1 F2 FRINGE DISFRIN DISRAD EPS
SEXT    L ROTATE DX DY K2 DISFRIN DISRAD
OCT     L ROTATE DX DY K3 DISFRIN DISRAD
DECA    L ROTATE DX DY K4 DISFRIN DISRAD
DODECA  L ROTATE DX DY K5 DISFRIN DISRAD
MULT    L DX DY DZ CHI1 CHI2 ROTATE(=CHI3) K0..K21 SK0..SK21 DISFRIN F1 F2 FRINGE DISRAD EPS VOLT
        DVOLT HARM PHI DPHI FREQ RADIUS ANGLE E1 E2 AE1 AE2 DROTATE
SOL     BZ DX DY DZ DPX DPY BOUND GEO CHI1 CHI2 CHI3 DBZ DISFRIN
CAVI    L ROTATE DX DY VOLT DVOLT V1 V20 V11 V02 FREQ PHI HARM RANVOLT RANPHASE DISFRIN FRINGE
TCAVI   L ROTATE DX DY K0 V1 FREQ PHI HARM RANKICK RANPHASE
COORD   DX DY CHI1 CHI2 CHI3 DIR
MARK    AX BX AY BY EX EPX EY EPY R1 R2 R3 R4 DETR DX DPX DY DPY DZ DDP AZ BZ NZ ZX ZPX ZY ZPY EMITX
        EMITY DP AZ SIGZ GEO OFFSET
APERT   DX1 DX2 DY1 DY2 DP AX AY DX DY</pre>
<pre>See also:
 <a href=#Ldefault-keyword>default-keyword</a> <a href=#Lset-value-of-element>set-value-of-element</a> <a href=#LElement>Element</a></pre>
<li><h3><a name=Ldefault-keyword>default-keyword</a></h3>
<pre>The default and available non-default variable keywords are:

type    default-keyword  non-default variable keyword
DRIFT   L                -
BEND    ANGLE            K1,K0,E1,E2
QUAD    K1               ROTATE
SEXT    K2               ROTATE
OCT     K3               ROTATE
DECA    K4               ROTATE
DODECA  K5               ROTATE
MULT    K1               K0,K2..K21,SK0,SK1,SK2..SK21,ROTATE,ANGLE
MARK    -                AX,BX,EX,EPX,AY,BY,EY,EPY,R1,R2,R3,R4,DETR,
                         DX,DPX,DY,DPY,DZ,DDP,AZ,BZ,ZX,ZPX,ZY,ZPY</pre>
<pre>See also:
 <a href=#Lkeywords>keywords</a></pre>
</ul>
<h3><a name=Lspecial-variables>special-variables</a></h3>
<pre>There are several variables which have special rolls in FFS. Some of them are also accessible in
the MAIN level.</pre>
<pre>See also:
 <a href=#Lconstants>constants</a> <a href=#Lexpression>expression</a> <a href=#Lflags>flags</a></pre>
<ul>
<li><h3><a name=L$Line>$Line</a></h3>
<pre> %Line counts the number of the results in FFS Shown with Out[]:= . Out remembers all outputs up
to Out[$Line]. $Line = 0 resets the counter and forgets the outputs.</pre>
<li><h3><a name=LCASE>CASE</a></h3>
<pre>CASE is a character-string to be attached with TITLE to issue the CASE command of TopDrawer in DRAW
or GEO commands.</pre>
<pre>See also:
 <a href=#LTITLE>TITLE</a> <a href=#LDRAW>DRAW</a> <a href=#LGEO>GEO</a></pre>
<li><h3><a name=LCHARGE>CHARGE</a></h3>
<pre>CHARGE contains the charge of the particle. The default is +1.</pre>
<li><h3><a name=LCONVERGENCE>CONVERGENCE</a></h3>
<pre>CONVERGENCE is the goal of the convergence(==MatchingResidual) in the matching. If MatchingResidual
becomes smaller than CONVERGENCE times the effective number of the conditions, the matching by GO
terminates. The flag CONV is set when MatchingResidual is smaller than CONVERGENCE after GO or CALCULATE(CAL).
The default value is 10^-9.</pre>
<pre>See also:
 <a href=#LGO>GO</a> <a href=#LMatchingResidual>MatchingResidual</a> <a href=#LCONV>CONV</a></pre>
<li><h3><a name=LDAPWIDTH>DAPWIDTH</a></h3>
<pre>DAPWIDTH is the successive width of the x-amplitudes to terminate the tracking assuming that the
aperture is enough. The default is 7.</pre>
<pre>See also:
 <a href=#LDynamicApertureSurvey>DynamicApertureSurvey</a></pre>
<li><h3><a name=LDP>DP</a></h3>
<pre>DP represents the relative momentum spread of the beam. It is automatically set by the keyword DP
of the MARK element at the beginning of the beam line. The value of EMITY affects the default weight
of variables in the matching. In the off-momentum matching, the range DP0 - DP < dp/p0 < DP0 + DP
is used for the matching. The assumed momentum-distribution in the BEAMSIZE(BEAM), MEASURE(MEA),
etc. commands, is Gaussian with the standard deviation DP and the mean DP0 if the flag GAUSS is on,
otherwise uniform (square) in the range DP0 - DP < dp/p0 < DP0 + DP.</pre>
<pre>See also:
 <a href=#LDP0>DP0</a> <a href=#Loff-momentum-matching>off-momentum-matching</a> <a href=#LGAUSS>GAUSS</a> <a href=#LUNIFORM>UNIFORM</a> <a href=#Lelements>elements</a> <a href=#LMARK>MARK</a></pre>
<li><h3><a name=LDP0>DP0</a></h3>
<pre> DP0 represents the central value of the relative momentum offset in the optics calculation, or the
center of the momentum distribution of the beam. The on-momentum optics has the relative momentum
deviation dp/p0 == DP0, and the off-momentum calculation is done in the range DP0 - DP < dp/p0 <
DP0 + DP.
 DP0 sets the momentum deviation of the closed orbit at the entrance for EMIT with RADTAPER.</pre>
<pre>See also:
 <a href=#LDP>DP</a> <a href=#Loff-momentum-matching>off-momentum-matching</a> <a href=#Lmatching-function-commands>matching-function-commands</a>
 <a href=#LEMITTANCE(EMIT)>EMITTANCE(EMIT)</a> <a href=#LRADTAPER>RADTAPER</a></pre>
<li><h3><a name=LDTSYNCH>DTSYNCH</a></h3>
<pre> DTSYNCH is the equilibrium arrival time advance (= -c*delta t, in meter) where the synchrotron radiation
loss balances with the RF, calculated by EMIT/Emittance[SaveEMIT->True]. This corresponds to the
origin of the RF phase. The default is zero.</pre>
<pre>See also:
 <a href=#LEMITX>EMITX</a> <a href=#LEMITY>EMITY</a> <a href=#LEMITZ>EMITZ</a> <a href=#LSIGZ>SIGZ</a> <a href=#LSIGE>SIGE</a> <a href=#LEMITTANCE(EMIT)>EMITTANCE(EMIT)</a> <a href=#LEmittance>Emittance</a> <a href=#LPHICAV>PHICAV</a>
</pre>
<li><h3><a name=LEFFRFFREQ>EFFRFFREQ</a></h3>
<pre> The effective angular frequency weff (= 2 Pi EFFRFFREQ) is obtained using the second derivative

  d^2Vcacc/dt^2 == -weff^2 Vcacc ,

ehere Vcacc is the total acceleration voltage at the equilibrium phase PHICAV. These quantities Vcacc
and its derivatives are summed over all CAVIs and MULTs.
 It is set by EMITTANCE(EMIT) or Emittance[]. Effective with RING only.</pre>
<pre>See also:
 <a href=#LEFFVC>EFFVC</a> <a href=#LPHICAV>PHICAV</a></pre>
<li><h3><a name=LEFFVC>EFFVC</a></h3>
<pre> Effective peak rf voltage EFFVC is given by

  Abs[ weff Vcacc + I dVcacc/dt ] / weff ,

where Vcacc, weff are total acceleration voltage at the equilibrium phase PHICAV and the effective
RF angular frequency (=2 Pi EFFRFFREQ). DVcacc/dt is the time derivative of Vcacc. The quantity Vcacc
and its derivatives are summed over all CAVIs and MULTs.
 It is set by EMITTANCE(EMIT) or Emittance[]. The unit is Volt. Effective with RING only.</pre>
<pre>See also:
 <a href=#LEFFVCRATIO>EFFVCRATIO</a> <a href=#LEFFRFFREQ>EFFRFFREQ</a> <a href=#LPHICAV>PHICAV</a></pre>
<li><h3><a name=LEFFVCRATIO>EFFVCRATIO</a></h3>
<pre> Ratio of (effective voltage)/(Sum[VOLT_k,{k}]) (default: 1). Set by EMITTANCE(EMIT) or Emittance[].
Effective with RING only.</pre>
<pre>See also:
 <a href=#LPHICAV>PHICAV</a> <a href=#LEFFVC>EFFVC</a></pre>
<li><h3><a name=LElementValues>ElementValues</a></h3>
<pre>ElementValues is a symbol to assign rules to determine values of keywords of elements or components.
This is used to give a dependence between keywords of different elements or components, or determine
then by a parametric expression.

Useage:  ElementValues = { key[elem] :> expr, ...}

where

       
key:   keyword to specify a value (string).
elem:  String to specify the elements or components, wildcards are allowed.
expr:  an expression which returs a real number to be set to the elements or components.

Example:  ElementValues = 
            { "DX"["QF1"] :> "DX"["QD1"]-0.001,
              "DY"["QF2.3"] :> -"DY"["QD1.2"],
              "ROTATE"["QF*"] :> f[x] }

Remarks:


1.  Iff elem contains ".", it is recognized as components, otherwise as elements.
2.  In the r.h.s. of the rule, an expression like key[elem] is evaluated as either LINE[key, elem]
    or Element[key, elem], depending on elem has ".".
3.  The expression expr can be any expression returning a real number.
4.  Later rules overrides the former, if many rules apply on the same keyword of the same element.
5.  The rule given by ElementValues overrides the relation given by COUP_LE command.
6.  Use a[b] in stead of a@b.
7.  ElementValues is cleared by USE. It is hidden by VISIT and restored by BYE.</pre>
<pre>See also:
 <a href=#LCOUPLE(COUP)>COUPLE(COUP)</a></pre>
<li><h3><a name=LEMITX>EMITX</a></h3>
<pre>EMITX is a real variable for the horizontal emittance (not normalized by gamma beta). It is automatically
set by the keyword EMITX of the MARK element at the beginning of the beam line. The EMITTANCE(EMIT)
command returns its calculated value in EMITX. The value of EMITX affects the default weight of variables
in the matching. Accessible in MAIN.</pre>
<pre>See also:
 <a href=#LEMITY>EMITY</a> <a href=#LEMITZ>EMITZ</a> <a href=#LSIGZ>SIGZ</a> <a href=#LSIGE>SIGE</a> <a href=#LDP>DP</a> <a href=#Lelements>elements</a> <a href=#LMARK>MARK</a></pre>
<li><h3><a name=LEMITXE>EMITXE</a></h3>
<pre>EMITXE specifies the minimum horizontal emittance for EMITTANCE(EMIT) and Emittance[] calculations.
It is useful to give emittance determined externally, such as for proton machines.</pre>
<pre>See also:
 <a href=#LEMITYE>EMITYE</a> <a href=#LEMITZE>EMITZE</a></pre>
<li><h3><a name=LEMITY>EMITY</a></h3>
<pre>EMITY is a real variable for the vertical emittance (not normalized by gamma beta). It is automatically
set by the keyword EMITY of the MARK element at the beginning of the beam line. The EMITTANCE(EMIT)
command returns its calculated value in EMITY. The value of EMITY affects the default weiht of
variables in the matching. Accessible in MAIN.</pre>
<pre>See also:
 <a href=#LEMITX>EMITX</a> <a href=#LEMITZ>EMITZ</a> <a href=#LSIGZ>SIGZ</a> <a href=#LSIGE>SIGE</a> <a href=#LDP>DP</a> <a href=#Lelements>elements</a> <a href=#LMARK>MARK</a></pre>
<li><h3><a name=LEMITYE>EMITYE</a></h3>
<pre>EMITYE specifies the minimum vertical emittance for EMITTANCE(EMIT) and Emittance[] calculations.
It is useful to give emittance determined externally, such as for proton machines.</pre>
<pre>See also:
 <a href=#LEMITXE>EMITXE</a> <a href=#LEMITZE>EMITZE</a></pre>
<li><h3><a name=LEMITZ>EMITZ</a></h3>
<pre>EMITZ is a real variable for the longitudinal emittance (not normalized by gamma beta). It is automatically
set by the keyword EMITZ of the MARK element at the beginning of the beam line. The EMITTANCE(EMIT)
command returns its calculated value in EMITZ. Accessible in MAIN.</pre>
<pre>See also:
 <a href=#LEMITX>EMITX</a> <a href=#LEMITY>EMITY</a> <a href=#LSIGZ>SIGZ</a> <a href=#LSIGE>SIGE</a> <a href=#LDP>DP</a> <a href=#Lelements>elements</a> <a href=#LMARK>MARK</a></pre>
<li><h3><a name=LEMITZE>EMITZE</a></h3>
<pre>EMITZE specifies the minimum longitudinal emittance for EMITTANCE(EMIT) and Emittance[] calculations.
It is useful to give emittance determined externally, such as for proton machines.</pre>
<pre>See also:
 <a href=#LEMITXE>EMITXE</a> <a href=#LEMITYE>EMITYE</a></pre>
<li><h3><a name=LExponentOfResidual>ExponentOfResidual</a></h3>
<pre>The exponent to calculate MatchinResidual. The default is 2.</pre>
<pre>See also:
 <a href=#LMatchingResidual>MatchingResidual</a> <a href=#LGO>GO</a></pre>
<li><h3><a name=LFFS$NumericalDerivative>FFS$NumericalDerivative</a></h3>
<pre>If False (default), the calculation of response matrix for each matching variables uses analytical
expressions as much as possible. If True, performs numerical differentiation during the matching
by GO. It is useful for some variables and matching functions in some cases. It is slow, so should
be avoided for off-momentum-matching for a large beam line.</pre>
<pre>See also:
 <a href=#LGO>GO</a> <a href=#Loff-momentum-matching>off-momentum-matching</a></pre>
<li><h3><a name=LFitFunction>FitFunction</a></h3>
<pre>FitFunction is a symbol to assign user-defined functions for matching with the GO command. 

Usage:   FitFunction := fun, 

where fun is a function that returns a real number or a list of real numbers, to be matched to zero
by GO. The goal of GO is to make fun zero or a list of zeros, together with built-in matching conditions.
Thus the sum of fun^2 is added to MatchingResidual. GO also evaluates FitFunction to obtain the derivatives
numerically. The function fun can refer the value of variables by Element or LINE functions, and
the optical functions at DP0 by Twiss. The algorithm of matching is same as that for built-in conditions,
but it is slower because of the numerical differentiation, when the beam line is long and the number
of variables large.

Example:  FitFunction := {Twiss["BX","$$$"]-20, Twiss["BY","$$$"]-20};

which puts the same goal as

   FIT $$$ BX 20 BY 20 .

   FitFunction is cleared by USE. It is also hidden by VISIT and restored by BYE.</pre>
<pre>See also:
 <a href=#LGO>GO</a> <a href=#LFREE>FREE</a> <a href=#LMatchingResidual>MatchingResidual</a> <a href=#LDP0>DP0</a> <a href=#LElement>Element</a> <a href=#LLINE>LINE</a> <a href=#LTwiss>Twiss</a></pre>
<li><h3><a name=LFSHIFT>FSHIFT</a></h3>
<pre>FSHIFT is the relative shift df/f0 of the revolution (or rf) frequency in a ring. This is valid in
EMITTANCE(EMIT), the particle-tracking, and CAL/GO with CALC6D. For CAL/GO with CALC4D, DP0 should
be used instead.</pre>
<pre>See also:
 <a href=#LEMITTANCE(EMIT)>EMITTANCE(EMIT)</a> <a href=#LCALCULATE(CAL)>CALCULATE(CAL)</a> <a href=#LGO>GO</a> <a href=#LCALC6D>CALC6D</a> <a href=#LCALC4D>CALC4D</a> <a href=#LDP0>DP0</a></pre>
<li><h3><a name=LGCUT>GCUT</a></h3>
<pre>GCUT specifies the cut-off value of Gaussian distribution in unit of the standard deviation. Accessible
in MAIN.</pre>
<pre>See also:
 <a href=#LSEED>SEED</a> <a href=#LGAUSS>GAUSS</a> <a href=#LGaussRandom>GaussRandom</a></pre>
<li><h3><a name=LInitialOrbits>InitialOrbits</a></h3>
<pre>Usage: InitialOrbits = { {x1, px1, y1, py1, z1, dp1}, ...};

or     InitialOrbits = { {ax1, bx1, nx1, ay1, by1, ny1,
          ex1, epx1, ey1, epy1, r11, r21, r31, r41,
          x1, px1, y1, py1, z1, dp1, 0, 0, 0, 0, 0, 0, 0}, ...};

specifies initial conditions of a number of orbits for the optics calculation by CALCULATE(CAL) and
GO. Those coordinates are offset from the central orbit. If six numbers are given, only the offsets
of the orbits are affected. If 27 numbers are given, all Twiss parameters are set (values for non-orbit
params are used directly. Orbits are giving offsets.)
  If InitialOrbits are given, the off-momentum matching and finite-amplitude matching is disabled.

 InitialOrbits is also necessary to calculate optics with wake field.</pre>
<pre>See also:
 <a href=#LCALCULATE(CAL)>CALCULATE(CAL)</a> <a href=#LGO>GO</a> <a href=#Loff-momentum-matching>off-momentum-matching</a> <a href=#LMatchingAmplitude>MatchingAmplitude</a>
</pre>
<li><h3><a name=LLOSSAMPL>LOSSAMPL</a></h3>
<pre>
LOSSAMPL is the transverse amplitude beyond which a particle is judged to have been lost. The default
is 1 m. Accessible in MAIN.</pre>
<pre>See also:
 <a href=#LLOSSDZ>LOSSDZ</a> <a href=#LAPERT>APERT</a></pre>
<li><h3><a name=LLOSSDZ>LOSSDZ</a></h3>
<pre>LOSSDZ is the longitudinal position z beyond which a particle is judged to have been lost. The default
is 100 m. Accessible in MAIN. LOSSDZ is effective only when SPAC is ON.</pre>
<pre>See also:
 <a href=#LLOSSAMPL>LOSSAMPL</a> <a href=#LAPERT>APERT</a> <a href=#LSPAC>SPAC</a></pre>
<li><h3><a name=LMatchingAmplitude>MatchingAmplitude</a></h3>
<pre>MatchingAmplitude is a list of amplitudes for the finite-amplitude matching.

Usage: MatchingAmplitude := { {dp1,x1,y1}, ..};

where dp1 is the momentum deviation to be matched, x1 and y1 are the horizontal and vertical amplitudes
at the beginning of the beam line, normalized by Sqrt of the sum of the emittance, i.e., Sqrt[(EMITX+EMITY)].
Three orbits are chosen in each dimension. The initial conditions of the orbit is chosen as

   {X,Px,Y,Py} =
   { {x1,0,0,0}, {-x1/2,Sqrt[3]/2 x1,0,0}, {-x1/2,-Sqrt[3]/2 x1,0,0},
     {0,0,y1,0}, {0,0,-y1/2,Sqrt[3]/2 y1}, {0,0,-y1/2,Sqrt[3]/2 y1} },

and when x1==0 or y1==0 corresponding orbits are excluded. The above are labeled {x1,x2,x3,y1,y2,y3}
in the output of CALCULATE(CAL) or GO, and also labeled 1 to 6 in the second element of FFS["CALC"]
and FFS["GO"].

    This matching is done when dp1 is within the off-momentum range given by DP, i.e., Abs[dp1] <
DP. If dp1 is in the range, the nearest zero- amplitude optics is chosen. The maching conditions
for the finite- amplitude optics are same as those for the zero-amplitude one.
   Th orbit with finte initial condition never close after one revolution, but FFS simply ignores
it and obtain the periodic optics around the open
orbit.</pre>
<pre>See also:
 <a href=#LDP>DP</a> <a href=#LEMITX>EMITX</a> <a href=#LEMITY>EMITY</a> <a href=#Loff-momentum-matching>off-momentum-matching</a> <a href=#LCALCULATE(CAL)>CALCULATE(CAL)</a> <a href=#LGO>GO</a>
</pre>
<li><h3><a name=LMatchingResidual>MatchingResidual</a></h3>
<pre>MatchingResidual holds the convergence in the last GO or CALCULATE(CAL) commands. It is calculated
by

     sw*(Sum[(w_i*df_i)^ExponentOfResidual,{i}]/sw)^(2/ExponentOfResidual)
     +penalty
 where w_i is the weight of the i-th condition, df_i is the difference of the i-th function from
the goal, penalty is an additional big number  (typically 10), when the optics is unstable or closed
orbit is not found in the case of CELL. The parameter sw is defined as

     sw=Sum[(OffMomentumWeight/2/woff)^2,{i}]
 with

     woff = 1                               for on-momentum optics
          = Sqrt[number-of-momentum-points] for off-momentum optics.
 The weight of the function is lighter in the case of off-momentum-matching so that all off-momentum
deviations functions weight equal to the on-momentum one. However, the relative weight for the off-momentum
part can be changed by setting OffMomentumWeight. 
   The weight of each function at each point with each momentum can be specified by defining the
FitWeight function.</pre>
<pre>See also:
 <a href=#LExponentOfResidual>ExponentOfResidual</a> <a href=#LCONVERGENCE>CONVERGENCE</a> <a href=#LOffMomentumWeight>OffMomentumWeight</a> <a href=#Loff-momentum-matching>off-momentum-matching</a>
 <a href=#LFitWeight>FitWeight</a></pre>
<li><h3><a name=LMASS>MASS</a></h3>
<pre>MASS is the rest mass of the particle in eV. The default is the electron mass.</pre>
<li><h3><a name=LMINCOUP>MINCOUP</a></h3>
<pre>MINCOUP is the minimum emittance ratio to be assumed in the calculation of intrabeam effects in EMITTANCE(EMIT)
and Emittance[]. Emittances Max[emit_k, MINCOUP*(emit_x+emit_y)] (k=x,y) are assumed in the intrabeam
calculation. Accessible in MAIN.</pre>
<pre>See also:
 <a href=#LEMITTANCE(EMIT)>EMITTANCE(EMIT)</a> <a href=#LEmittance>Emittance</a> <a href=#LINTRA>INTRA</a> <a href=#Lequilibrium-beam-envelope>equilibrium-beam-envelope</a>
</pre>
<li><h3><a name=LMOMENTUM>MOMENTUM</a></h3>
<pre>MOMENTUM is the nominal momentum of the beam line at the entrance in eV/c. Accessible in MAIN.</pre>
<li><h3><a name=LNBUNCH>NBUNCH</a></h3>
<pre>NBUNCH is the number of bunches for the calculation of WakeFunction. Accessible in MAIN.</pre>
<pre>See also:
 <a href=#LPBUNCH>PBUNCH</a></pre>
<li><h3><a name=LNetResidual>NetResidual</a></h3>
<pre>The net residual of convergence except the penalty for unstable optics.</pre>
<pre>See also:
 <a href=#LMatchingResidual>MatchingResidual</a> StablilityLevel</pre>
<li><h3><a name=LNP>NP</a></h3>
<pre>NP is the number of particles in the tracking. Accessible in MAIN.</pre>
<pre>See also:
 <a href=#LMEASURE(MEA)>MEASURE(MEA)</a></pre>
<li><h3><a name=LNPARA>NPARA</a></h3>
<pre>NPARA specifies the maximum number of parallel processes for various calculations such as CALC, GO,
TrackParticles, DynamicApertureSurve, etc.</pre>
<pre>See also:
 <a href=#LCALCULATE(CAL)>CALCULATE(CAL)</a> <a href=#LGO>GO</a> <a href=#LTrackParticles>TrackParticles</a> <a href=#LDynamicApertureSurvey>DynamicApertureSurvey</a>
</pre>
<li><h3><a name=LOffMomentumWeight>OffMomentumWeight</a></h3>
<pre>Relative weight of the off-momentum deviation for the off-momentum matching. The default is 1.</pre>
<pre>See also:
 <a href=#LExponentOfResidual>ExponentOfResidual</a> <a href=#LCONVERGENCE>CONVERGENCE</a> <a href=#LMatchingResidual>MatchingResidual</a> <a href=#Loff-momentum-matching>off-momentum-matching</a>
 <a href=#LFitWeight>FitWeight</a></pre>
<li><h3><a name=LOMEGA0>OMEGA0</a></h3>
<pre>OMEGA0 is 2*Pi*SpeedOfLight/LINE["s","$$$"] . Accessible in MAIN.</pre>
<pre>See also:
 <a href=#LSpeedOfLight>SpeedOfLight</a> <a href=#LLINE>LINE</a></pre>
<li><h3><a name=LOpticsEpilog>OpticsEpilog</a></h3>
<pre>OpticsEpilog is a variable to assign a user-defined function which is to be executed every time after
an optics calculation is done in CALCULATE(CAL) or GO commands. In GO, OpticsEpilog is called at
the end of each iteration. This function is useful, for instance, for setting parameters which depends
on the result of optics calculation itself.</pre>
<pre>See also:
 <a href=#LOpticsProlog>OpticsProlog</a></pre>
<li><h3><a name=LOpticsProlog>OpticsProlog</a></h3>
<pre>OpticsProlog is a variable to assign a user-defined function which is to be executed every time before
an optics calculation is done in the CALCULATE(CAL) or GO commands. In GO, OpticsProlog is called
at the beginning of each iteration. This function is useful, for instance, for setting parameters
which depends on the result of optics calculation itself.</pre>
<pre>See also:
 <a href=#LOpticsEpilog>OpticsEpilog</a></pre>
<li><h3><a name=LPBUNCH>PBUNCH</a></h3>
<pre>PBUNCH is the number of particles/bunch for the calculation of the intra-beam and space charge effects
in EMITTANCE(EMIT), and WakeFunction. Accessible in MAIN.</pre>
<pre>See also:
 <a href=#LEMITTANCE(EMIT)>EMITTANCE(EMIT)</a> <a href=#LINTRA>INTRA</a> <a href=#LWSPAC>WSPAC</a> <a href=#LWakeFunction>WakeFunction</a> <a href=#Lequilibrium-beam-envelope>equilibrium-beam-envelope</a>
</pre>
<li><h3><a name=LPhotonList>PhotonList</a></h3>
<pre>When PHOTONS is ON (default is OFF), with RAD and FLUC, TrackParticles generates a list of all photons
radiated through the tracking. The list is assigned to a symbol PhotonList. PhotonList is a list
of

{en, gx, gy, gz, nx, ny, nz, xi1, xi2, xi3, np, nele}

where

en:    photon energy [eV]
gx:    GX coordinate of the emission point [m]
gy:    GY coordinate of the emission point [m]
gz:    GZ coordinate of the emission point [m]
nx:    GX component of the photon direction vector
ny:    GY component of the photon direction vector
nz:    GZ component of the photon direction vector (nx^2+ny^2+nz^2)=1.
xi1:   Stokes' parameter for polarization 45 degree to the GZ=0 plane.
xi2:   Stokes' parameter for right-handed polarization
xi3:   Stokes' parameter for polarization in the GZ=0 plane.
np:    particle number
nele:  component number in the beam line

The probability of each polarization is given by each Stokes' parameter as (1+xi)/2 . TrackParticles
always updates PhotonList. The length of PhtonList is the number of emitted photons.
   Remember that the {GX, GY, GZ} = {0, 0, 0} and their directions are {z, -x, -y} at the entrance
of the beam line by default. It is changeable by the GEO command anyway.</pre>
<pre>See also:
 <a href=#LPHOTONS>PHOTONS</a> <a href=#LTrackParticles>TrackParticles</a></pre>
<li><h3><a name=LPHICAV>PHICAV</a></h3>
<pre>The equilibrium RF phase (in radian, = 2 Pi EFFRFFREQ DTSYNCH/c) where the synchrotron radiation
loss and acceleration balances. If there are phase, voltage, frequency variations in RF cavities,
it is calculated based on "effective voltage". Effective with RING only.</pre>
<pre>See also:
 <a href=#LEFFVC>EFFVC</a> <a href=#LEFFRFFREQ>EFFRFFREQ</a> <a href=#LDTSYNCH>DTSYNCH</a> <a href=#LCAVI>CAVI</a> <a href=#LMULT>MULT</a></pre>
<li><h3><a name=LSIGE>SIGE</a></h3>
<pre> SIGE is the equilibrium momentum spread at the entrance of the beam line calculated by EMIT/Emittance[SaveEMIT->True].</pre>
<pre>See also:
 <a href=#LEMITX>EMITX</a> <a href=#LEMITY>EMITY</a> <a href=#LEMITZ>EMITZ</a> <a href=#LSIGZ>SIGZ</a> <a href=#LEMITTANCE(EMIT)>EMITTANCE(EMIT)</a> <a href=#LEmittance>Emittance</a></pre>
<li><h3><a name=LSIGZ>SIGZ</a></h3>
<pre> SIGZ is the equilibrium bunch length at the entrance of the beam line calculated by EMIT/Emittance[SaveEMIT->True].</pre>
<pre>See also:
 <a href=#LEMITX>EMITX</a> <a href=#LEMITY>EMITY</a> <a href=#LEMITZ>EMITZ</a> <a href=#LSIGE>SIGE</a> <a href=#LEMITTANCE(EMIT)>EMITTANCE(EMIT)</a> <a href=#LEmittance>Emittance</a></pre>
<li><h3><a name=LSpeedOfLight>SpeedOfLight</a></h3>
<pre>SpeedOfLight is 299792458.</pre>
<li><h3><a name=LStabilityLevel>StabilityLevel</a></h3>
<pre>Number of unstable planes in the optics calculations. Equal to zero if all x and y optics are stable
for on/off-momentum and finite amplitude matching.</pre>
<pre>See also:
 <a href=#LNetResidual>NetResidual</a> <a href=#LMatchingResidual>MatchingResidual</a></pre>
<li><h3><a name=LTITLE>TITLE</a></h3>
<pre>TITLE is a character-string to make the title of the plot in DRAW or GEO commands.</pre>
<pre>See also:
 <a href=#LCASE>CASE</a> <a href=#LDRAW>DRAW</a> <a href=#LGEO>GEO</a></pre>
</ul>
<h3><a name=LSAVE>SAVE</a></h3>
<pre>Usage: SAVE [element-pattern]

saves the values of the elements. What are saved are the value of the default keyword of all elements,
the values of the non-default keywords which have been changed manually or by the matching. If ALL
is given it resets all keywords. If element-pattern is given, it is only limited to the elements
which match the pattern, otherwise all elements are saved.</pre>
<pre>See also:
 <a href=#LRESET>RESET</a> <a href=#LUSE>USE</a> <a href=#LVISIT>VISIT</a> <a href=#LBYE>BYE</a> <a href=#LSTOP>STOP</a> <a href=#LQUIT>QUIT</a> <a href=#Lwildcards>wildcards</a></pre>
<h3><a name=LSEED>SEED</a></h3>
<pre>The SEED command is obsolete. Use SeedRandom[] function instead of SEED.</pre>
<pre>See also:
 <a href=#LMEASURE(MEA)>MEASURE(MEA)</a> <a href=#LFIXSEED>FIXSEED</a> <a href=#LMOVESEED>MOVESEED</a> <a href=#LSeedRandom>SeedRandom</a></pre>
<h3><a name=LSHOW>SHOW</a></h3>
<pre>SHOW prints out the current matching conditions.

   FFS["SHOW"] or FFS$SHOW[] returns the current matching conditions as a list. Each element has
a form of

{component1, component2, function, goal-value, number-of-momentums, scale},

which corresponds to the format of the print-out by SHOW.</pre>
<pre>See also:
 <a href=#Lmatching-function-commands>matching-function-commands</a> <a href=#LFIT>FIT</a> <a href=#LFFS>FFS</a> <a href=#LFFS$SHOW>FFS$SHOW</a></pre>
<h3><a name=LSPLIT>SPLIT</a></h3>
<pre>Usage: SPLIT component length

splits the component into two pieces at the point where the distance from the entrance is length.
The new components have the same name as the original, and the strengths are proportional to the
new lengths. Only magnets and cavities can be split. You should CALCULATE(CAL) after SPLIT to get
optical parameters after SPLIT. Matching using SPLIT element as a variable may degrade the speed
of convergence.</pre>
<h3><a name=LSTATUS(STAT)>STATUS(STAT)</a></h3>
<pre>STAT shows the current settings of flags, fit points, 
special-variables, the region for DISPLAY, seed of the random number generator, and elapsed CPU time,
etc.</pre>
<pre>See also:
 <a href=#Lspecial-variables>special-variables</a> <a href=#Lflags>flags</a></pre>
<h3><a name=LSTOP>STOP</a></h3>
<pre>Exits FFS and returns to SAD/MAIN level, with saving the values of the elements.</pre>
<pre>See also:
 <a href=#LQUIT>QUIT</a> <a href=#LSAVE>SAVE</a> <a href=#LABORT>ABORT</a> <a href=#LUSE>USE</a> <a href=#LVISIT>VISIT</a> <a href=#LBYE>BYE</a></pre>
<h3><a name=LSUSPEND(SUSP)>SUSPEND(SUSP)</a></h3>
<pre>Suspend reading from the current input stream, and wait for input from the console. Resumes by RESUME(RES)</pre>
<pre>See also:
 <a href=#LRESUME(RES)>RESUME(RES)</a> <a href=#LEND>END</a></pre>
<h3><a name=LTERMINATE(TERM)>TERMINATE(TERM)</a></h3>
<pre>   TERM [INPUT(IN)] suspends the current input stream and switches it to the previous input stream.

  TERM OUTPUT(OUT) suspends the current output and switches it to the previous output stream.</pre>
<pre>See also:
 <a href=#LCLOSE(CLO)>CLOSE(CLO)</a> <a href=#LINPUT(IN)>INPUT(IN)</a> <a href=#LREAD>READ</a> <a href=#LOUTPUT(OUT)>OUTPUT(OUT)</a> <a href=#LAPPEND(APP)>APPEND(APP)</a> <a href=#LEND>END</a></pre>
<h3><a name=LTYPE(T)>TYPE(T)</a></h3>
<pre>Usage: TYPE [element-pattern [element-pattern1..]]

prints out the values of elements which match element-pattern in the SAD MAIN input format. Keywords
which have zero values are omitted unless it is the default variable. If non element-pattern is given,
all elements are printed out.</pre>
<pre>See also:
 <a href=#LDISPLAY(DISP)>DISPLAY(DISP)</a> <a href=#LVARIABLES(VAR)>VARIABLES(VAR)</a> <a href=#Lelements>elements</a></pre>
<h3><a name=LUNTIL>UNTIL</a></h3>
<pre>Usage: REP [n] body UNTIL [expr1]

executes commands in body n times until expr1 gives nonzero. The number n can be any expression which
gives a number. If n is omitted, infinity is assumed. If expr1 is omitted, False(==0) is assumed.</pre>
<pre>See also:
 <a href=#LREPEAT(REP)>REPEAT(REP)</a> <a href=#Lexpression>expression</a> <a href=#Lcommand-syntax>command-syntax</a> <a href=#Lfunctions>functions</a> Do</pre>
<h3><a name=LUSE>USE</a></h3>
<pre>Usage: USE [[NO]EXPAND] beam-line

switches the beam line used in FFS to the beam line given by beam-line. beam-line can be an BeamLine
object or the name of a beam line defined in MAIN. All information specific to the current beam line,
such as matching conditions is lost. If the keyword EXPAND is given (default), the new beam line
is expanded, i.e., the values of components are refreshed to the saved values.
   If a BeamLine object is used by USE or VISIT, the new beam line becomes a
new LINE in the MAIN level, with a name which is created automatically.</pre>
<pre>See also:
 <a href=#LVISIT>VISIT</a> <a href=#LBYE>BYE</a> <a href=#LEXPAND>EXPAND</a> <a href=#LBeamLine>BeamLine</a> <a href=#LBeamLineName>BeamLineName</a></pre>
<h3><a name=LVARIABLES(VAR)>VARIABLES(VAR)</a></h3>
<pre>VARIABLES displays a list of current matching-variables and their present, previous, saved, minimum,
and maximum values together with the COUPLEd master elements and their coefficients.
   When executed in the FFS function, it returns the result as a list.

   Usage:   FFS["VAR"]

returns a list of nvar elements, where nvar is the number of current matching-variables given by
the FREE command. Each element has the form

  {name, keyword, present, previous, saved, minimum, maximum, coupled-master-element, coupling-coefficient}
,

which corresponds to the output of the VARIABLES(VAR) command.</pre>
<pre>See also:
 <a href=#LFREE>FREE</a> <a href=#LCOUPLE(COUP)>COUPLE(COUP)</a> <a href=#LFFS>FFS</a></pre>
<h3><a name=LVARY>VARY</a></h3>
<pre>Usage: VARY keyword element-pattern

changes the default-keyword of the elements which match element-pattern to keyword.</pre>
<pre>See also:
 <a href=#LFREE>FREE</a> <a href=#Lelements>elements</a> <a href=#Lwildcards>wildcards</a></pre>
<h3><a name=LVISIT>VISIT</a></h3>
<pre>Usage: VISIT [[NO]EXPAND] beam-line

switches the beam line used in FFS to the beam line given by beam-line. beam-line can be an BeamLine
object or the name of a beam line defined in MAIN. All information specific to the current beam line,
such as matching conditions are reserved, and the previous beam line is restored when BYE command
is issued. If the keyword EXPAND is given (default), the new beam line is expanded, i.e., the values
of components are refreshed to the saved values.
   If a BeamLine object is used by USE or VISIT, the new beam line becomes a new LINE in the MAIN
level, with a name which is created automatically.</pre>
<pre>See also:
 <a href=#LUSE>USE</a> <a href=#LBYE>BYE</a> <a href=#LEXPAND>EXPAND</a> <a href=#LBeamLine>BeamLine</a> <a href=#LBeamLineName>BeamLineName</a></pre>
<h3><a name=Lwildcards>wildcards</a></h3>
<pre>   Many commands and functions accept the wildcards as a specification for the name of elements or
components. The valid wildcards are:

       *         matches any zero or more characters.
       %         matches one character.
       {..}      matches any character enclosed.
       {^..}     matches any character not enclosed.
       ..|..     alternative pattern.</pre>
<pre>See also:
 <a href=#Lelements>elements</a> <a href=#Lcomponents>components</a> <a href=#LDISPLAY(DISP)>DISPLAY(DISP)</a> <a href=#LTYPE(T)>TYPE(T)</a> <a href=#LSAVE>SAVE</a> <a href=#LRESET>RESET</a> <a href=#LFREE>FREE</a>
 <a href=#LFIX>FIX</a> <a href=#LATTRIBUTE(ATTR)>ATTRIBUTE(ATTR)</a> <a href=#LREJECT(REJ)>REJECT(REJ)</a> <a href=#LCALCULATE(CAL)>CALCULATE(CAL)</a> <a href=#Lfunctions>functions</a>
 <a href=#LElement>Element</a> <a href=#LLINE>LINE</a> <a href=#LTwiss>Twiss</a></pre>
<hr>
</body>
