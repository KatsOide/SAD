<<<<<<< HEAD
Help$Update="$Date: 2017/02/03 18:38:22 $"[8,17];
Help$Version="1.1.0.3k64";
=======
Help$Update="$Date: 2017/01/08 18:38:22 $"[8,17];
Help$Version="1.0.10.11k64";
>>>>>>> origin/master

Help$Messages=(Print["SAD/FFS Help Update: ",Help$Update];{
{" ",
 "\
Usage: Help [item [subitem ...]]\n\n\
displays (un)helpful information on the input item. \n\n\
>>> Wildcards or abbreviations can be used to specify the item. \n\
>>> Help prompts sub items or items on lower levels.  \n\
>>> At the prompt \".. Topic?\", type sufficient number of <Return>s to exit.\n\
>>> Type ?<Return> to see the information of the current item.\n\n\
   The FFS commands are shown in uppercases. The minimum abbreviated form \n\
of each command is enclosed in ().    Down to that form each command can be\n\
shorten.   The optional arguments for the commands are usually enclosed in\n\
[].\n\
   These messages are also available at http://acc-physics.kek.jp/SAD/SADHelp.HTML.",
  "",
 Sort[
 {{"GO",
   "\
Usage: GO [[NO]EXPAND]\n\n\
Does matching for fitting conditions given by matching-function-commands\n\
with variables specified by FREE.\n\n\
If an option EXPAND is given (default), it expands the beam line before the\n\
calculation.   If NOEXPAND is given, it avoids any expansion.\n\n"//
   (FFSGO$Message="\
   FFS[\"CAL\"] and FFS[\"GO\"] returns the result as a list, whose format\n\
is\n\n\
   {dp, kind, reslist, function-values},\n\n\
where\n\n\
dp:        a list contains dp/p0 .\n\
kind:      a list of kind of the orbit (ususally 0, but 1 to 6 for the\n\
           finite amplitude matching, see special-variables:MatchingAmplitude).\n\
reslist:   a list of {residual, xstab, ystab}, where\n\
           residual: matching residual,\n\
           xstab:    True when the matrix is stable in X,\n\
           ystab:    True when the matrix is stable in Y, for each orbit.\n\n\
Above are lists with length nf (== number of orbits).\n\n\
function-values: a list of length nc (== number of calculated items). Each\n\
           element has the form:\n\n\
           {component1, component2, function, list-of-values},\n\n\
           where\n\n\
           component1, component2: fit locations (see FIT).\n\
           function: name of the function (see matching-function-commands).\n\
           list-of-values: list of the value of the function for each orbit.\n\
                           Length nf.\n\
           The central orbit comes at the Floor[(n+1)/2]-th element."),
   "FIT SHOW matching-function-commands off-momentum-matching\
 FREE FIX VARIABLES(VAR) COUPLE(COUP) \
ATTRIBUTE(ATTR) CALCULATE(CAL) VARY SHOW flags CONV \
special-variables:CONVERGENCE MatchingResidual MatchingAmplitude \
FitFunction, functions:FFS-dedicated-function:FFS OptimizeOptics",
   {}},

  {"CALCULATE(CAL)",
   "\
Usage: (1) CALC [[NO]EXPAND]]\n\
       (2) CALC matching-function1[-] [matching-function2[-]..]\n\
 \n\
(1) With no argument or with an option [NO]EXPAND, calculates the optics \n\
and the matching-functions using the current values of the components. \n\
It prints out the values of the matching-functions specified either by the \n\
matching-function-commands or the second usage of CALC, as described below.\n\
If an option EXPAND is given(default), it expands the beam line before the \n\
calculation.   If NOEXPAND is given, it calculates without any expansion.\n"//
    FFSGO$Message//"\n\n\
(2) With matching-fuction names, sets the matching-functions at the current\n\
fit point to be printed out after calculation.   If the matching-function is\n\
followed by a minus sign, it suppresses the print-out.\n\
 \n\
Example: CALC BX BY CALC",
   "GO DISPLAY(DISP) COUPLE(COUP) ATTRIBUTE(ATTR) SHOW FIT \
matching-function-commands EXPAND flags:CONV \
special-variables:CONVERGENCE MatchingResidual \
functions:FFS-dedicated-functions:FFS",
    {}},

  {"DISPLAY(DISP)",
   "Usage: DISP_LAY [keywords] [pattern-string] [region]\n\n\
Displays values of various optical-/geometric-functions at the components\n\
given by the pattern-string in the region (see region) in the current beam\n\
line.\n\
   It has several display modes specified by the keywords.  As the default,\n\
it displays AX, BX, NX, EX, EPX, AY, BY, NY, EY, EPY, LENG, the length and \n\
the value of the default-keyword of the component.\n\
   Each line refers to the entrance of each component of the line.  \n\
The end of the beam line has the name \"$$$\".   The first component can be \n\
specified by \"^^^\".\n\
   DISP does not calculate the functions to be displayed, so CALCULATE(CALC)\n\
is necessary whenever values of components are updated.",
   "TYPE(T) optical-functions geometric-functions",
    Sort[
    {{"GEOMETRY(G)",
      "DISP G displays geometric information of the beam line.\n\
It shows the geometry at the coordinate, except for a SOL region,\n\
where the geometry at the orbit is shown.",
      "geometric-functions matching-function-commands",
      {}},

      {"OGEOMETRY(OG)",
      "DISP OG displays geometric information at the orbit.",
      "geometric-functions matching-function-commands",
      {}},
      
     {"ORBIT(O)",
      "\
DISP O displays the orbits DX, DPX, DY, DPY together with the other \n\
optical-functions.",
      "optical-functions matching-function-commands",
      {}},

     {"RMATRIX(R)",
      "DISP R displays the components of the x-y coupling matrix R\n\
together with the 1D optical parameters. See x-y-coupling.",
      "x-y-coupling optical-functions matching-function-commands",
      {}},

     {"PHYSICAL(P)",
      "DISP P displays the physical dispersions PEX, PEPX, PEY, PEPY,\n\
together with the 1D optical parameters.",
      "optical-functions matching-function-commands",
      {}},

     {"BEAM(B)",
      "DISP B displays the beam sizes and the projected Twiss parameters, \n\
calculated either by Twiss parameters or the EMIT command with\n\
the CODPLOT flag.\n\n\
Example: EMITX=...; EMITY=...;DP=...; \n\
         BEAMSIZE(BEAM)\n\
         DISP B",
      "BEAMSIZE(BEAM) EMITTANCE(EMIT) flags CODPLOT GAUSS UNIFORM special-variables EMITX EMITY DP",
      {}},

     {"ACCELERATION(A)",
      "\
DISP A displays the nominal energy, energy deviation(DDP), longitudinal\n\
position(z), and emittances for a transport line with accelerating cavities.\n\
The flag TRPT must be on.",
      "flags TRPT RING elements CAVI special-variables EMITX EMITY DP",
      {}},

     {"DUMPOPTICS(D)",
      "DISP D displays all matching-functions in one line \n\
suitable to be read by a spread-sheet program.",
      "optical-functions geometrical-functions matching-function-commands",
      {}},

      {"Z",
       "DISP Z displays muatching functions related to the Z plane:\n\
AZ BZ NZ DZ DDP ZX ZPX ZY ZPY , which are obtained by CALC/GO with CALC6D.",
      "extended-twiss-parameters",
      {}},

     {"region",
      "Region for DISPLAY(DISP) is specified as \n\n\
        DISP ....  begin [end] \n\n\
with begin and end having the form name[.order][{+-}offset] (see components).\n\n\
Example:   DISP ... QF.2-10 QD+5\n\n\
displays functions starting at 10 elements upstream from the entrance of the\n\
second QF through 5 elements downstream from the entrance of the first QD.\n\
The region for DISP is kept after once set   It is shown in the second part \n\
of the prompt when FFSPRMPT is ON, and also seen by the STATUS(STAT) \n\
command.\n\
The components which match the pattern-string in DISP are only chosen in \n\
the current region.",
      "ALL pattern-string components STATUS(STAT)",
      {}},

     {"ALL",
      "\
ALL is a word to choose the entire beam line for the region to be displayed.",
      "region pattern-string",
      {}},

     {"pattern-string",
      "The components in the current region can be selectively displayed \n\
by the DISP command using the pattern-string.   The pattern-string is a \n\
character string involving the wildcards to match the name of the components.\n\
Note that the components are chosen in the current region, and the keyword\n\
ALL is necessary to extend it to the entire beam line.",
      "wildcards components region ALL",
      {}}}]
  },

  {"STOP",
   "Exits FFS and returns to SAD/MAIN level, with saving the values of \n\
the elements.",
   "QUIT SAVE ABORT USE VISIT BYE",
   {}},

  {"QUIT",
   "Exits FFS and return to SAD/MAIN level, without saving the values of\n\
the elements.",
   "STOP SAVE ABORT USE VISIT BYE",
   {}},

  {"ABORT",
   "Stops SAD immediately.",
   "STOP QUIT SAVE USE VISIT BYE",
   {}},

  {"SAVE",
   "Usage: SAVE [element-pattern]\n\n\
saves the values of the elements.   What are saved are the value of the\n\
default keyword of all elements, the values of the non-default keywords \n\
which have been changed manually or by the matching. If ALL is given it\n\
resets all keywords.   If element-pattern is given, it is only limited\n\
to the elements which match the pattern, otherwise all elements are saved.",
   "RESET USE VISIT BYE STOP QUIT wildcards",
   {}},

  {"RESET",
   "Usage: RESET [ALL] [element-pattern]\n\n\
restores the value of the elements.   What are restored are the value \n\
of the default keyword of all elements, the values of the non-default \n\
keywords which have been changed manually or by the matching.   If ALL\n\
is given, it resets all keywords. If element-pattern is given, reset is\n\ 
limited to the elements which match the pattern.",
   "SAVE USE VISIT wildcards RECOVER(REC)",
   {}},

  {"wildcards",
   "\
   Many commands and functions accept the wildcards as a specification \n\
for the name of elements or components.\n\
The valid wildcards are:\n\n\
       *         matches any zero or more characters.\n\
       %         matches one character.\n\
       {..}      matches any character enclosed.\n\
       {^..}     matches any character not enclosed.\n\
       ..|..     alternative pattern.",
   "elements components DISPLAY(DISP) TYPE(T) SAVE RESET FREE FIX machine-errors ATTRIBUTE(ATTR)\
 REJECT CALCULATE(CALC) functions FFS-dedicated-functions:Element LINE Twiss",
   {}},

  {"END",
   "Closes the current output-stream and set the output stream to the \n\
standard output(6).   It also suspends all the input streams and switches \n\
to the standard input(5).   Since this command affects all input and output \n\
streams, you may consider to use TERMINATE(TERM) or CLOSE(CLO) to suspend \n\
or close them selectively.",
   "TERMINATE(TERM) CLOSE(CLO) INPUT(IN) READ OUTPUT(OUT) APPEND(APP)",
   {}},

  {"TERMINATE(TERM)",
   "\
   TERM [INPUT(IN)] suspends the current input stream and switches it to the\n\
previous input stream.\n\
   TERM OUTPUT(OUT) suspends the current output and switches it to the\n\
previous output stream.",
   "CLOSE(CLO) INPUT(IN) READ OUTPUT(OUT) APPEND(APP) END",
   {}},

  {"CLOSE(CLO)",
   "\
   CLOSE [INPUT(IN)] closes the current input stream and switches it to \n\
the previous input stream.\n\
   CLOSE OUTPUT(OUT) suspends the current output and switches it to the \n\
previous output stream.",
   "TERMINATE(TERM) INPUT(IN) READ OUTPUT(OUT) APPEND(APP) END",
   {}},

  {"INPUT(IN)",
   "\
IN {filename | file-number} switches the input stream to the specified \n\
file or the file-number.   The original stream is kept and to be returned \n\
by TERMINATE(TERM).   The input file is not rewound.",
   "TERMINATE(TERM) CLOSE(CLO) READ OUTPUT(OUT) APPEND(APP) END",
   {}},

  {"READ",
   "\
READ {filename | file-number} switches the input stream to the specified \n\
file or the file-number.   The original stream is kept and to be returned \n\
by TERMINATE(TERM).   The input file is rewound.",
   "TERMINATE(TERM) CLOSE(CLO) INPUT(IN) OUTPUT(OUT) APPEND(APP) END",
   {}},

  {"OUTPUT(OUT)",
   "\
OUT {filename | file-number} switches the output stream to the specified \n\
file or the file-number.   The file is written from the beginning.",
   "TERMINATE(TERM) CLOSE(CLO) INPUT(IN) READ APPEND(APP) END",
   {}},

  {"APPEND(APP)",
   "\
APP {filename | file-number} switches the output stream to the specified \n\
file or the file number.   The output is appended to the existing file.",
   "TERMINATE(TERM) CLOSE(CLO) INPUT(IN) READ OUTPUT(OUT) END",
   {}},

  {"EXECUTE(EXEC)",
   "Usage: EXEC character-string-expression\n\n\
executes the character-string-expression as FFS commands.",
   "expressions functions FFS ToExpression",
   {}},

  {"FIT",
   "\
Usage: (1) FIT [component]\n\
       (2) FIT component1 component2\n\n\
sets the current location where the matching condition is applied. \n\
The component is given with the form name[.order][{+-}offset] (see \n\
components).    If component is omitted, the end of the beam line is chosen.\n\
   If two components are given, it means a relative-fitting or zone-fitting.\n\
If the fitting condition is not maximum-fitting, the condition means to \n\
make values at two components equal (for AX, BX, AY, BY, EX, EPX, EY, EPY,\n\
R1, R2, R3, R4, DX, DPX, DY, DPY, PEX, PEPX, PEY, PEPY, CHI1, CHI2, CHI3), \n\
or have the specified difference (for NX, NY, LENG, GX, GY, GZ).\n\
   If the fitting condition is maximum-fitting, the condition means a \n\
zone-fitting (for AX, BX, AY, BY, EX, EPX, EY, EPY, R1, R2, R3, R4, DX, DPX,\n\
DY, DPY, PEX, PEPX, PEY, PEPY, CHI1, CHI2, CHI3), which\n\
suppress the maximum of the function in the region between component1 and \n\
component2, or maximum-fitting for the difference of the function (for NX, \n\
NY, LENG, GX, GY, GZ).\n\
   The fit region is shown in the first part of the prompt when FFSPRMPT is\n\
ON.\n\n\
Example: (1) FIT QF.2-10\n\n\
sets the current fit point at  10 components upstream from the entrance of \n\
the second QF.\n\n\
         (2) FIT QF QD NX 0.5 BXM 10\n\n\
sets the two-point fitting between QF and QD, then set the difference of NX \n\
between QF and QD to be 0.5, and the maximum of BX to be 10 in the region \n\
between QF and QD.",
   "matching-function-commands components SHOW GO CALC",
   {}},

   {"FREE",
    "Usage: FREE element-pattern [keyword] [element-pattern1 [keyword1]..]\n\n\
specifies elements which match element-pattern as the matching variables.\n\
The optional keyword specifies the non-default variables.   See\n\
default-keyword. \n\
   For the MARK element at the beginning of the beam line, a special form\n\
can be used for the FREE command.   That is a form <matching-function>I \n\
(appending \"I\" to a matching-function name) which means the incoming \n\
condition of the matching-function is varied in the matching.\n\n\
Example: FREE AXI BXI AYI BYI\n\n\
changes incoming AX, BX, AY, and BY to find the solution.",
    "FIX FIT SHOW GO CALC wildcards elements",
    {
     DefaultKeywordMessage=
     {"default-keyword",
      "\
The default and available non-default variable keywords are:\n\n\
type    default-keyword  non-default variable keyword\n\
DRIFT   L                -\n\
BEND    ANGLE            K1,K0,E1,E2\n\
QUAD    K1               ROTATE\n\
SEXT    K2               ROTATE\n\
OCT     K3               ROTATE\n\
DECA    K4               ROTATE\n\
DODECA  K5               ROTATE\n\
MULT    K1               K0,K2..K21,SK0,SK1,SK2..SK21,ROTATE,ANGLE\n\
MARK    -                AX,BX,EX,EPX,AY,BY,EY,EPY,R1,R2,R3,R4,DETR,\n\
                         DX,DPX,DY,DPY,DZ,DDP,AZ,BZ,ZX,ZPX,ZY,ZPY",
      "keywords",
      {}}
    }},

   {"FIX",
    "Usage: (1) FIX element-pattern [keyword] [element-pattern1 [keyword1]..]\n\n\
removes elements which match element-pattern from the matching variables.  \n\
The optional keyword specifies the non-default variables.   If the keyword \n\
is omitted, all keywords are removed.\n\
   For the MARK element at the beginning of the beam line, a special form\n\
can be used for the FIX command.   That is a form <matching-function>I \n\
(appending \"I\" to a matching-function name).\n\n\
Example: FIX AXI BXI AYI BYI\n\n\
removes incoming AX, BX, AY, and BY from the matching variables.\n\n\
Usage: (2) FIX\n\n\
sets the standard optics for the orbit correction commands.",
    "FREE FIT SHOW GO CALC wildcards elements",
    {}},

   {"VARIABLES(VAR)",
    "\
VARIABLES displays a list of current matching-variables and their present,\n\
previous, saved, minimum, and maximum values together with the COUPLEd master\n\
elements and their coefficients.\n\
   When executed in the FFS function, it returns the result as a list.\n\n\
   Usage:   FFS[\"VAR\"]\n\n\
returns a list of nvar elements, where nvar is the number of current \n\
matching-variables given by the FREE command.   Each element has the form\n\n\
  {name, keyword, present, previous, saved, minimum, maximum,\n\
   coupled-master-element, coupling-coefficient} ,\n\n\
which corresponds to the output of the VARIABLES(VAR) command.",
    "FREE COUPLE functions:FFS-dedicated-functions:FFS",
    {}},

   {"USE",
    "Usage: USE [[NO]EXPAND] beam-line\n\n\
switches the beam line used in FFS to the beam line given by beam-line.\n\
beam-line can be an BeamLine object or the name of a beam line defined\n\
in MAIN. All information specific to the current beam line, such as matching\n\
conditions is lost.   If the keyword EXPAND is given (default), the new \n\
beam line is expanded, i.e., the values of components are refreshed to the \n\
saved values.\n\
   If a BeamLine object is used by USE or VISIT, the new beam line becomes a\n\
new LINE in the MAIN level, with a name which is created automatically.",
    "VISIT BYE EXPAND functions:beamline-functions:BeamLine BeamLineName",
    {}},

   {"VISIT",
    "Usage: VISIT [[NO]EXPAND] beam-line\n\n\
switches the beam line used in FFS to the beam line given by beam-line.\n\
beam-line can be an BeamLine object or the name of a beam line defined\n\
in MAIN. All information specific to the current beam line, such as matching\n\
conditions are reserved, and the previous beam line is restored when BYE\n\
command is issued.   If the keyword EXPAND is given (default), the new beam\n\
line is expanded, i.e., the values of components are refreshed to the saved \n\
values.\n\
   If a BeamLine object is used by USE or VISIT, the new beam line becomes a\n\
new LINE in the MAIN level, with a name which is created automatically.",
    "USE BYE EXPAND functions:beamline-functions:BeamLine BeamLineName",
    {}},

   {"BYE",
    "Exits from the current beam line and returns to the original beam line \n\
where VISIT command was issued.   All information specific to the beam line,\n\
such as matching conditions are restored.\n\
   Note that BYE does neither SAVE the values of elements of the leaving \n\
beam line, nor RESET the values of elements of the returning beam line.",
    "VISIT USE SAVE RESET STOP QUIT ABORT",
    {}},

   {"SPLIT",
    "\
Usage: SPLIT component length\n\n\
splits the component into two pieces at the point where the distance from\n\
the entrance is length.   The new components have the same name as the\n\
original, and the strengths are proportional to the new lengths.\n\
Only magnets and cavities can be split.   You should CALCULATE(CAL) after\n\
SPLIT to get optical parameters after SPLIT.   Matching using SPLIT element\n\
as a variable may degrade the speed of convergence.",
    "",
    {}},

   {"ATTRIBUTE(ATTR)",
    "Usage: ATTR element-pattern\n\n\
prints out the current value, minimum and maximum values, COUPLEd element \n\
and its coefficient for elements which match the element-pattern.",
    "COUPLE element-command wildcards",
    {}},

   {"FITPOINTS(FITP)",
    "FITP n sets n to the number of off-momentum points in the off-momentum \n\
matching.   If the fitting condition is on-momentum only, it is not affected.",
    "matching-function-commands",
    {}},

   {"RECOVER(REC)",
    "REC exchanges the values of FREEd elements with those when the last \n\
GO command was issued.   FIXed elements are not affected.",
    "GO FREE FIX RESET SAVE",
    {}},

   {"TYPE(T)",
    "Usage: TYPE [element-pattern [element-pattern1..]]\n\n\
prints out the values of elements which match element-pattern in the \n\
SAD MAIN input format.   Keywords which have zero values are omitted unless \n\
it is the default variable.   If non element-pattern is given, all elements \n\
are printed out.",
    "DISPLAY(DISP) VARIABLES(VAR) elements",
    {}},

   {"ORG",
    "Usage: ORG location, dgx, dgy, dgz, dchi1, dchi2, dch3\n\n\
sets the origin of the geometrical coordinate relative to the location\n\
with a relative shift (dgx, dgy, dgz) and rotation (dchi1, dchi2, dchi3).",
    "",
    {}},

   {"EMITTANCE(EMIT)",
    "\
Usage: (1) EMIT\n\
       (2) EMIT dp\n\n\
(1) EMIT calculates the closed orbit, the normal coordinate, and the\n\
equilibrium emittance assuming the current beam line is a positron ring.\n\
One of EMITTANCE(EMIT), the Emittance[] function, or the EMIT command\n\
in the MAIN level are necessary to be done in prior to multi-turn tracking.\n\
See multi-turn-tracking.\n\n\
(2) EMIT dp, where dp is |df_rf/f_rf|/(alpha_p == momentum compaction), \n\
does EMIT for five rf frequencies:\n\n\
   df_rf/f_rf/alpha_p = -|dp|, -|dp|/2, 0, |dp|/2, |dp|,\n\n\
then prints out a table of the dependences of various quantities on the\n\
frequency shift.\n\n\
   The results of EMITTANCE(EMIT) are affected by flags COD, RADCOD, RFSW,\n\
INTRA, WSPAC, EMIOUT, CODPLOT and special-variables MOMENTUM, CHARGE, FSHIFT, MINCOUP, \n\
PBUNCH. The flag TRPT or RING affects only Emittance[], as EMITTANCE(EMIT)\n\
automatically set RING.\n\
   EMITTANCE(EMIT) returns the equilibrium emittaces in variables EMITX,\n\
EMITY, EMITZ, and the equilibrium bunch length in SIGZ, the relative\n\
momentum spread in SIGE.\n\n\
   The map used in EMIT is slightly different from that used in the tracking.\n\
For instance, the edge angle of a bend is approximated by a thin quad.\n\
If the edge angle is large and the curvature is small, EMIT may give a wrong \n\
answer.   This will be corrected in near future.",
    "multi-turn-tracking extended-Twiss-parameters \
flags:COD RADCOD RFSW INTRA EMIOUT WSPAC CODPLOT TRPT\
special-variables:MOMENTUM CHARGE FSHIFT MINCOUP PBUNCH \
functions:FFS-dedicated-functions:Emittance",
    {}},

   {"multi-turn-tracking",
    "\
The multi-turn tracking can be done by the TRACK command of the MAIN\n\
level, the TRACK command in FFS, or the DynamicApertureSurvey[] function\n\
in FFS.   The latter only perform the DAPERT mode.\n\n\
   The multi-turn tracking uses the closed orbit, normal coordinate, and \n\
the equilibrium emittances.   Therefore One of EMITTANCE(EMIT), the \n\
Emittance[] function, or the EMIT command in the MAIN level are necessary to\n\
be done once in prior to the multi-turn-tracking.   The values of EMITX, \n\
EMITY, EMITZ, SIGE can be changed between EMITs and the multi-turn-tracking.",
    "EMITTANCE(EMIT) flags:RFSW RAD FLUC RADCOD SPAC WSPAC special-variables",
    {}},

   {"machine-error-commands",
    "\
Usage: machine-error-command [options] amount component-pattern ..\n\n\
where machine-error-command is one of\n\n\
command    keyword affected     applicable types\n\
DELX       DX                   BEND QUAD SEXT OCT DECA DODECA SOL CAV\n\
DELY       DY                   BEND QUAD SEXT OCT DECA DODECA SOL CAV\n\
DL         L                    DRIFT SOL\n\
DTHETA     ROTATE               QUAD SEXT OCT DECA DODECA CAV\n\
DTHETA     DROTATE              BEND\n\
DK         default-keyword      DRIFT BEND QUAD SEXT OCT DECA DODECA MULT SOL CAV\n\
DDK        K0 or DBZ            BEND SOL\n\n\
   amount is the amount of the error,\n\
   component-pattern is the pattern to specify the components to be applied.\n\n\
   Options are\n\n\
RANDOM(R)        Set amount*GaussRandom[] to the keyword.  \n\
UNIFORM(U)       Set the specified amount to the keyword without random number.\n\
INCOHERENT(INC)  GaussRandom[] is called for each component.   Default.\n\
COHERENT(C)      GaussRandom[] is called once for each component-pattern.\n\
PUT(P)           Set the error to the keyword.   Default.\n\
ADD(A)           Add the error to the keyword.",
    "components wildcards keywords default-keyword DUMP SEED",
    {}},

   {"DUMP",
    "\
Usage: DUMP component-pattern [compnent-pattern1..]\n\n\
prints out the current machine errors of components which match component-\n\
pattern.",
    "machine-error-commands components wildcards",
    {}},

   {"elements",
    "An element in FFS represents an object which has a unique name and \n\
several keywords with values.   This simulates a power supply of a magnet. \n\
An element has one or more components, which correspond to individual \n\
magnets in a beam line.   Each component may have different values from \n\
the values of the corresponding element.   This simulates the machine error \n\
which varies magnet to magnet.   \n\
   The value of an element can be saved to or recovered from the \n\
element-save-buffer by SAVE or RESET commnads.   Different beam lines can \n\ 
share the same element, and their values can be different to each other,\n\
but they have the common element-save-buffer.   Therefore the value of an \n\
element can be transferred between beam lines by SAVE and RESET command \n\
through the element-save-buffer.\n\
   An element is created only in SAD MAIN level.   In the definition, if a\n\
keyword is omitted, the previous definition is unchanged.  All keywords have\n\
the default value zero.   In FFS, it is only possible to change their values.",
    "TYPE(T) set-value-of-element functions:FFS-dedicated-functions:Element",
    ElementsMessage=Sort[
      {DefaultKeywordMessage,

       KeywordsMessage=
       {"keywords",
        "Available keywords are:\n\n\
type    keywords\n\
DRIFT   L RADIUS\n\
BEND    L ROTATE DROTATE DX DY ANGLE K0 K1 E1 E2 AE1 AE2\n\
        F1 FB1 FB2 FRINGE DISFRIN\n\
        DISRAD EPS RANKICK\n\
QUAD    L ROTATE DX DY K1 F1 F2 FRINGE DISFRIN DISRAD EPS\n\
SEXT    L ROTATE DX DY K2 DISFRIN DISRAD\n\
OCT     L ROTATE DX DY K3 DISFRIN DISRAD\n\
DECA    L ROTATE DX DY K4 DISFRIN DISRAD\n\
DODECA  L ROTATE DX DY K5 DISFRIN DISRAD\n\
MULT    L DX DY DZ CHI1 CHI2 ROTATE(=CHI3) K0..K21 SK0..SK21\n\
        DISFRIN F1 F2 FRINGE DISRAD EPS VOLT HARM PHI DPHI FREQ\n\
        RADIUS ANGLE E1 E2 AE1 AE2 DROTATE\n\
SOL     BZ DX DY DZ DPX DPY BOUND GEO CHI1 CHI2 CHI3 DBZ DISFRIN\n\
CAVI    L ROTATE DX DY VOLT V1 V20 V11 V02 FREQ PHI HARM RANVOLT RANPHASE\n\
        DISFRIN FRINGE\n\
TCAVI   L ROTATE DX DY K0 V1 FREQ PHI HARM RANKICK RANPHASE\n\
COORD   DX DY CHI1 CHI2 CHI3 DIR\n\
MARK    AX BX AY BY EX EPX EY EPY R1 R2 R3 R4 DETR DX DPX DY DPY DZ DDP\n\
        AZ BZ NZ ZX ZPX ZY ZPY EMITX EMITY DP AZ SIGZ GEO OFFSET\n\
APERT   DX1 DX2 DY1 DY2 DP AX AY DX DY",
        "default-keyword set-value-of-element functions \
FFS-dedicated-functions:Element",
        {}},

      {"DRIFT",
        "A drift space.",
        "",
        {{"L",
          "Length.",
          "",
          {}},

         {"RADIUS",
          "Radius of the vacuum chamber. Effective when SPAC is ON.",
          "flags SPAC",
          {}},

         {"transformation",
          DRIFT$trans="\
The transformation of a drift is\n\n\
   exp(:H:),\n\n\
with\n\n\
   H(x, px, y, py, z, p) = (-(p^2 - px^2 - py^2) + 1 - E/v0) L .",
          "transformation:coordinates",
          {}}}},

      {"APERT",
       "\
An aperture.   Only valid in tracking.   A particle with\n\n\
   (x - DX)^2/AX^2 + (y - DY)^2/AY^2 < 1 && \n\
   Min[DX1, DX2] < x < Max[DX1, DX2] && \n\
   Min[DY1, DY2] < y < Max[DY2, DY2] \n\n\
can pass through the aperture, otherwise it is lost and a message\n\
is printed out. If AX or AY is zero (default), they are interpreted as\n\
infinity. If AX <=> 0 && AY <=> 0 and (DX1 == DX2 or DY1 == DY2) then\n\
the aperture is only determined by AX and AY.",
       "",
       {}},

      {"BEND",
       "A bending magnet.",
       "",
       Sort[
       {{"L",
          "Length along the arc of the orbit.",
          "",
          {}},

         ROTATE$Message=
         {"ROTATE",
          "\
Rotation in x-y plane.   After displacing the magnet by DX and DY, \n\
rotate the magnet around the local s-axis by -(amount given by ROTATE), \n\
then place the component. At the exit rotate back the magnet around\n\
the local s-axis at the exit, then take out displacement.",
          "DX DY DROTATE",
          {}},
         
         DROTATE$Message=
         {"DROTATE",
          "\
Additional rotation in x-y plane to simulate a rotation error.\n\
DROTATE does not afgfect the geometry of the ring.",
          "DX DY ROTATE",
          {}},
         
         DX$Message=
         {"DX",
          "\
Horizontal displacement of magnet.   This applied before the rotation by \n\
ROTATE.",
          "DY ROTATE DROTATE",
          {}},

         DY$Message=
         {"DY",
          "\
Vertical displacement of magnet.   This applied before the rotation by \n\
ROTATE.",
          "DX ROTATE DROTATE",
          {}},

         ANGLE$Message={"ANGLE",
          "\
The bending angle.   If positive, it bends the orbit in x-s plane toward \n\
negative-x-direction.   ANGLE determines the geometry of the beam line,\n\
while K0 represents a dipole kick on top of the bending angle given by\n\
ANGLE, i.e., the total deflection of the beam is given of ANGLE + K0.",
          "K0",
          {}},

         E1$Message={"E1",
          "\
The ratio of the face-angle at the entrance to the bending angle.\n\
The effective face angle is E1 * ANGLE + AE1, and a positive \n\
angle at the entrance corresponds to a surface with dx/ds > 0.\n\
For example, a symmetrically-placed rectangular magnet has\n\
 E1 = 0.5 and E2 = 0.5.",
          "AE1 E2 ANGLE",
          {}},

         E2$Message={"E2",
          "\
The ratio of the face-angle at the exit to the bending angle.\n\
The effective face angle is E2 * ANGLE + AE2, and a positive \n\
angle at the exit corresponds to a surface with dx/ds < 0.\n\
For example, a symmetrically-placed rectangular magnet has\n\
E1 = 0.5 and E2 = 0.5.",
          "AE2 E1 ANGLE",
          {}},

         AE1$Message={"AE1",
          "\
The absolute face angle at the entrance.\n\
The effective face angle is E1 * ANGLE + AE1, and a positive \n\
angle at the entrance corresponds to a surface with dx/ds > 0.",
          "E1 AE2 ANGLE",
          {}},

         AE2$Message={"AE2",
          "\
The absolute face-angle at the exit to the bending angle.\n\
The effective face angle is E2 * ANGLE + AE2, and a positive \n\
angle at the exit corresponds to a surface with dx/ds < 0.",
          "E2 AE1 ANGLE",
          {}},

         Kn$Message[n_]:=
         {"K"//n,
          "\
The normal "//2*(n+1)//"-pole magnetic field component (times the length L).\n\n\
   K"//n//" = B^("//n//")L/(Brho),\n\n\
where L is the length of the component.   Positive sign means horizontal \n\
focusing.",
          "L",
          {}};Kn$Message[0],

         Kn$Message[1],

         {"F1",
          "\
Length of the slope of the field at the edge as:\n\n\
                By(s) |   *******\n\
                      |  *\n\
                      | *\n\
                      |*\n\
                      *\n\
                     *|\n\
                    * |\n\
                   *  |\n\
        ----*******---+--------- s\n\
                  |       |\n\
                  |<----->|\n\
                  |   F1  |\n\n\
Only the effects up to y^4 in Hamiltonian are taken into account.\n\
More rigorous definition is\n\n\
   F1 = 6 Integrate[By(s)/B0 - (By(s)/B0)^2, {s, -Inf, Inf}] ,\n\n\
where integration is done over one fringe.\n\n"//
(BF1$Message="\
   The transformation of the linear fringe of the entrance of a bend is\n\n\
   exp(:V:),   V = -f^2/rhob px/p/24 - f/rhob^2 y^2/p/12 \n\
                   + 1/rhob^2/f y^4/p/6 ,\n\n\
where f is the length of fringe given by F1, and rhob bending radius\n\
at the design momentum. At the exit, the sign of rhob is changed.\n\
This linear fringe also changes the path length in the body of the bend as\n\n\
   l'=l-(phi0 f)^2/l/24 Sin[(phi0(1-E1-E2)-AE1-AE2)/2]/Sin[phi0/2]\n\n\
to maintain the geometric position of the design orbit, i.e., you have to\n\
increase the bend field a little bit to keep the orbit unchanged.   Unlike a\n\
quadrupole, the effect of linear fringe is always applied at both the\n\
entrance and the exit, otherwise you cannot obtain a circular design orbit.\n\n\
   Use FB1 and FB2 to specify the values of entrance and exit separately."),
          "FRINGE FB1 FB2",
          {}},

         {"FB1",
           "\
   F1 at the entrance. Actually F1 + FB1 is used at the entrance.",
          "F1 FB2",
          {}},

         {"FB2",
           "\
   F1 at the exit. Actually F1 + FB2 is used at the exit.",
          "F1 FB1",
          {}},

         {"FRINGE",
          "\
When FRINGE is non-zero, the effect of the linear fringe F1 is taken into\n\
account both at the entrance and the exit.\n"//BF1$Message,
          "F1",
          {}},

         DISFRIN$Message=
         {"DISFRIN",
          "\
If nonzero, the nonlinear Maxwellian fringe is suppressed.",
          "",
          {}},

         DISRAD$Message=
         {"DISRAD",
          "\
If nonzero, the synchrotron radiation in the particle-tracking is inhibited.",
          "flags RAD",
          {}},

         {"transformation",
          BEND$trans="\
The transformation of a bend depends on the value of K1.   If K1 is zero,\n\
it is a series of transformations:\n\n\
   (kick due to rotation error)\n\
      px2 = px1 + dphix\n\
      py2 = py1 + dphiy\n\
   (drift to the entrance face)\n\
      x2  = x1/(cos(psi1) - sin(psi1) (px1/pz1))\n\
      px2 = px1 cos(psi1) + pz1 sin(psi1)\n\
      y2  = y1 + (py1/pz1) x2 sin(psi1)\n\
      z2  = z1 - (p1 /pz1) x2 sin(psi1) ,\n\
      where psi1 = ANGLE * E1 + AE1;\n\
   (linear fringe at entrance face)\n\
      x2  = x1 + dxfr (p1 - p0)/p1\n\
      py2 = py1 + (dyfr - dyfra y1^2) y1/p1^2\n\
      z2  = z1 + (dxfr px1 + (dyfr - dyfra y1^2/2) y1^2/(2 p1))/p1\n\
      where dxfr = F1^2/(24 rhob) ,\n\
            dyfr = F1/(6 rhob^2) ,\n\
            dyfra= 2/3 1/(F1 rhob^2) ,\n\
            rhob = L'/(ANGLE + K0) ,\n\
            L'   = L - (ANGLE F1)^2 /(24 L)\n\
                     * sin((ANGLE (1 - E1 - E2) - AE1 - AE2)/2)/sin(ANGLE/2)\n\
   (nonlinear fringe at entrance)\n\
      x2  = x1  + y1^2 (1-y1^2/rhob^2/12) p1^2/(2 rhob (p1^2 - px1^2)^(3/2))\n\
      py2 = py1 - px1 (1-y1^2/rhob^2/6) y1/(p1 rhob sqrt(p1^2 - px1^2))\n\
      z2  = z1  - px1 y1^2 (1-y1^2/rhob^2/12) p1/(2 rhob (p1^2 - px1^2)^(3/2))\n\
   (body of bend)\n\
      px2 = -rho0/rhob (sin(psi2) + sin(omega + psi1))\n\
            + sin(omega) pz1 + cos(omega) px1 - x1/rhob sin(omega)\n\
      x2  = x1 cos(omega) + rhob (pz2 - cos(omega) pz1 + sin(omega) px1)\n\
            + rho0 (cos(omega+psi1) - cos(psi2))\n\
      y2  = y1 + py1/sqrt(p1^2 - py1^2) s\n\
      z2  = z1 - s p1/sqrt(p1^2 - py1^2) + v1/v0 L'\n\
      where rho0  = L'/ANGLE\n\
            omega = ANGLE - psi1 - psi2\n\
            s     = rhob ANGLE (arcsin(px1/sqrt(p1^2 - py1^2))\n\
                    - arcsin(px2/sqrt(p2^2 - py2^2)) + omega)\n\
   (nonlinear fringe at exit)\n\
      x2  = x1  - y1^2 (1-y1^2/rhob^2/12) p1^2/(2 rhob (p1^2 - px1^2)^(3/2))\n\
      py2 = py1 + px1 y1 (1-y1^2/rhob^2/6)/(p1 rhob sqrt(p1^2 - px1^2))\n\
      z2  = z1  + px1 y1^2 (1-y1^2/rhob^2/12) p1/(2 rhob (p1^2 - px1^2)^(3/2))\n\
   (linear fringe at exit face)\n\
      x2  = x1 - dxfr (p1 - p0)/p1\n\
      py2 = py1 + (dyfr - dyfra y1^2) y1/p1^2\n\
      z2  = z1 + (-dxfr px1 + (dyfr - dyfra y1^2/2) y1^2/(2 p1))/p1 - dzfr\n\
      where dzfr = dxfr * ( sin(ANGLE E1 + AE1) + sin(ANGLE E2 + AE2) )\n\
   (drift from the exit face)\n\
      px2 =  cos(psi2) px1 + sin(psi2) pz1\n\
      x2  = x1 (cos(psi2) + px2/pz2 sin(psi2))\n\
      y2  = y1 + py2/pz2 x1 sin(psi2)\n\
      z2  = z1 - x1 sin(psi2) p2/pz2\n\
      where psi2 = ANGLE * E2;\n\
   (kick due to rotation error)\n\
      px2 = px1 + dphix\n\
      py2 = py1 + dphiy .\n\n\
If K1 is nonzero, the effects from E1 and E2 are approximated by thin\n\
quadrupoles.   Then the body is subdivided into\n\n\
   1 + floor(sqrt(abs(K1 L')/(12 10^-5 EPS)))\n\n\
pieces (EPS = 1 is used when EPS = 0), and the bend-body transformation\n\
above is done for each piece and the kick from K1 is applied alternatively.\n\
In FFS optics and Emittance calculations, or when the synchrotron radiation\n\
is turned on, the same algorithm as K1 <> 0 is applied.",
          "transformation: coordinates",
          {}}
          }]
         },

       {"QUAD",
        "A quadrupole magnet.",
        "",
        Sort[
        {L$Message=
         {"L",
          "Effective length.",
          "",
          {}},

         ROTATE$Message,

         DX$Message,

         DY$Message,

         Kn$Message[1],

         {"F1",
          F1F2$Message=
          "\
F1 and F2 are parameters to characterize the slope of the field at the edges\n\
defined as:\n\n\
     F1 = SIGN(Sqrt[a],a),    a = 24(I_0^2/2 - I_1),\n\
     F2 = I_2 - I_0^3/3\n\
with\n\
     I_n = Integrate[(s-s0)^n K1[s]/K1_0,{s,-Infinity,Infinity}],\n\n\
where s0 is the location of the edge where the effective length is defined,\n\
and K1_0 is the nominal value of K1, given by the keyword K1.\n\
   The effects only in the first order of K1 is taken into account.",
          "F2 FRINGE",
          {}},

         {"F2",
          F1F2$Message,
          "F1 FRINGE",
          {}},

         FRINGEQ$Message={"FRINGE",
          "\
The effects of the linear fringe (characterized by F1 and F2), and the\n\
nonlinear Mexwellian fringe are controled as:\n\n\
                   DISFRIN=0                   DISFRIN<>0\n\
             Nonlinear      Linear       Nonlinear     Linear\n\
FRINGE=0    entr & exit      none          none         none\n\
FRINGE=1       entr          entr          none         entr\n\
FRINGE=2       exit          exit          none         exit\n\
FRINGE=3    entr & exit   entr & exit      none      entr & exit\n\n",
          "F1 F2 DISFRIN",
          {}},

         DISFRINQ$Message={"DISFRIN",
          "\
If nonzero, the nonlinear maxwellian fringe is suppressed.  The\n\
effects of DISFRIN and FRINGE are summarized as\n\n\
                   DISFRIN=0                   DISFRIN<>0\n\
             Nonlinear      Linear       Nonlinear     Linear\n\
FRINGE=0    entr & exit      none          none         none\n\
FRINGE=1       entr          entr          none         entr\n\
FRINGE=2       exit          exit          none         exit\n\
FRINGE=3    entr & exit   entr & exit      none      entr & exit\n\n",
          "FRINGE",
          {}},

         DISRAD$Message,

         {"transformation",
          QUAD$trans="\
The transformation in a QUAD is a sequence of:\n\n\
   (nonlinear fringe at entrance)\n\
      canonical transformation by a generating function\n\n\
      G(x1, px2, y1, py2, p1) = H0(x1, px2, y1, py2, p1)\n\
                + (D[H0, x1] D[H0, px2] + D[H0, y1] D[H0, py2])/2\n\n\
      where H0  =  px2 dx1 + py2 dy1\n\
            dx1 =  x1 (a/3 + b)\n\
            dy1 = -y1 (a + b/3)\n\
            a   =  K1 x1^2/p1/4\n\
            b   =  K1 y1^2/p1/4 .\n\
   (linear fringe at entrance)\n\
      px2 = exp(-a) px1\n\
      py2 = exp(a)  py1\n\
      x2  = exp(a)  x1 + b px1\n\
      y2  = exp(-a) y1 - b py1\n\
      z2  = z1 - (a x1 + b (1 + a/2) px2) px1\n\
               + (a y1 + b (1 - a/2) py2) py1\n\
      where a = -K1 F1 abs(F1)/(24 p1 L)\n\
            b =  K1 F2/L .\n\
   (body of quad)\n\
      The body is subdivided in n = 1 + floor(10 abs(K1 L)/EPS) (EPS = 1\n\
      is used when EPS = 0), then a transversely linear transformation\n\
      exp(:H:) is done in each slice with\n\n\
         H = ((-p + (px^2 + py^2)/(2 p) + E/v0) L + K1 (x^2 - y^2)/2)/n .\n\n\
      Between slices applied is the correction exp(:dH:) for the kinematical\n\
      term with\n\n\
         dH = (-sqrt(p^2 - px^2 -py^2) + p - (px^2 + py^2)/(2 p)) L/n .\n\n\
      In a solenoid, the forms of H and dH are modified.\n\
   (linear fringe at exit)\n\
      px2 = exp( a)  px1\n\
      py2 = exp(-a) py1\n\
      x2  = exp(-a) x1 + b px1\n\
      y2  = exp( a) y1 - b py1\n\
      z2  = z1 + (a x1 - b (1 - a/2) px2) px1\n\
               - (a y1 - b (1 + a/2) py2) py1\n\
      where a = -K1 F1 abs(F1)/(24 p1 L)\n\
            b =  K1 F2/L .\n\
   (nonlinear fringe at exit)\n\
      canonical transformation by a generating function\n\n\
      G(x1, px2, y1, py2, p1) = H0(x1, px2, y1, py2, p1)\n\
                + (D[H0, x1] D[H0, px2] + D[H0, y1] D[H0, py2])/2\n\n\
      where H0  =  px2 dx1 + py2 dy1\n\
            dx1 =  x1 (a/3 + b)\n\
            dy1 = -y1 (a + b/3)\n\
            a   = -K1 x1^2/p1/4\n\
            b   = -K1 y1^2/p1/4 .",
        "transformation: coordinates",
        {}}
         }]
        },

          SEXT$trans[name_,pole_,n_]:="\
The transformation in a "//name//" is given as\n\n\
   exp(:Fin:)exp(:a L:)exp(:H"//n//"/2:)exp(:b L:)\n\
         *exp(:V"//n//":)exp(:a L:)exp(:H"//n//"/2:)exp(:b L:)exp(:Fout:) ,\n\n\
where L and H"//n//" are Hamiltonians of a drift of length L and a thin \n"//
pole//"pole kick of integrated strength K"//n//":\n\n\
   H"//n//
" = K"//n//"/"//n+1//"! Re((x - I y)^"//n+1//") ,\n\n\
respectively.   The coeffients are a = 1/2 - 1/sqrt(12) and\n\
b = 1/2 - a.   Terms exp(:Fin:) and exp(:Fout:) are transformations for\n\
entrance and exit nonlinear fringes.   The term exp(:V"//n//":) is a\n\
correction to adjust the third-order terms in L:\n\n\
   V"//n//" = (SUM over j=(x,y), k=(x,y)) [\n\
              - beta/2 (H"//n//",k)^2 \n\
              + gamma (H"//n//",j H"//n//",k H"//n//",j,k)] ,\n\n\
where ,i represents the derivative by x or y.   We have also introduced two\n\
coefficients beta = 1/6 - 1/sqrt(48) and gamma = 1/40 - 1/24/sqrt(3).";
       SEXT$Message[name_,pole_,n_]:=
       {name,
        "A "//pole//"pole magnet.",
        "",
        Sort[
        {L$Message,

         ROTATE$Message,

         DX$Message,

         DY$Message,

         Kn$Message[n],

         DISFRIN$Message,

         DISRAD$Message,

         {"transformation",
        SEXT$trans[name,pole,n],
        "",
        {}}
         }]
        };SEXT$Message["SEXT","sextu",2],

       SEXT$Message["OCT","octa",3],

       SEXT$Message["DECA","deca",4],

       SEXT$Message["DODECA","dodeca",5],

       {"SOL",
        "\
A solenoid.   Unlike other elements, SOL elements inserted at boundaries or\n\
of a solenoid or at where the field changes.   Between SOL elements DRIFT,\n\
BEND(straight bend only), QUAD, and MULT elements can be inserted.  The\n\
longitudinal field of the solenoid overlaps on those elements.\n\
   In a SOL region, the coordinate is shifted on the axis of the solenoid,\n\
no matter how the design orbit bends there.   The x-direction of the\n\
coordinate in a solenoid is so chosen as to CHI3 = 0.   At the exit of a\n\
solenoid, the coordinate is shifted back to the design orbit, but the value\n\
of CHI3 is so determined as to set CHI3 zero at the nearest MARK element\n\
which has GEO = 1 after the exit.   The offset and orientation of the design\n\
orbit can be given by keywords DX, DY, DPX, DPY at a SOL element with \n\
GEO = 1.\n\
SOL can be used to shift the coordinate to the actual orbit even without BZ.\n\
It is useful to define the coordinate with magnets with DX and DY.",
        "geometric-functions MARK",
        Sort[
        {{"BOUND",
          "\
BOUND = 1 must be given at both sides of the boundaries of a solenoid,\n\
otherwise SOL only specifies the change of BZ",
          "",
          {}},

         {"BZ",
          "\
The longitudinal field of a solenoid.   If a SOL is used with BOUND = 0\n\
(default),   only BZ is used to change the field, and no coordinate\n\
transformation is applied.",
          "",
          {}},

         {"GEO",
          "\
One of boundaries (with GEO = 1) of a solenoid must have GEO = 1 to specify\n\
the alignment of the design orbit.   At a SOL element with GEO = 1, the\n\
design orbit is determined by DX, DY, DPX, DPY parameters",
          "DX DY DPX DPY",
          {}},

         {"DX",
          "\
An x-offset of the design ORBIT relative to the solenoid center at SOL\n\
with GEO = 1.",
          "GEO DY DPX DPY",
          {}},

         {"DY",
          "\
A y-offset of the design ORBIT relative to the solenoid center at SOL\n\
with GEO = 1.",
          "GEO DX DPX DPY",
          {}},

         {"DPX",
          "\
An offset of the design ORBIT angle CHI1 relative to the solenoid axis at\n\
SOL with GEO = 1.",
          "GEO DX DY DPY geometric-functions: CHI1",
          {}},

         {"DPY",
          "\
An offset of the design ORBIT angle CHI2 relative to the solenoid axis at\n\
SOL with GEO = 1.",
          "GEO DX DY DPX geometric functions: CHI2",
          {}},

         {"F1",
           "\
The length of fringe of the solenoide field. It affects only the EMITTANCE\n\
calculation. If F1 = 0 (default), no radiation arises at the fringe.",
           "",
           {}},

         {"DISFRIN",
          "\
Disables the nonlinear fringe of solenoid if nonzero. The default is 0. The\n\
transformation for the nonlinear fringe is expressed by\n\n\
   exp(:H:) ,\n\
   H = -Bz/(8 Brho p^2) p_phi p_r, \n\n\
where\n\n\
   p_phi = x py - y px ,\n\
   p_r   = x px + y py ,\n\n\
whose canonical partners are\n\n\
   phi = ArcTan[y/x] ,\n\
   r   = Log[x^2 + y^2]/2 ,\n\n\
respectively.",
          "",
          {}}}]
       },

       {"COORD",
        "\
An element for an arbitrary coordinate transformation.   This element can be\n\
used to express an off-axis element.\n\n\
Usage: COORD name=(DX=dx DY=dy CHI1=chi1 CHI2=chi2 CHI3=chi3 DIR=dir); .\n\n\
If dir is zero (default), the transformation of the coordinate by COORD is\n\n\
  {x1      {c3 -s3 0     {1  0  0      {c1 0  s1   {x-dx\n\
   y1   =   s3  c3 0      0  c2 s2      0  1  0     y-dy\n\
   z1}      0   0  1}.    0 -s2 c2}.   -s1 0  c1}.  z   } ,\n\ 
and if dir is nonzero,\n\n\
  {x1      { dx    {c3 -s3 0     {1  0   0      {c1 0  s1   {x\n\
   y1   =   -dy  +  s3  c3 0      0  c2 -s2      0  1  0     y\n\
   z1}       0 }    0   0  1}.    0  s2  c2}.   -s1 0  c1}.  z} ,\n\n\ 
where {x1, y1, z1} is the new coordinate and\n\n\
  c1=cos(chi1), s1=sin(chi1), etc.\n\n\
Note that these are NOT the inverse to each other.\n\n\
   To use this element, you have to calculate the values of those parameters\n\
carefully.   DISP G may help you but there is no automatic way to get them.\n\
You may also have to be careful when you use a line with this element in the\n\
reverse direction.\n\n\
   A better way to do an equivalent thing in most cases is to use SOL.\n\
Unlike COORD, SOL automatically determines the parameters for the coordinate\n\
transformation.",
        "SOL DISPLAY(DISP)",
        {}},

       {"CAVI",
        "Accelerating structure.",
        "",
        Sort[
        {L$Message,

         ROTATE$Message,

         DX$Message,

         DY$Message,

         DISFRINCAV$Message={"DISFRIN",
          "\
If nonzero, the Maxwellian fringe is suppressed.  The\n\
effects of DISFRIN and FRINGE are summarized as\n\n\
             DISFRIN=0          DISFRIN<>0\n\
FRINGE=0    entr & exit            none\n\
FRINGE=1       entr                none\n\
FRINGE=2       exit                none\n\
FRINGE=3    entr & exit            none",
          "FRINGE",
          {}},

         {"VOLT",
          "Accelerating peak voltage in Volt.\n"//
          (Acc$Message="The acceleration is given by \n\n\
     dE = - e*(VOLT+V1 x+V20 x^2/2+V11 x y+V02 y^2/2)\n\
                *Sin[2 Pi FREQ (t-ts) + PHI +DPHI],\n\n\
where ts is the equilibrium time determined by the valance between\n\
the acceleration and the radiation loss around the ring.\n\
(CAVI only) The non-relativistic corrections\n\n\
     VOLT*(2 Pi FREQ/c)^2/(gamma beta)^2/4 are\n\n\
automatically added to V20 and V02, respectively. The Lorentz factor\n\
is evaluated as inverse of average of 1/(beta gamma) at the entrance\n\
and the exit.\n\
   CAVI includes the edge effect at the lowest order, given by a Hamiltonian\n\
at the entrance edge at s0:\n\n\
   Hf = - (e VOLT/L)(Sin(omega t - dphi) + Sin(dphi) - offset) (x^2+y^2)/4 delta(s-s0)\n\n\
where dphi and offset are determined by the cavity phase and the radiation loss,\n\
which is nonzero only in the case of NORAD. The sign flips at the exit.\n\
This Hamiltonian should be consistent with what Kiyoshi Kubo derived."),
          "",
          {}},

         FREQ$Message={"FREQ",
          "\
Rf frequency.   If this keyword is nonzero, the keyword HARM is ignored.\n"//
          Acc$Message,
          "HARM",
          {}},

         HARM$Message={"HARM",
          "\
A harmonic number.   This is valid only when FREQ is zero.",
          "FREQ",
          {}},

         {"V1",
          "\
The linear x-dependence of the acceleration. Tracking only.\n"//Acc$Message,
          "VOLT V20 V11 V02",
          {}},

         {"V20",
          "\
The x^2-dependence of the acceleration. Tracking only.\n"//Acc$Message,
          "VOLT V1 V11 V02",
          {}},

         {"V11",
          "\
The xy-dependence of the acceleration. Tracking only.\n"//Acc$Message,
          "VOLT V1 V20 V02",
          {}},

         {"V02",
          "\
The y^2-dependence of the acceleration. Tracking only.\n"//Acc$Message,
          "VOLT V1 V20 V11",
          {}},

         {"PHI",
          "\
Relative phase offset.   The stable synchrotron phase above the\n\
transition is near PHI = 0.   \n\
The acceleration is given as \n\n\
     dE = - e*(VOLT+V1 x+V20 x^2/2+V11 x y+V02 y^2/2)\n\
                *Sin[2 Pi FREQ (t-ts) + PHI + DPHI],\n\n\
where ts is the equilibrium time determined by the valance between\n\
the acceleration and the radiation loss around the ring.",
          "FREQ VOLT V1 V20 V11",
          {}},

         {"DPHI",
          "\
Relative phase offset.   The stable synchrotron phase above the\n\
transition is near PHI = 0.   \n\
The acceleration is given as \n\n\
     dE = - e*(VOLT+V1 x+V20 x^2/2+V11 x y+V02 y^2/2)\n\
                *Sin[2 Pi FREQ (t-ts) + PHI + DPHI],\n\n\
where ts is the equilibrium time determined by the valance between\n\
the acceleration and the radiation loss around the ring.\n\
DPHI is not taken into account to determine the design mementum p0(s).",
          "FREQ VOLT V1 V20 V11",
          {}}

          }]},

       {"MULT",
        "\
A magnet with multipoles.  Note that the reference plane is\n\
defined so that the skew quadrupole component becomes zero.\n\
   It can have a nonzero ANGLE to express a combined function\n\
bending magnet with multipoles. Note that the definition of\n\
the multipoles with nonzero ANGLE is very special\n\
The current version does not allow nonzero ANGLE inside a solenoid\n\
or with acceleration. Also the fringe field and emittance\n\
calculation are not installed properly for nonzero ANGLE.",
        "multipole_with_nonzero_ANGLE",
        Sort[
        {L$Message,

          ANGLE$Message,

          E1$Message,

          E2$Message,

          AE1$Message,

          AE2$Message,

         {"misalignments",
          "\
Misalignments of a MULT element are expressed by the keywords DX, DY, DZ,\n\
CHI1, CHI2, and ROTATE(=CHI3).  They specify all misalignments of a rigid\n\
body,  At the entrance of MULT, the coordinates of a particle are\n\
transformed as\n\n\
   { x  }    {  c3 -s3  0  } {  1   0   0  } {  c1  0  -s1 } { x - DX }\n\
   { y  }  = {  s3  c3  0  } {  0   c2 -s2 } {  0   1   0  } { y - DY }\n\
   { ds }1   {  0   0   1  }.{  0   s2  c2 }.{  s1  0   c1 }.{   - DZ } ,\n\n\
where c1 and s1 are Cos[CHI1] and Sin[CHI1], etc.   The inverse is applied\n\
at the exit.\n\
   Those misalignments are also valid within a solenoid.\n\
   Other straight elements such as QUAD or THIN do not and will not have\n\
these full misalignment specifications, because they can be substituted by\n\
MULT.\n\
   The geometry of the design orbit is determined by the saved values of\n\
CHI1, CHI2, and DZ, while the current values are used for DX, DY, and ROTATE.",
          "",
          {}},

         {"multipole_with_nonzero_ANGLE",
          StringJoin["\
The multipoles in MULT with nonzero ANGLE are defined as\n\n\
   H = ... + As(x, y) ,\n\n",
"   As(x, y) = Sum[ g_kn (Kn + I SKn)/(n + 1)! (rho + x)^(1/2 - k)\n\
                  * (x + I y)^(n + k) / rho^(1/2),\n\
                  {k, 0, Infinity}, {n, 0, nmax}]\n\n\
with\n\n",
"   g_kn = - (2k - 1)!! (2k - 3)!! (n + 1)! / (8^k (n + k + 1)! k!) ,\n\n\
where rho = L/ANGLE . Actually the summation is truncated at n + k <= 21\n\
in the current version.   While this definition converges to the regular\n\
one for multipoles when ANGLE -> 0, K0 and K1 of MUILT are\n\
different from those of BEND."],
         "ANGLE",
         {}},

         Apply[Sequence,Table[Kn$Message[i],{i,0,21}]],

         SKn$Message[n_]:=
         {"SK"//n,
          "\
The skew "//2*(n+1)//"-pole magnetic field component (times the length L).\n\n\
   SK"//n//" = B^("//n//")L/(Brho),\n\n\
where L is the length of the component.   Positive sign means a horizontally\n\
focusing magnet rotated around z-axis by -90/(n+1) degree, i.e.,\n\
ROTATE = (90/(n+1)) DEG .",
          "L",
          {}};
         Apply[Sequence,Table[SKn$Message[i],{i,0,21}]],

         {"RADIUS",
          "Radius of the vacuum chamber. Effective when SPAC is ON.",
          "flags SPAC",
          {}},

         {"F1",
          F1F2$Message,
          "F2 FRINGE",
          {}},

         {"F2",
          F1F2$Message,
          "F1 FRINGE",
          {}},

         {"FB1",
          "Linear Fringe length F1 for the K0 component at the entrance.",
          "BEND F1 FB1",
          {}},

         {"FB2",
          "Linear Fringe length F1 for the K0 component at the exit.",
          "BEND F1 FB2",
          {}},

         {"VOLT",
          "Accelerating peak voltage in Volt.\n"//
          (Acc$Message="The acceleration is given by \n\n\
     dE = - e * VOLT * Sin[2 Pi FREQ (t-ts) + PHI + DPHI],\n\n\
where ts is the equilibrium time determined by the valance between\n\
the acceleration and the radiation loss around the ring."),
          "",
          {}},

          FREQ$Message,

          HARM$Message,

         {"PHI",
          "\
Relative phase offset.   The stable synchrotron phase above the\n\
transition is near PHI = 0.   \n\
The acceleration is given as \n\n\
     dE = - e * VOLT * Sin[2 Pi FREQ (t-ts) + PHI],\n\n\
where ts is the equilibrium time determined by the valance between\n\
the acceleration and the radiation loss around the ring.",
           "",
           {}},
           
         {"DPHI",
          "\
Relative phase offset.   The stable synchrotron phase above the\n\
transition is near PHI = 0.   \n\
The acceleration is given as \n\n\
     dE = - e*(VOLT+V1 x+V20 x^2/2+V11 x y+V02 y^2/2)\n\
                *Sin[2 Pi FREQ (t-ts) + PHI + DPHI],\n\n\
where ts is the equilibrium time determined by the valance between\n\
the acceleration and the radiation loss around the ring.\n\
DPHI is not taken into account to determine the design mementum p0(s).",
          "FREQ VOLT V1 V20 V11",
          {}},

         FRINGEQ$Message,

         DISFRINQ$Message,

         DISRAD$Message}]
         },

       {"MARK",
        "\
MARK elements play special rolls in FFS:\n\n\
(1) The first element of the beam line must be a MARK element to be used by\n\
    FFS.   In this case the MARK element contains the parameters of the \n\
    incoming beam (see optical-functions, special-variables EMITX, EMITY,\n\
    DP).\n\
(2) The calculated optical parameters at a MARK command is saved by \n\
    SAVE or STOP commands, then it can be used as the incoming condition\n\
    of other beam lines which have the same MARK element.\n\n\
Example: MARK P1 = (EMITX = .. EMITY = .. DP = ..);\n\
         LINE  A = ( .. P1 ..)\n\
               B = (P1 .. );\n\
         FFS USE = A;\n\
             ...           do matching on LINE A\n\
             SAVE P1       save the parameters at P1\n\
             USE B;        switch to LINE B\n\
             ...           do matching of LINE B whose entrance is to be\n\
                           matched P1.\n\n\
(3) If a MARK element has keyword GEO nonzero, this MARK element becomes the\n\
    origin of the geometric rotation after the last SOL element.\n\
(4) The values of optical-functions of the MARK element at the beginning of \n\
    the beam line can be specified as matching variables by the FREE command.\n\n\
   A MARK elements have all optical-functions as its keywords except NX, NY,\n\
TRX, TRY, and LENG.   Also it has keywords EMITX, EMITY, and DP which give \n\
the values of the corresponding special-variables.",
       "SAVE USE optical-functions SOL special-variables EMITX EMITY DP",
       {{"OFFSET",
         "\
OFFSET is a relative position from the current position.  A fraction is\n\
allowed to specify a location within an element.\n\
   If the MARK at the beginning of a beam line has OFFSET nonzero, the optics\n\
calculation starts from the shifted location.   If the last component of a\n\
beam line is a MARK with nonzero OFFSET, the optics calculation stops at the\n\
shifted location.   The periodic condition is applied between those shifted\n\
locations.\n\
   The geometric origin and the origin of LENG shift to the first MARK.\n\n\
Examples:\n\
(1)  LINE A    = ( ...  QF PQFC  ... );\n\
     QUAD QF   = (L=0.3 K1=0.2);\n\
     MARK PQFC = (OFFSET = -0.5);\n\n\
Here PQFC represents the center of QF.\n\n\
(2)  LINE A    = ( ...  PQFC QF  ... );\n\n\
     QUAD QF   = (L=0.3 K1=0.2);\n\
     MARK PQFC = (OFFSET =  1.5);\n\
Here PQFC represents the center of QF, too (consider why).   The value\n\
of OFFSET is interpreted taking the direction of the LINE into account,\n\
i.e., a MARK in a line A represents the same location in a line -A.\n\n\
Restrictions:\n\
(1) Function TrackParticles does not take OFFSET into account if the start\n\
    or stop location is in the midst of a beam line and a Mark with nonzero\n\
    OFFSET, in the current version.  Tracking for entire beam line or\n\
    MEASURE(MEA) command supports OFFSET.\n\
(2) The outputs by DISPLAY(DISP) outside of the narrowed region by OFFSET are\n\
    meaningless.",
        "",
        {}}}}
       }]},

   {"MATRIX(MAT)",
    "Usage: MATRIX [{SYMPLECTIC(S) | PHYSICAL(P)}] [from to]\n\n\
prints out the 4 by 5 transfer matrix from from-component to to-component.\n\
If SYMPLECTIC(S) is specified (default), the symplectic transfer matrix on \n\
{x,px/p0,y,py/p0,dp/p0} where p0 is the nominal momentum at the entrance,\n\
is given. Otherwise, in the case of TRPT, the transfer matrix on\n\
{x,px/p0(s),y,py/p0(s),dp/p0(s)} is printed out.\n\
   If the from- and to- components are omitted, entire beam line is assumed.\n\
If to-component is upstream the from-component, it gives the inverse matrix\n\
(TRPT) or one-turn-wrapped matrix (RING).",
    "DISPLAY(D) flags TRPT RING",
    {}},

   {"CHROMATICITY(CHRO)",
    "CHRO prints out the chromaticity of QUAD and SEXT in the entire beam \n\
line using the simplest formula:\n\n\
     xi_{x,y}=Integrate[-(K1/L) beta_{x,y}(s) ds] for QUAD,\n\
     xi_{x,y}=Integrate[-(K2/L) eta_x (s) beta_{x,y}(s) ds] for SEXT.\n\n\
These formula are not valid when there is x-y coupling or vertical \n\
dispersion.",
    "",
    {}},

   {"RADINT",
    "RADINT prints out the radiation integrals involving the x-coupling\n\
for all components of the beam line.",
    "",
    {}},

   {"SEED",
    "SEED command is removed. Use SeedRandom[] function instead of SEED command.",
    "MEASURE(MEA) machine-errors flags FIXSEED MOVESEED SeedRandom",
    {}},

   {"VARY",
    "Usage: VARY keyword element-pattern\n\n\
changes the default-keyword of the elements which match element-pattern to \n\
keyword.",
    "FREE elements wildcards",
    {}},

   {"REJECT(REJ)",
    "\
Usage: (1) REJ matching-function-pattern [matching-function-pattern1..]\n\
       (2) REJ TOTAL\n\
       (3) REJ TOTALFIT\n\n\
rejects the matching-functions which match matching-function-pattern at the \n\
current FIT location. If TOTAL or TOTALFIT is given, the entire matching conditions in\n\
all locations are rejected, then output parameters by CALCULATE are reset when TOTAL\n\
is given.",
    "matching-function-commands FIT wildcards",
    {}},

   {"COUPLE(COUP)",
    "Usage: COUP slave-element master-element coefficient\n\n\
sets the value of the default-keyword of slave-element to be equal to \n\
coefficient times the value of the default-keyword of master-element.\n\
COUPLE(COUP) cannot be cascaded.   The master-element cannot be COUPLEd to \n\
any other element.   To reset COUPLE, say COUP slave-element slave-element 1.",
    "ATTRIBUTE(ATTR) FREE",
    {}},

   {"SHOW",
    "\
SHOW prints out the current matching conditions.\n\n\
   FFS[\"SHOW\"] returns the current matching conditions as a list.\n\
Each element has a form of\n\n\
{component1, component2, function, goal-value, number-of-momentums, scale},\n\n\
which corresponds to the new format of the print-out by SHOW.",
    "matching-function-commands FIT functions FFS",
    {}},

   {"STATUS(STAT)",
    "STAT shows the current settings of flags, fit points, \n\
special-variables, the region for DISPLAY, seed of the random number \n\
generator, and elapsed CPU time, etc.",
    "flags special-variables",
    {}},

   {"REVERSE(REV)",
    "REV changes the sign of AX, AY, EPX, EPY, R2, R3, DPX, DPY at the\n\
entrance of the beam line.",
    "matching-function-commands",
    {}},

   {"DRAW",
    "\
Usage: DRAW [begin end] fun1 [fun2..] [& fun11 [fun12..]] [element-pattern]\n\n\
prints out the TopDrawer commands of the plots of functions fun1...\n\
Available functions are all matching-functions (except LENG, TRX, TRY, GX,\n\
GY, GZ, CHI1, CHI2, CHI3) and additional functions.   If functions are\n\
separated by ampersand (&), these are plotted in a separated window.\n\
   If begin- and end-components are specified, the plot region is limited\n\
between them.   If the end-component comes earlier than the \n\
begin-components, it wraps the plot around the beam line.\n\
   If the optional element-pattern is given, it draws the beam-line lattice \n\
with the labels for elements which match element-pattern.   If LAT is\n\
specified for element-pattern, the lattice is drawn without label.",
    "special-variables TITLE CASES matching-functions OUTPUT(OUT) TERMINATE(TERM) GEO DISPLAY(DISP) wildcards",
    {}},
    
   {"GEO",
    "\
prints out the TopDrawer commands for the geometric plot of the beam line.",
    "DISPLAY(DISP)",
    {}},

   {"TDR",
    "Usage:   TDR {filename | file_number}\n\n\
runs TopDrawer (tdr) using the file specified by filename or file_number as\n\
the input.   It supports both Tek terminal and X-window.\n\n\
Example:   OUT 'a' DRAW bx by & ex ey q* CLOSE OUT TDR 'a'\n\n\
TDR does not work when SAD is running under EMACS without X-window.",
    "DRAW GEO OUTPUT(OUT) CLOSE(CLO)",
    {}},

   {"PRINT(PRI)",
    "PRI expression  evaluates expression and prints out the result.",
    "expressions functions Print",
    {}},

   {"IF",
    IF$Message=
    "\
Usage: IF expr1 body1 [ELSEIF expr2 body2 [ELSEIF ..]] [ELSE body3] ENDIF\n\n\
This is a FORTRAN77 like IF-structure.   If the expression expr1 is \n\
True(==1) or nonzero, executes commands in body1. If it is False(==0), skip\n\
commands until ELSE, ELSEIF or ENDIF appears at the same level of the\n\
IF-structure, and executes commands after ELSE or ENDIF, or executes the\n\
ELSEIF command. If expr1 is not a real number, an error message is printed\n\
and ignores the command line.",
    "ELSE ELSEIF ENDIF expressions command-systax functions If",
    {}},

   {"ELSE",
    IF$Message,
    "If ELSEIF ENDIF",
    {}},

   {"ELSEIF",
    IF$Message,
    "IF ELSE ENDIF",
    {}},

   {"ENDIF",
    IF$Message,
    "IF ELSE ELSEIF",
    {}},

   {"REPEAT(REP)",
    REPEAT$Message=
    "\
Usage: REP [n] body UNTIL [expr1]\n\n\
executes commands in body n times until expr1 gives nonzero.   The number n\n\
can be any expression which gives a number.   If n is omitted, infinity is\n\
assumed.   If expr1 is omitted, False(==0) is assumed.",
    "UNTIL",
    {}},

   {"UNTIL",
    REPEAT$Message,
    "REPEAT expressions command-syntax functions Do",
    {}},

   {"MEASURE(MEA)",
    "\
Usage: MEA [end-component] [OUT file plot-spaces]\n\n\
tracks particles from the entrance to end-component and prints out the\n\
statistics at the end.   If end-component is omitted, the component end\n\
used in the last MEASURE(MEA) (default: end of the beam line) is assumed.\n\
   If OUT file plot-spaces are attached, it plots phase space \n\
disribution on file.   The phase-spaces are specified like as X-PX, \n\
or X-Y, etc., (up to any numbers).\n\
   Parameters for the tracking are specified by special-variables and flags:\n\n\
seed for the random-number generator:\n\
     SeedRandom[seed_Real] or SeedRandom[{seeds__Real}]\n\n\
special-variables (can be set with =):\n\
     NP        number of particles \n\
     EMITX     horizontal emittance\n\
     EMITY     vertical emittance\n\
     DP        relative momentum spread\n\
     DP0       relative momentum offset dp/p0\n\
     GCUT      cut-off value of the Gaussian tail\n\
flags:\n\
     GAUSS/UNIFORM    Gaussian/uniform(default) momentum distribution\n\
     JITTER/NOJITTER  off(default)/on nullifying the incoming centroid offset\n\
     RFSW/NORFSW      switch on(default)/off the rf-cavities\n\
     RAD/NORAD        synchrotron radiation on/off\n\
     RADCOD/NORADCOD  off/on compensation of energy loss due to radiation\n\
     FIXSEED/MOVESEED keep(default)/unkeep the initial random-number seed\n\n\
   The initial transverse distribution is Gaussian.",
    "special-variables flags functions TrackParticles SeedRandom RESULTOFTRACKING",
    {}},

   {"matching-function-commands",
    "\
Usage: (1) matching-function  goal-value [off-momentum-points]\n\
       (2) matching-functionM goal-value [off-momentum-points]\n\
       (3) matching-functionI incoming-value\n\
       (4) matching-functionSCALE scale\n\n\
(1) sets the matching condition for matching-function at the current \n\
fitting point or region with the goal-value and the \n\
off-momentum-points (see off-momentum-matching).   \n\
   If off-momentum-points is omitted, the previous value for this \n\
matching-function at this fitting-point is assumed.   If the previous value\n\
is not defined, 1 is assumed.   If -1 is given for off-momentum-points,\n\
the matching-function is rejected from the matching (see REJECT(REJ)).\n\
   If \"*\" is given for goal-value, the previous value is used if exists.\n\n\
Example:   BX 10 3    (beta_x to be 10 at 3 momenta) \n\
           BX 20      (now beta_x to be 20 at 3 momenta (previous setting))\n\
           BX *  5    (now beta_x to be 20 (previous setting) at 5 momenta)\n\n\
(2) If the letter \"M\" is appended to matching-function, it means the \n\
maximum-fitting for the function.   The maximum of either the value (for\n\
positive-definite functions) or the absolute value (for bipolar functions)\n\
are to be limited in the matching.\n\n\
(3) If the letter \"I\" is appended to matching-function, it specifies \n\
the value of the incoming beam.\n\n\
(4) If SCALE is appended to matching-function, it sets the scale of\n\
the input/output of the function to scale.   This scale is used in the\n\
matching-function commands, DISPLAY(DISP), SHOW, etc.\n\n\
   Available matching-functions are:\n\
optical-functions (see optical-functions):\n\
AX BX NX AY BY NY EX EPX EY EPY R1 R2 R3 R4 DETR DX DPX DY DPY DZ DDP \n\
PEX PEPX PEY PEPY TRX TRY LENG\n\
geometrical-functions (see geometrical-functions):\n\
GX GY GZ CHI1 CHI2 CHI3",
    "FIT GO SHOW optical-functions geometric-functions off-momentum-matching\
 x-y-coupling REJECT(REJ) special-variables DP functions FitValue \
MatchingAmplitude",
    {}},

    {"off-momentum-matching",
     "\
FFS matches the optical functions for an orbit with finite momentum \n\
deviation.\n\n\
Example: \n\
   DP=0.01;      sets the range of momentum to DP0-0.01 < dp/p0 < DP0+0.01 .\n\
   BX 10 9;      sets the goal of betax to 10 m, at 9 points.\n\
                 in the range above, i.e.,\n\
                 dp/p0 = {-0.01,-0.0075,-0.005,-0.0025,0,\n\
                          0.0025,0.005,0.0075,0.01} + DP0 .\n\
   GO            starts the matching.\n\n\
As this example, the off-momentum points are chosen with equal separation.\n\
If the off-momentum point n is an even number, the chosen points are same as\n\
the case of n+1, but the on-momentum point (==DP0) is excluded.",
     "matching-function-commands special-variables:DP DP0",
     {}},

    {"optical-functions",
     "Available optical functions for matching are:\n\n\
AX      alpha_X\n\
BX      beta_X\n\
NX      psi_X, the default scale is 1/(2Pi)\n\
AY      alpha_Y\n\
BY      beta_Y\n\
NY      psi_Y, the default scale is 1/(2Pi)\n\
EX      eta_X   (dispersion_X)\n\
EPX     eta_Px  (dispersion_PX) \n\
EY      eta_Y   (dispersion_Y)\n\
EPY     eta_Py  (dispersion_PY)\n\
R1      R_1     (see x-y-coupling)\n\
R2      R_2     (see x-y-coupling)\n\
R3      R_3     (see x-y-coupling)\n\
R4      R_4     (see x-y-coupling)\n\
DETR    R_1*R_4 - R_2*R_3 (see x-y-coupling)\n\
DX      dx\n\
DPX     dpx\n\
DY      dy\n\
DPY     dpy\n\
DZ      dz\n\
DDP     delta=dp/p0\n\
AZ      alpha_Z\n\
BZ      beta_Z\n\
NZ      psi_Z, the default scale is 1/(2Pi)\n\
ZX      zeta_X  (z-dispersion_X)\n\
ZPX     zeta_Px (z-dispersion_PX) \n\
ZY      zeta_Y  (z-dispersion_Y)\n\
ZPY     zeta_Py (z-dispersion_PY)\n\
PEX     eta_x   (dispersion_x)\n\
PEPX    eta_px  (dispersion_px) \n\
PEY     eta_y   (dispersion_y)\n\
PEPY    eta_yy  (dispersion_py)\n\
TRX     trace(T_X), only defined at the end of the beam line.\n\
TRY     trace(T_Y), only defined at the end of the beam line.\n\
LENG    length of the design orbit\n\n\
In the above, upper case X, Px, Y, Py represents the x-y decoupled \n\
coordinate.   EX, EPX, EY, EPY refer the decoupled coordinate, while\n\
PEX, PEPX, PEY, PEPY are in the physical coordinate.   On the other hand, \n\
DX, DPX, DY, DPY refer the physical coordinate.",
    "geometrical-functions x-y-coupling matching-function-commands \
GO CALCULATE(CALC) DISPLAY(DISP) SHOW",
    {}},

   {"geometrical-functions",
    "Available geometrical-functions are:\n\n\
GX      geometrical coordinate xi\n\
GY      geometrical coordinate eta\n\
GZ      geometrical coordinate zeta\n\
CHI1    geometrical rotation angle ch1_1\n\
CHI2    geometrical rotation angle ch1_2\n\
CHI3    geometrical rotation angle ch1_3\n\n\
The geometrical coordinate {xi, eta, zeta} is set by the ORG command, and\n\
its default origin is at the entrance of the beam line, and the default\n\
directions are xi in s-direction, eta in -(x-direction), and zeta in\n\
-(y-direction) at the entrance. The set {xi, eta, zeta} forms a right-hand\n\
system.\n\
   The rotation angles are defined so as to give the local {x,y,s} is \n\
written\n\n\
    {x, y, s}_local\n\
   = rotate[s, chi3] rotate[x, chi2] rotate[y, -chi1]{x, y, s}_origin,\n\n\
where rotate[a, b] reads \"rotate around the  new-a vector by b \n\
right-handedly\".",
    "optical-functions matching-function-commands DISPLAY(DISP) flags:GEOCAL",
    {}},

   {"extended-Twiss-parameters",
    "\
A symplectic matrix such as the normal mode matrix can be expressed in terms\n\
of the extended Twiss parameters.   In 6 by 6 case, those are\n\n\
   AX  BX          ZX  EX\n\
     PSIX         ZPX EPX\n\
   R1  R2  AY  BY  ZY  EY\n\
   R3  R4    PSIY ZPY EPY\n\
                   AZ  BZ\n\
                     PSIZ .\n\n\
A(X,Y,Z), B(X,Y,Z) are alphas and betas in the usual sense, after a diagonalization\n\
to 2 by 2 submatrices.  PSI(X,Y,Z) are the rotation angle to set one\n\
the coordinate to parallel to the (X,Y,Z) axes.   R(1,2,3,4) are the\n\
components of the x-y coupling matrix (see x-y-coupling).   E(X,PX,Y,PY) are\n\
\"dispersions\" which decouples synchro-beta coupling terms together with\n\
Z(X,PX,Y,PY).   Those parameters should agree with what FFS calculates in\n\
the case of no synchro-beta couplings.",
    "x-y-coupling optical-functions",
    {{"definitions",
      "\
Let V denote the matrix to define the normal mode, i.e.,\n\n\
   U = V . u\n\n\
where U = {X, PX, Y, PY, Z, PZ} and u = {x, px, y, py, z, delta} are normal\n\
physical coordinates, respectively. The matrix V can be expressed as\n\n\
   V = P . B . R . H ,\n\n\
where\n\n\
   H = {{(1 - Det[Hx]/(1 + a))I,       Hx.J2.Transpose[Hy].J2/(1+a), -Hx},\n\
        {Hy.J2.Transpose[Hx].J2/(1+a), (1 - Det[Hy]/(1 + a))I,       -Hy},\n\
        {-J2.Transpose[Hx].J2,         -J2.Transpose[Hy].J2,         a I}} ,\n\
   R = {{b I, J2.Transpose[r].J2, 0},\n\
        {r,   b I,                0},\n\
        {0,   0,                  I}} ,\n\
   P . B = {{Px.Bx, 0,     0    },\n\
            {0,     Py.By, 0    },\n\
            {0,     0,     Pz.Bz}} ,\n\n\
with\n\n\
   a^2 + Det[Hx] + Det[Hy] = 1 ,\n\
   b^2 + Det[R] = 1 .\n\n\
Symbols I, J2, Hx,y, r, Bx,y,z, Px,y,z above are 2 by 2 matrices:\n\n\
   I = {{1, 0},\n\
        {0, 1}} ,\n\
   J2 = {{0,  1},\n\
         {-1, 0}} ,\n\
   r = {{R1, R2},\n\
        {R3, R4}} ,\n\
   Bk = {{ 1/Sqrt[betak],      0          },\n\
         { alphak/Sqrt[betak], Sqrt[betak]}} ,\n\
   Pk = {{ Cos[psik], Sin[psik]},\n\
         {-Sin[psik], Cos[psik]}} .\n\n\
Matrices Hx,y defines dispersions as\n\n\
   {{zetax,  etax},\n\
    {zetapx, etapx},\n\
    {zetay,  etay},\n\
    {zetapy, etapy}} = R . Join[Hx, Hy] .",
      "",
      {}}}},

   {"x-y-coupling",
    "\
The transformation matrix from the physical coordinate {x,px,y,py} to \n\
the x-y decoupled coordinate {X,Px,Y,Py} is written as\n\n\
      R = {{mu I, J . Transpose[r] . J}, {r, mu I}}, \n\n\
with the submatrix r={{R1, R2},{R3, R4}}, where mu^2 + Det[r] = 1, \n\
I = {{1,0},{0,1}}, and J={{0, 1}, {-1, 0}}. The value of function DETR is equal\n\
to Det[r] in this case.\n\n\
   Let T stand for the physical\n\
transfer matrix from location 1 to location 2, then the transformation in\n\
the decoupled coordinate is diagonalized as\n\n\
      R_2 . T . Inverse[R_1] = {{T_X ,0}, {0, T_Y}} .\n\n\
The Twiss parameters are defined for the matrices T_X and T_Y.\n\
   If Det[r] >= 1, the above condition for mu is violated. In such a case, an\n\
alternative form of m is used:\n\n\
      R = {{J . Transpose[r] . J, mu I}, {mu I, r}}, \n\n\
where mu^2 + Det[r] = 1. The function DETR shows a number a-Det[r], where a = 1.375.\n\
thus the alternative form is used when Det[r] >= 0.625.",
    "DISPLAY(DISP) optical-functions matching-function-commands",
    {}},

   {"flags",
    "Usage: [NO]flag\n\n\
turns the flag on.   If NO is prepended to flag, the flag is turned off.\n\
Some flags have antonym which works in the opposite way.   Flags can be \n\
accessed in the function-syntax with the form ?flag, which returns True (=1)\n\
when the flag is on, or False (=0) otherwise.   Some flags can be \n\
accessed by the ON/OFF commands at the MAIN level.",
    "expressions PatternTest",
    Sort[
    {{"RAD",
      "RAD turns on the synchrotron radiation in the particle-tracking.   \n\
Accessible in the MAIN level.",
      "RADCOD FLUC",
      {}},

     {"RFSW",
      "\
RFSW turns on the acceleration by CAVI and TCAVI element in the \n\
particle-tracking and the emittance calculation.   Accessible in MAIN level,\n\
but FFS always turns RFSW on at the beginning of the session.",
      "",
      {}},

     {"RADCOD",
      "RADCOD turns on the energy loss due to synchrotron radiation at the\n\
closed-orbit in the emittance calculation.   Also turns off the implicit \n\
acceleration in the tracking to compensate the energy loss automatically,\n\
in the case that TRPT is ON.     Accessible in MAIN level.",
      "RAD FLUC TRPT",
      {}},

     {"COD",
      "COD turns on finding the closed-orbit in the emittance calculation.\n\
Accessible in MAIN level.",
      "",
      {}},

     {"INTRA",
      "INTRA turns on the calculation of intra-beam scattering in the\n\
emittance calculation.    Accessible in MAIN level.",
      "EMITTACE(EMIT)",
      {}},

     {"TRPT",
      "TRPT or NORING decalres that the beam line is a transport line, not\n\
a part of a storage ring.   The nominal momentum be changed in the\n\
bem line due to acceleration.   The default momentum distribution becomes \n\
uniform distribution.   The default is RING or NOTRPT.   TRPT affects\n\
Emittance[] to ignore equilibrium calculation for a transport line.",
      "DISPLAY(DISP) RING UNIFORM GAUSS",
      {}},

     {"EMIOUT",
      "EMIOUT turns on the extented output of emittance calculation.\n\
Accessible in the MAIN level.",
      "EMIT",
      {}},

     {"GAUSS",
      "GAUSS or NOUNIFORM sets the momentum distribution of the incoming \n\
beam to be Gaussian, otherwise uniform(square) distribution is assumed.\n\
It affects the beam size calculated by Twiss parameters.",
      "UNIFORM MEASURE(MEA) BEAM special-variables DP",
      {}},

     {"BIPOL",
      "BIPOL or NOUNIPOL allows the change of sign of the value of the \n\
element during the matching.   It affects the default keywords of all \n\
elements.   This is overridden by MIN, MAX specification or VariableRange of\n\
each element.",
      "UNIPOL element-commands functions VariableRange",
      {}},

     {"CELL",
      "CELL or NOINS sets the periodic condition in calculating the \n\
optical-functions.",
      "INS CALCULATE(CAL) GO optical-functions matching-function-commands",
      {}},

     {"DAPERT",
      "DAPERT enables the DAPERT procedure in the multi-turn tracking\n\
to obtain the dynamic aperture diagram.   Accessible in the MAIN level.",
      "functions DynamicApertureSurvey",
      {}},

     {"FIXSEED",
      "FIXSEED or NOMOVESEED disables the change of the seed of the random \n\
number generator after the particle tracking.",
      "MOVESEED MEASURE(MEA) SEED",
      {}},

     {"IDEAL",
      "IDEAL or NOREAL inhibits to use the component-specific deviations \n\
(i.e., machine-errors) in the optics calculation.",
      "REAL CALCULATE(CAL) GO machine-errors",
      {}},

     {"CODPLOT",
      "CODPLOT lets the emittance calculation return the information on \n\
the closed-orbit, extended Twiss parameters, and the beam size along\n\
the beam line into the FFS optics buffer, which can be shown by DISPLAY(DISP) or\n\
DRAW commands as well as Twiss and OpticsPlot functions.",
      "EMITTANCE(EMIT) DISPLAY(DISP) DRAW WSPAC",
      {}},

     {"WSPAC",
      "When on, performs space-charge simulation in a \"strong-weak\"\n\
mode. The beam size through the beam line is to be calculated by \n\
EMIT with CODPLOT. The space-charge force is calculated assuming Gaussian\n\
distribution in all dimensions, and particles/bunch given by PBUNCH.\n\
WSPAC is effective in optics and emittance calculations and tracking.\n\ 
   Do not confuse WSPAC with SPAC.",
      "EMITTANCE(EMIT) PBUNCH CODPLOT MINCOUP SELFCOD SPAC",
       {}},

     {"SELFCOD",
      "When on with WSPAC, in tracking, the space charge force is calculated \n\
relative to the center of mass of the current set of particles each time.\n\
Otherwise(default) it is calculated relative to the closed orbit given by EMIT.\n\
SELFCOD is useful when the closed orbits given by EMIT and TRACK are different.",
      "WSPAC",
       {}},

     {"PSPAC",
      "When on, performs space-charge simulation in a \"Particle-In-Cell\"\n\
method. PSPAC is effective in tracking only.\n\ 
   Do not confuse PSPAC with SPAC/WSPAC.",
      "PSPACNX PSPACNY PSPACNZ PSPACDX PSPACDY PSPACDZ",
       {}},

     {"LWAKE",
      "LWAKE turns on optics calculation with Longitudinal WakeFunction",
      "WakeFunction TrackParticles InitialOrbits TWAKE",
      {}},

     {"TWAKE",
      "TWAKE turns on optics calculation with Transverse WakeFunction",
      "WakeFunction TrackParticles InitialOrbits LWAKE",
      {}},

     {"FLUC",
      "FLUC or NODAMPONLY enables the diffusion due to synchrotron radiation\n\
in the particle tracking.   Otherwise only the damping is enabled when RAD\n\
is ON.",
      "DAMPONLY RAD RADCOD",
      {}},

     {"CMPLOT",
      "CMPLOT enables the shift of the center of mass at the beginning of \n\
the tracking.   This is almost obsolete.",
      "",
      {}},

     {"ABSW",
      "ABSW or NORELW sets the weights of variable elements independent from\n\
their values in the matching.   Otherwise they are weighted relatively.",
      "RELW",
      {}},

     {"JITTER",
      "\
JITTER or NOQUIET allows jitter of the center-of-mass of the incoming beam\n\
in the case of TRPT.   Otherwise the center-of-mass statistically fluctuates\n\
depending on the number of particles.",
      "QUIET MEASURE(MEA) TRPT",
      {}},

     {"CONV",
      "CONV is a flag set by the CALCULATE(CAL) or GO commands.   It becomes\n\
True when MatchingResidual is less than CONVERGENCE.",
      "CALCULATE(CAL) GO special-variables:MatchingResidual CONVERGENCE",
      {}},
      
     {"STABLE",
      "STABLE is a flag set by the CALCULATE(CAL) or GO commands in the case\n\
of CELL. It becomes True when the closed orbit is found and the optics is\n\
stable in both x and y.",
      "CALCULATE(CAL) GO",
      {}},

     {"PHOTONS",
       "\
When PHOTONS is ON (default is OFF), TrackParticles generates a list of all\n\
photons radiated through the tracking. The list is assigned to a symbol PhotonList.",
       "PhotonList TrackParticles",
       {}},

     {"RADLIGHT",
      "\
When RADLIGHT is on, the function TrackParticles returns a list of \n\
trajectories which are used to calculate the synchrotron radiation field.",
      "functions:FFS-dedicated-functions:TrackParticles RadiationField \
RadiationSpectrum",
      {}},

     {"SPAC",
      "When SPAC is on, tracking is done with space charge effect. \n\
The actual number of particles in the beam and the number of macro particles\n\
are given by PBUNCH and NP, respectively. This calculation assumes a cylindrical symmetry\n\
of the chamber whose radius is given by RADIUS of DRIFT and MULT elements.\n\
If RADIUS is positive, an aperture is also set at RADIUS to make particle\n\
loss.  If RADIUS is zero, no space charge calculation is done.  If RADIUS is\n\
negative, no space charge effect is taken, but the aperture is set at\n\
-RADIUS.\n\
   Do not confuse SPAC with WSPAC.",
      "NP PBUNCH WSPAC",
       {}},

     {"GEOCAL",
      "\
When GEOCAL is on(default), the geometry of the beam line is always\n\
updated by CALCULATE(CAL) or GO commands using the current values\n\
of components.   The coordinate transformation by SOL is also updated.\n\
When GEOCAL is off, the geometry is never updated.   It is useful to\n\
simulate misalignments within a solenoid, etc.",
      "GEOFIX CAL GO elements:SOL",
      {}},

     {"GEOFIX",
      "GEOFIX is the antonym of GEOCAL.",
      "GEOCAL",
      {}},

     {"SORG",
      "SORG sets the origin of S (design orbit length) at the location\n\
set by ORG.",
      "ORG"
      {}},

     {"FFSPRMPT",
      "\
When FFSPRMPT is off(default) the input prompt is In[n]:= , where n\n\
is $Line+1.   Otherwise the prompt is the traditional FFS prompt, showing\n\
the FIT location and the DISP range.",
      "",
      {}},

     {"RING",
      "RING is the antonym of TRPT.",
      "TRPT",
      {}},

     {"UNIFORM",
      "\
UNIFORM is the antonym of GAUSS.   It assumes the momentum\n\
distribution to be a uniform(square) within +-DP.",
      "GAUSS TRPT",
      {}},

     {"UNIPOL",
      "UNIPOL is the antonym of BIPOL.",
      "BIPOL",
      {}},

     {"INS",
      "INS is the antonym of CELL.",
      "CELL",
      {}},

     {"MOVESEED",
      "MOVESEED is the antonym of FIXSEED.",
      "FIXSEED",
      {}},

     {"REAL",
      "REAL is the antonym of IDEAL.",
      "IDEAL",
      {}},

     {"DAMPONLY",
      "DAMPONLY is the antonym of FLUC.",
      "FLUC",
      {}},

     {"RELW",
      "RELW is the antonym of ABSW.",
      "ABSW",
      {}},

     {"QUIET",
      "QUIET is the antonym of JITEER.",
      "JITTER",
      {}},

     {"UNSTABLE",
      "UNSTABLE is the antonym of STABLE.",
      "STABLE",
      {}},

     {"CALC6D",
      "If CALC6D is on, the optics calculation in CALC and GO performs full\n\
6D calculation, which may takes RADCOD into account. The antonyms is CALC4D.\n\
The Default is CALC4D.",
      "CALC4D",
      {}},

     {"CALC4D",
      "If CALC4D is on, the optics calculation in CALC and GO performs a 4x5\n\
calculation (4D + dispersion). The antonyms is CALC6D. The Default is CALC4D.",
      "CALC6D",
      {}},

     {"CONVCASE",
      "\
When CONVCASE is on, FFS command line parser converts the input characters \n\
to the upper case.(Default on) CONVCASE actions for the element names \n\
and patterns CAN be overridden by PRSVCASE flag.",
      "PRSVCASE",
      {}},

     {"PRSVCASE",
      "\
When PRSVCASE is on, FFS command line parser preserves the input characters \n\
for the element names and patterns.(Default off)",
      "CONVCASE",
      {}},

      Null[]}]},

   {"special-variables",
    "\
There are several variables which have special rolls in FFS.   Some \n\
of them are also accessible in the MAIN level.",
    "special-symbols expressions flags",
    Sort[
    {{"EMITX",
      "\
EMITX is a real variable for the horizontal physical emittance.\n\
It is automatically set by the keyword EMITX of the MARK element at the\n\
beginning of the beam line. The EMITTANCE(EMIT) command returns its \n\
calculated value in EMITX.   The value of EMITX affects the default \n\
weight of variables in the matching.   Accessible in MAIN.",
      "EMITY EMITZ DP elements MARK",
      {}},

     {"EMITY",
      "\
EMITY is a real variable for the vertical physical emittance.\n\
It is automatically set by the keyword EMITY of the MARK element at the\n\
beginning of the beam line. The EMITTANCE(EMIT) command reurns its\n\
calculated value in EMITY.   The value of EMITY affects  the default \n\
weiht of variables in the matching.   Accessible in MAIN.",
      "EMITX EMITZ DP elements MARK",
      {}},

     {"EMITZ",
      "\
EMITZ is a real variable for the longitudinal physical emittance.\n\
It is automatically set by the keyword EMITZ of the MARK element at the\n\
beginning of the beam line. The EMITTANCE(EMIT) command reurns its\n\
calculated value in EMITZ. Accessible in MAIN.",
      "EMITX EMITY DP elements MARK",
      {}},

     {"EMITXE",
      "\
EMITXE specifies the minimum horizontal emittance for EMITTANCE(EMIT)\n\
and Emittance[] calculations. It is useful to give emittance\n\
determined externally, such as for proton machines.",
      "EMITYE EMITZE",
      {}},

     {"EMITYE",
      "\
EMITYE specifies the minimum vertical emittance for EMITTANCE(EMIT)\n\
and Emittance[] calculations. It is useful to give emittance\n\
determined externally, such as for proton machines.",
      "EMITXE EMITZE",
      {}},

     {"EMITZE",
      "\
EMITZE specifies the minimum longitudinal emittance for EMITTANCE(EMIT)\n\
and Emittance[] calculations. It is useful to give emittance\n\
determined externally, such as for proton machines.",
      "EMITXE EMITYE",
      {}},

     {"DP",
      "\
DP represents the relative momentum spread of the beam.\n\
It is automatically set by the keyword DP of the MARK element at the\n\
beginning of the beam line. The value of EMITY affects the default\n\
weight of variables in the matching.   In the off-momentum matching, the\n\
range DP0 - DP < dp/p0 < DP0 + DP is used for the matching.   The assumed\n\
momentum-distribution in the BEAMSIZE(BEAM), MEASURE(MEA), etc. commands,\n\
is Gaussian with the standard deviation DP and the mean DP0 if the flag GAUSS\n\
is on, otherwise uniform (square) in the range DP0 - DP < dp/p0 < DP0 + DP.",
      "DP0 off-momentum-matching flags GAUSS UNIFORM elements MARK",
      {}},

     {"DP0",
      "\
DP0 represents the central value of the relative momentum offset\n\
in the optics calculation, or the center of the momentum distribution of\n\
the beam.   The on-momentum optics has the relative momentum deviation\n\
dp/p0 == DP0, and the off-momentum calculation is done in the range\n\
DP0 - DP < dp/p0 < DP0 + DP.",
      "DP off-momentum-matching matching-function-commands",
      {}},

     {"CONVERGENCE",
      "\
CONVERGENCE is the goal of the convergence(==MatchingResidual) in the\n\
matching.   If MatchingResidual becomes smaller than CONVERGENCE times the\n\
effective number of the conditions, the matching by GO terminates.   The\n\
flag CONV is set when MatchingResidual is smaller than CONVERGENCE after\n\
GO or CALCULATE(CAL).   The default value is 10^-9.",
      "GO MatchingResidual flags:CONV",
      {}},

     {"MatchingResidual",
      "\
MatchingResidual holds the convergence in the last GO or \n\
CALCULATE(CAL) commands.   It is calculated by\n\n\
     sw*(Sum[(w_i*df_i)^ExponentOfResidual,{i}]/sw)^(2/ExponentOfResidual)\n\
     +penalty\n\n\
where w_i is the weight of the i-th condition, df_i is the differece of\n\
the i-th function from the goal, penalty is an additional big number \n\
(typically 10), when the optics is unstable or closed orbit is not found in\n\
the case of CELL.  The parameter sw is defined as\n\n\
     sw=Sum[(OffMomentumWeight/2/woff)^2,{i}]\n\n\
with\n\n\
     woff = 1                               for  on-momentum optics\n\
          = Sqrt[number-of-momentum-points] for off-momentum optics.\n\n\
The weight of the function is lighter in the case of off-momentum-matching\n\
so that all off-momentum deviations functions weight equal to the\n\
on-momentum one.    However, the relative weight for the off-momentum part\n\
can be changed by setting OffMomentumWeight. \n\
   The weight of each function at each point with each momentum can be \n\
specified by defining the FitWeight function.",
      "ExponentOfResidual CONVERGENCE OffMomentumWeight off-momentum-matching\
functions FitWeight",
      {}},

     {"NetResidual",
      "\
The net residual of convergence except the penalty for unstable optics.",
      "MatchingResidual StabliltyLevel",
       {}},

     {"StabilityLevel",
      "\
Number of unstable planes in the optics calculations. Equal to zero if\n\
all x and y optics are stable for on/off-momentum and finite amplitude matching.",
       "",
       {}},

     {"OffMomentumWeight",
      "Relative weight of the off-momentum deviation for the off-momentum\n\
matching.   The default is 1.",
      "ExponentOfResidual CONVERGENCE MatchingResidual off-momentum-matching\
functions:FFS-dedicated-functions:FitWeight",
      {}},

     {"TITLE",
      "TITLE is a character-string to make the title of the plot in\n\
DRAW or GEO commands.",
      "CASE DRAW GEO",
      {}},

     {"FFS$NumericalDerivative",
      "If False (default), the calculation of response matrix for each matching\
variables usus analytical expressions as much as possible. If True, it usse\
numerical difference, which is faster than analytic especially when there\
are many coupled variables defined by ElementValues.",
      "GO ElementValues",
      {}},

     {"CASE",
      "CASE is a character-string to be attached with TITLE to issue\n\
the CASE command of TopDrawer in DRAW or GEO commands.",
      "TITLE DRAW GEO",
      {}},

     {"NP",
      "NP is the number of particles in the tracking.   Accessible in MAIN.",
      "MEASURE(MEA)",
      {}},

     {"CHARGE",
      "\
CHARGE contains the charge of the particle.   The default is +1.",
      "",
      {}},
      
     {"MASS",
      "\
MASS is the rest mass of the particle. The default is electron mass.",
      "",
      {}},
      
     {"MOMENTUM",
      "MOMENTUM is the nominal momentum of the beam line at the entrance\n\
in eV. Accessible in MAIN.",
      "",
      {}},

     {"NPARA",
      "NPARA specifies the maximum number of parallel processes for\n\
variaous calulations such as CALC, GO, TrackParticles, DynamicApertureSurve, etc.",
      "",
      {}},

     {"OMEGA0",
      "\
OMEGA0 is 2*Pi*SpeedOfLight/LINE[\"s\",\"$$$\"] . Accessible in MAIN.",
      "SpeedOfLight functions LINE",
      {}},

     {"DTSYNCH",
      "\
Shift of the origin of z of the closed orbit (default: 0). Set by EMITTANCE or\n\
Emittance[]. Effective with RING only.",
      "",
      {}},

     {"EFFVCRATIO",
      "\
Ratio of (effective voltage)/(Sum[VOLT_k,{k}]) (default: 1),\n\
where effective voltage V_eff is defined as\n\n\
V_eff = Sqrt[(Sum[VOLT_k Cos[PHI_k],{k}])^2 + (Sum[VOLT_k Sin[PHI_k],{k}])^2] .\n\n\
EFFVCRATIO is set by EMITTANCE(EMIT) or Emittance[]. Effective with RING only.",
      "",
       {}},

     {"PHICAV",
      "\
Shift of cavity phase PHI when variation exists among cavities (default: 0). Set by\n\
EMITTANCE(EMIT) or Emittance[] as\n\n\
{Cos[PHICAV], Sin[PHICAV]} == {Sum[VOLT_k Cos[PHI_k],{k}], Sum[VOLT_k Sin[PHI_k],{k}]} .\n\n\
Effective with RING only.",
      "CAVI MULT",
      {}},
      
     {"SpeedOfLight",
      "SpeedOfLight is 299792458.",
      "",
      {}},

     {"PBUNCH",
      "\
PBUNCH is the number of particles/bunch for the calculation of the\n\
intra-beam  and space charge effects in EMITTANCE(EMIT), and WakeFunction. \n\
Accessible in MAIN.",
      "EMITTANCE(EMIT) flags INTRA",
      {}},

     {"NBUNCH",
      "\
NBUNCH is the number of bunches for the calculation of \n\
WakeFunction. Accessible in MAIN.",
      "",
      {}},

     {"MINCOUP",
      "\
MINCOUP is the minimum emittance ratio (EMITY/EMITX) to be assumed in the \n\
calculation of intra-beam effects in EMITTANCE(EMIT).    Accessible in MAIN.",
      "EMITTANCE(EMIT) flags INTRA",
      {}},

     {"LOSSAMPL",
      "\
LOSSAMPL is the transverse amplitude beyond which a particle is judged\n\
to have been lost.   The default is 1 m.    Accessible in MAIN.",
      "elements APERT",
      {}},

     {"LOSSDZ",
      "\
LOSSDZ is the longitudinal position z beyond which a particle is judged\n\
to have been lost.   The default is 100 m.    Accessible in MAIN.\n\
LOSSDZ is effective only when SPAC is ON.",
      "elements APERT flags SPAC",
      {}},

     {"FSHIFT",
      "FSHIFT is the relative shift df/f0 of the revolution (or rf) \n\
frequency in a ring.   This is only valid in EMITTANCE(EMIT) or the \n\
particle-tracking.   In the optics calculation DP0 should be used instead.",
      "DP0",
      {}},

     {"GCUT",
      "\
GCUT specifies the cut-off value of Gaussian distribution in unit of\n\
the standard deviation.    Accessible in MAIN.",
      "SEED flags GAUSS",
      {}},

     {"DAPWIDTH",
      "\
DAPWIDTH is the width of the x-amplitudes to quit the tracking to judge\n\
the aperture is enough.",
      "functions:FFS-dedicated-functions:DynamicApertureSurvey",
      {}},

     {"MatchingAmplitude",
      "\
MatchingAmplitude is a list of amplitudes for the finite-amplitude matching.\n\n\
Usage: MatchingAmplitude := { {dp1,x1,y1}, ..};\n\n\
where dp1 is the momentum deviation to be matched, x1 and y1 are the\n\
horizontal and vertical amplitudes at the beginning of the beam line,\n\
normalized by Sqrt of the sum of the emittance, i.e., Sqrt[(EMITX+EMITY)].\n\
Three orbits are chosen in each dimension.   The initial conditions\n\
of the orbit is chosen as\n\n\
   {X,Px,Y,Py} =\n\
   { {x1,0,0,0}, {-x1/2,Sqrt[3]/2 x1,0,0}, {-x1/2,-Sqrt[3]/2 x1,0,0},\n\
     {0,0,y1,0}, {0,0,-y1/2,Sqrt[3]/2 y1}, {0,0,-y1/2,Sqrt[3]/2 y1} },\n\n\
and when x1==0 or y1==0 corresponding orbits are excluded.   The above \n\
are labeled {x1,x2,x3,y1,y2,y3} in the output of CALCULATE(CAL) or GO,\n\
and also labeled 1 to 6 in the second element of FFS[\"CALC\"] and \n\
FFS[\"GO\"].\n\n\
    This matching is done when dp1 is within the off-momentum range given by\n\
DP, i.e., Abs[dp1] < DP.    If dp1 is in the range, the nearest zero-\n\
amplitude optics is chosen.   The maching conditions for the finite-\n\
amplitude optics are same as those for the zero-amplitude one.\n\
   Th orbit with finte initial condition never close after one revolution,\n\
but FFS simply ignores it and obtain the periodic optics around the open\n\
orbit.",
      "DP EMITX EMITY off-momentum-matching CALCULATE(CAL) GO",
      {}},

     {"InitialOrbits",
      "\
Usage: InitialOrbits = { {x1, px1, y1, py1, z1, dp1}, ...};\n\n\
or     InitialOrbits = { {ax1, bx1, nx1, ay1, by1, ny1,\n\
          ex1, epx1, ey1, epy1, r11, r21, r31, r41,\n\
          x1, px1, y1, py1, z1, dp1, 0, 0, 0, 0, 0, 0, 0}, ...};\n\n\
specifies initial conditions of a number of orbits for the optics\n\
calculation by CALCULATE(CAL) and GO.   Those coordinates are offset from\n\
the central orbit. If six numbers are given, only the offsets of the\n\
orbits are affected.   If 27 numbers are given, all Twiss parameters are\n\
set (values for non-orbit params are used directly. Orbits are giving offsets.)\n\  If InitialOrbits are given, the off-momentum matching and \n\
finite-amplitude matching is disabled.\n\
   InitialOrbits is also necessary to calculate optics with wake field.",
       "CALCULATE(CAL) GO off-momentum-matching finite-amplitude-matching",
      {}},

     {"ElementValues",
      "\
ElementValues is a symbol to assign rules to determine values of keywords\n\
of elements or components. This is used to give a dependence between\n\
keywords of different elements or components, or determine then by a\n\
parameteric expression.\n\n\
Useage:  ElementValues = { key[elem] :> expr, ...}\n\n\
where\n\n\
   key:      keyword to specify a value (string).\n\
   elem:     String to specify the elements or components,\n\
             wildcards are allowed.\n\
   expr:     an expression which returs a real number to be set to\n\
             the elements or components.\n\n\
Example:  ElementValues = \n\
            { \"DX\"[\"QF1\"] :> \"DX\"[\"QD1\"]-0.001,\n\
              \"DY\"[\"QF2.3\"] :> -\"DY\"[\"QD1.2\"],\n\
              \"ROTATE\"[\"QF*\"] :> f[x] }\n\n\
Remarks:\n\
1. Iff elem contains \".\", it is recognized as components, otherwise as\n\
   elements.\n\
2. In the r.h.s. of the rule, an expression like key[elem] is evaluated as\n\
   either LINE[key, elem] or Element[key, elem], depending on elem has \".\".\n\
3. The expression expr can be any expression returning a real number.\n\
4. Later rules overrides the former, if many rules apply on the same keyword\n\
   of the same element.\n\
5. The rule given by ElementValues overrides the relation given by\n\
   COUP_LE command.\n\
6. Use a[b] in stead of a@b.\n\
7. ElementValues is cleared by USE. It is hidden by VISIT and restored by BYE.",
      "",
      {}},

     {"FitFunction",
      "\
FitFunction is a symbol to assign user-defined functions for \n\
matching with the GO command. \n\n\
Usage:   FitFunction := fun, \n\n\
where fun is a function that returns a real number or a list of real \n\
numbers, to be matched to zero by GO.  The goal of GO is to make fun zero\n\
or a list of zeros, together with built-in matching conditions.   Thus the sum of\n\
fun^2 is added to MatchingResidual. GO also evaluates FitFunction to obtain the\n\
derivatives numerically.   The function fun can refer the value of variables\n\
by Element or LINE functions, and the optical functions at DP0 by Twiss.\n\
The algorithm of matching is same as that for built-in conditions, but \n\
it is slower because of the numerical differentiation, when the beam line\n\
is long and the number of variables large.\n\n\
Example:  FitFunction := {Twiss[\"BX\",\"$$$\"]-20, Twiss[\"BY\",\"$$$\"]-20};\n\n\
which puts the same goal as\n\n\
   FIT $$$ BX 20 BY 20 .\n\n\
   FitFunction is cleared by USE. It is also hidden by VISIT and restored by BYE.",
      "GO FREE MatchingResidual DP0 functions:FFS-dedicated-functions:Element\
       LINE Twiss",
      {}},

     {"OpticsProlog",
      "\
OpticsProlog is a variable to assign a user-defined function which is to be\n\
executed every time before an optics calculation is done in the CALCULATE(CAL)\n\
or GO commands.   In GO, OpticsProlog is called at the beginning of each\n\
iteration.   This function is useful, for instance, for setting parameters\n\
which depends on the result of optics calculation itself.",
      "OpticsEpilog",
      {}},

     {"OpticsEpilog",
      "\
OpticsEpilog is a variable to assign a user-defined function which is to be\n\
executed everytime after an optics calculation is done in CALCULATE(CAL)\n\
or GO commands.   In GO, OpticsEpilog is called at the end of each\n\
iteration.   This function is useful, for instance, for setting parameters\n\
which depends on the result of optics calculation itself.",
      "OpticsProlog",
      {}},

     {"$FORM",
      "\
$FORM is a character-string to specify the format of the output of a real\n\
number.   \n\n\
Usage: $FORM=\"w.f\"\n\
       $FORM=\"Sw.f\"\n\
       $FORM=\"Fw.f\"\n\
       $FORM=\"Mw.f\"\n\n\
where w is the width of the output, and f is the length of the fractions.\n\
If S is attached, trailing zeroes are omitted.   If F is attached, it becomes\n\
same as FORTRAN's F-format.   If M is attached, the exponent is expressed as 10^n.\n\
If w and f are omitted, 17.15 is assumed.\n\
   The default is S17.15 .",
      "",
      {}},

     {"PageWidth",
      "\
PageWidth is the number of columns of the output.   The default is set from\n\
GetEnv[\"WIDTH\"].",
      "",
      {}},

     {"STACKSIZ",
      "\
STACKSIZ has the size of the stack for SADScript interpreter.   It can be set\
by user at the MAIN level, right before the first FFS session.   The default\
value is 200000.",
      "",
      {}},

     {"PhotonList",
       "\
When PHOTONS is ON (default is OFF), TrackParticles generates a list of all\n\
photons radiated through the tracking. The list is assigned to a symbol PhotonList.\n\
PhotonList is a list of\n\n\
{en, gx, gy, gz, nx, ny, nz, xi1, xi2, xi3, np, nele}\n\n\
where\n\n\
en:    photon energy [eV]\n\
gx:    GX coordinate of the emission point [m]\n\
gy:    GY coordinate of the emission point [m]\n\
gz:    GZ coordinate of the emission point [m]\n\
nx:    GX component of the photon direction vector\n\
ny:    GY component of the photon direction vector\n\
nz:    GZ component of the photon direction vector (nx^2+ny^2+nz^2)=1.\n\
xi1:   Stokes' parameter for polarization 45 degree to the GZ=0 plane.\n\
xi2:   Stokes' parameter for right-handed polarization\n\
xi3:   Stokes' parameter for polarization in the GZ=0 plane.\n\
np:    particle number\n\
nele:  component number in the beam line\n\n\
The probability of each polarization is given by each Stokes' parameter as\n\
(1+xi)/2 . TrackParticles always updates PhotonList. The length of PhtonList\n\
is the number of emitted photons.\n\
   Remember that the {GX, GY, GZ} = {0, 0, 0} and their directions are {z, -x, -y}\n\
at the entrance of the beam line by default. It is changeable by the GEO command anyway.",
       "PHOTONS TrackParticles",
       {}}
       
    }]},

   {"set-value-of-element",
    "\
Usage: element-pattern [keyword] [{MIN | MAX | MINMAX | MAXMIN}] value\n\n\
sets value to the specified keyword of the elements which match \n\
element-pattern.   If keyword is omitted, the default-keyword is assumed.\n\
   If MIN, MAX, MINMAX, MAXMIN are specified, it sets the limit of the\n\
default-keyword.   Both MINMAX and MAXMIN means MIN=-Abs[value] and \n\
MAX=+Abs[value].\n\
   If the keyword is not the default-keyword, it affects both the current \n\
and the saved value.",
    "ATTRIBUTES(ATTR) SAVE elements wildcards \
functions:FFS-dedicated-functions:Element",
    {KeywordsMessage,

     DefaultKeywordMessage}},

    {"command-syntax",
     "The command syntax in FFS is\n\n\
     expression1 [param1..] [;] expression2..\n\n\
(1) The input is first evaluated as an expression.   If the expression\n\
    returns a Symbol with the same name as the expression itself, it is\n\
    interpreted as an FFS command, otherwise the returned value is printed\n\
    out unless it is Null.\n\
(2) Each command takes succeeding its parameters if necessary.   A command with\n\
    indefinite number of parameters can be terminated by semicolon.\n\
    Most commands terminate itself at the end of line.\n\
(3) A line can be continued to the next line if a backslash is placed at the\n\
    end of the line.\n\
(4) An expression continues to the next line if it is not closed in the line.\n\
(5) An exclamation mark comments out the rest of the line.\n\n\
Example: A command line\n\n\
          QF* .1\n\n\
means the set-value-of-element command as unless the symbol QF has been defined otherwise.\n\
If QF has been defines as a number, such as QF=2.5, the above command line\n\
is interpreted as Times[QF,.1] then returns .25 .",
     "expressions functions",
     {}},

    {"components",
     "\
Components are the objects which consist the beam line.   A component simulates\n\
an individual magnet, drift space, or rf-cavity.   The parameters of a \n\
component is specified the values in the corresponding element with the\n\
same name as the component, which simulates a power supply.   Many \n\
components can be attached to the same element.   Parameters of each \n\
component may deviate from the corresponding element if machine errors are\n\
given.\n\
   A component is specified with the form name[.order][{+-}offset], where\n\
name is the name of the component.    The number order means the order-th \n\
component which belongs to name element, counted from the beginning of the\n\
line starting from 1.   Offset is a positive or negative number to specify \n\
the downstream or upstream components from the given component.   If order \n\
is omitted, the first element is assumed, and if offset is omitted, zero is\n\
assumed.\n\
   The end of line is specified by $$$.   The first component can be\n\
specified by ^^^.",
     "elements",
     {}},

    {"expressions",
     "\
An expression in FFS consists of a symbol, constants, and operators.\n\n\
>>> A symbol is a characters of any length starting with an alphabet or $.\n\
>>> There are two kinds of constants, real number and character-string.\n\
    real number is a number in fortran-line format.\n\
    character-string is a set of characters surrounded by \"\" or ''.\n\
    special-characters can be specified with backslash.\n\
>>> Available operators are (in the order of the priority):\n\
    #,##,\n\
    ?,\n\
    ::,\n\
    @,\n\
    [],\n\
    ++, --,\n\
    /@, //@, @@,\n\
    .,\n\
    ^,\n\
    *, /,\n\
    +, -,\n\
    ==, <>, >, <, >=, =>, <=, =<, \n\
    ===, <=>, \n\
    ~, \n\
    &&,\n\
    ||,\n\
    .., ...,\n\
    |,\n\
    :,\n\
    ->, :>,\n\
    /., //.,\n\
    +=, -=, *=, /=,\n\
    &,\n\
    //,\n\
    /:,\n\
    =, :=, ^=, ^:=, =.\n\
    ;,\n\
    {}\n\
An operator with higher priority is operated first.   An expression \n\
enclosed in () is evaluated first. Most mathematical operations are \n\
threaded into a list, i.e., {a,b} + {c,d} gives {a + b,c + d}, etc.\n\
   Each operators can be used as a function using its name.  For example,\n\
Plus[x,y] gives the same result as x + y.",
     "special-symbols functions command-syntax special-characters",
     Sort[
     {{"Plus(+)",
       "a + b returns the sum of a and b.",
       "",
       {}},

      {"(-)",
       "operator for subtraction or unary minus.",
       "",
       {}},

      {"Times(*)",
       "a * b returns the product of a and b.",
       "",
       {}},

      {"(/)",
       "operator for division.",
       "",
       {}},

      {"Dot(.)",
       "a . b returns the inner product of a and b.",
       "",
       {}},

      {"Power(^)",
       "a ^ b returns the power of a to b.",
       "",
       {}},

      {"Equal(==)",
       "a == b returns True(==1) if a and b have the same type and the same\n\
value.   It returns False(==0) if a and b have the same type but the \n\
different values.   Otherwise returns the expression a == b.",
       "",
       {}},

      {"Unequal(<>)",
       "\
a <> b returns True(==1) if a and b have the same type but the different\n\
values.   It returns False(==0) if a and b have the same type but the same\n\
value.   Otherwise returns the expression a <> b.",
       "",
       {}},

      {"Greater(>)",
       "If both a and b are real, a > b returns True if a is greater than b,\n\
False otherwise.   It causes an error when a or b is not real.",
       "",
       {}},

      {"Less(<)",
       "If both a and b are real, a < b returns True if a is less than b,\n\
False otherwise.   It causes an error when a or b is not real.",
       "",
       {}},

      {"GreaterEqual(>= or =>)",
       "If both a and b are real, a => b returns True if a is greater than\n\
or equal to b, False otherwise.   It causes an error when a or b is not real.",
       "",
       {}},

      {"LessEqual(<= or =<)",
       "If both a and b are real, a <= b returns True if a is less than\n\
or equal to b, False otherwise.   It causes an error when a or b is not real.",
       "",
       {}},

      {"SameQ(===)",
       "a === b returns True(==1) if a and b have the same type and same\n\
value, False(==0) otherwise.",
       "",
       {}},

      {"UnsameQ(<=>)",
       "\
a <=> b returns True(==1) if a and b have the different types or different\n\
values.   False(==0) otherwise.",
       "",
       {}},

      {"Not(~)",
       " ~a returns True(==1) when a is zero, False(==0) when a is a nonzero\n\
real.",
       "",
       {}},

      {"And(&&)",
       " a && b returns True(==1) when both a and b are nonzero real, \n\
False(==0) otherwise.   b is not evaluated when a is zero.",
       "",
       {}},

      {"Or(||)",
       "\
a || b returns True(==1) when a is nonzero real or b is nonzero real,\n\
False(==0) otherwise.   b is not evaluated when a is nonzero.",
       "",
       {}},

      {"StringJoin(//)",
       "a // b converts a and b to character-strings, then join them.",
       "",
       {}},

      {"Alternatives(|)",
       "\
a | b | ... represents a pattern which matches one of patterns a, b, ...",
       "",
       {}},

      {"Sequence([])",
       "a[b,c,..] means a list of b, c,.. with the head a.   It is \n\
evaluated as a function-reference when a is a function or a \n\
defined-function.   When a is a list with head List, it is interpreted \n\
as a part specification of a list.   When a is a character-string, it is \n\
interpreted as a substring specification.   When a is an operator, it is \n\
an expression  b (a) c (a) .. . When a is Null, it means a sequence.",
       "",
       {}},

      {"List({})",
       "{a,b,c...} is a list structure.",
       "",
       {}},

      {"Set(=)",
       "\
a = value sets the value b to the symbol a.\n\
{a,b,..}={v1,v2,..} sets a,b,c simultaneously.\n\
a[b,c,..]=v1 sets the part of a[b,c,..] if a is a list.\n\
a[b,c,..] = expression defines the value a[b,c,..] if a is not a list.",
       "",
       {}},

      {"SetDelayed(:=)",
       "same as Set but the right hand side is not evaluated when it is set.",
       "Set",
       {}},

      {"Unset(=.)",
       "a=. clears the definition assigned to a.",
       "functions Clear",
       {}},

      {"CompoundExpression(;)",
       "a ; b evaluates a, then evaluates b and returns its result.",
       "",
       {}},

      {"Function(&)",
       " a & is a pure-function whose argument is specified #, #n, ##, ##n.",
       "Slot(#) SlotSequence(##) functions Function",
       {}},

      {"PatternTest(?)",
       "\
pattern?test matches to an object which matches pattern\n\
then test[object] gives True.",
       "",
       {}},

      {"Rule(->)",
       "\
pattern->expr represents a rule for ReplaceAll.",
       "",
       {}},

      {"RuleDelayed(:>)",
       "\
pattern:>expr represents a rule for ReplaceAll, where expr is kept\n\
unevaluated until the replacement.",
       "Literal",
       {}},

      {"ReplaceAll(/.)",
       "\
expr/.rule replaces all subexpressions of expr using rule.",
       "",
       {}},

      {"ReplaceRepeated(//.)",
       "\
expr//.rule replaces all subexpressionso of expr using rule,\n\
while a replacement is performed.",
       "",
       {}},

      {"Repeated(..)",
       "\
p.. matches sequence of one ore more expressions, each matching p.",
       "",
       {}},

      {"RepeatedNull(...)",
       "\
p... matches sequence of zero ore more expressions, each matching p.",
       "",
       {}},

      {"Map(/@)",
       "\
f/@a maps function f to subexpressions of a.   f/@[a,level] specifies\n\
a levelspec of map by level.",
       "",
       {}},

      {"MapAll(//@)",
       "\
f//@a maps function f to all subexpressions of a.  f//@[a,Heads->True]\n\
maps including the heads of a and its subexpressions.",
       "",
       {}},

      {"Apply(@@)",
       "\
f@@a applies function f to subexpressions of a.   f@@[a,level] specifies\n\
a levelspec to apply by level.",
       "",
       {}},

      {"Member(@)",
       "\
f@a refers the member a of an instance or a class f.   Otherwise it is same\n\
as f[a].   f@g@h means (f@g)@h, and f@g[h] (f@g)[h].",
       "",
       {}},

      {"Increment(++)",
       "\
a++ increments a by 1, returning the old value of a.\n\
++a increments a by 1, returning the new value of a.",
       "",
       {}},

      {"Decrement(--)",
       "\
a-- decrements a by 1, returning the old value of a.\n\
--a decrements a by 1, returning the new value of a.",
       "",
       {}},

      {"AddTo(+=)",
       "a+=b is equivalent to a=a+b .",
       "",
       {}},

      {"SubtractFrom(-=)",
       "a-=b is equivalent to a=a-b .",
       "",
       {}},

      {"TimesBy(*=)",
       "a*=b is equivalent to a=a*b .",
       "",
       {}},

      {"DivideBy(/=)",
       "a/=b is equivalent to a=a/b.",
       "",
       {}},

      {"Part([[]])",
       "\
a[[b,..]] is a subexpression of an expression a.\n\n\
If an index is omitted or Null as a[[,b]], Part returns a list of elements \n\
whose corresponding index takes the entire range.  For instance,\n\n\
{{1, 2}, {3, 4}, {5, 6}}[[,2]] gives {2, 4, 6}.",
       "",
       {}},

      {"MessageName(::)",
       "\
symbol::tag returns a message associated with symbol and tag\n\n\
symbol::tag = message sets a message identified by symbol",
       "",
       {}},

      {"TagSet(/:)",
       "\
symb/:lhs = rhs sets rhs to lhs, associated with symbol symb.\n\
symb/:lhs := rhs sets rhs to lhs unevaluated, associated with symbol symb.\n\
symb/:lhs =. unsets lhs, associated with symbol symb.",
       "",
       {}}
    }]},

   {"special-symbols",
    "There are pre-defined special symbols in FFS:\n\n\
symbol        value\n\
True           1\n\
False          0\n\
Infinity       INF\n\
INF            INF\n\
NaN            NaN\n\
Pi             ArcSin[1]*2\n\
E              Exp[1]\n\
I              Complex[0,1]\n\
Degree         Pi/180\n\
GoldenRatio    (1+Sqrt[5])/2\n\
SpeedOfLight   299792458",
    "special-variables flags expressions",
    {}},

   {"functions",
    "FFS functions:\n\n\
Constants:\n\
   Degree GoldenRatio I INF* Infinity NaN* Pi SpeedOfLight\n\
Elementary-functions:\n\
   ArcCos ArcCosh ArcSin ArcSinh ArcTan ArcTanh Cos Cosh Exp Log Sin Sinh\n\
   Sqrt Tan Tanh\n\
Special-functions:\n\
   BesselI BesselJ BesselK BesselY BesselJZero Erf Erfc Factorial \n\
   Gamma LogGamma LogGamma1 GammaRegularized GammaRegularizedQ*\n\
   GammaRegularizedP* GaussianCoulomb* GaussianCoulombU*\n\
   GaussianCoulombFitted* LegendreP*\n\
Numerical-functions:\n\
   Abs Ceiling Floor Max Min MinMax* Mod Negative NonNegative Positive\n\
   Round Sign\n\
Matrix-operations:\n\
   Det Eigensystem IdentityMatrix Inner LinearSolve Outer SingularValues*\n\
   Transpose\n\
Random-number:\n\
   GaussRandom* Random* SeedRandom\n\
Complex:\n\
   Arg Complex ComplexQ Conjugate Im Re\n\
Fourier-Transformation:\n\
   Fourier InverseFourier\n\
Data-Manupilation:\n\
   FindRoot Fit* NIntegrate* PolynomialFit* Spline*\n\
Calculus:\n\
   D\n\
Minimization:\n\
   DownhillSimplex*\n\
List-manipulations:\n\
   Append Complement Delete Depth Difference* Dimensions Drop Extract Flatten\n\
   FlattenAt HeldPart Insert Intersection Join Length Part Partition Prepend\n\
   Product Range ReplacePart Rest Reverse RotateLeft RotateRight Select \n\
   Sort Sum Take Table Union\n\
Character-strings:\n\
   FromCharacterCode CharacterPosition Characters DigitQ LetterQ StringDrop\n\
   StringFill* StringInsert StringLength StringPosition StringTrim*\n\
   Symbol SymbolName ToCharacteCode ToLowerCase ToUpperCase ToExpression\n\
Functional-Operations:\n\
   Apply Cases Count DeleteCases Identity FixedPoint* FixedPointList*\n\
   Fold Function Level Map MapAll MapAt MapIndexed MapThread Nest Position\n\
   Replace Scan SelectCases* SwitchCases* Thread\n\
Object-oriented programing and context:\n\
   Begin BeginPackage Class* End EndPackage\n\
Flow-Control:\n\
   Break Catch Check Continue Do For Goto If Label Return Switch Throw Which\n\
   While\n\
Tests:\n\
   AtomQ ComplexQ DirectoryQ* EvenQ FileQ* MatchQ MatrixQ MemberQ NearlySameQ* \n\
   Negative NonNegative NumberQ OddQ Order Positive RealQ StringQ* VectorQ\n\
   BoundQ* FBoundQ*\n\
Input/Output:\n\
   Close Flush* Get OpenRead OpenWrite OpenAppend Print Read SeekFile*\n\
   Short* StringToStream Write WriteString\n\
File System:\n\
   CopyDirectory CopyFile CreateDirectory DeleteDirectory DeleteFile\n\
   DirectoryName FileByteCount FileDate FileNames FileType\n\
   RenameDirectory RenameFile SetFileDate ToFileName\n\
Scoping:\n\
   Block Module With*\n\
Attributes:\n\
   Attributes* Clear Evaluate Head Hold Literal Protect ReleaseHold\n\
   SetAttributes* Unevaluated Unprotect\n\
GUI Widget:\n\
   Window* PanedWindow* Frame* LabelFrame* Canvas* TextLabel* TextMessage*\n\
   Button* CheckButton* RadioButton* Menu* OptionMenu* MenuButton*\n\
   Entry* SpinBox* ListBox* ScrollBar* Scale* TextEditor*\n\
Graphics:\n\
   BeamPlot* ColumnPlot* HistoPlot* ListContourPlot ListDensityPlot \n\
   ListPlot Plot Show FitPlot* GeometryPlot* OpticsPlot* TkPhotoPutBlock*\n\
System Interface:\n\
   Directory Evironment GetEnv* GetGID* GetPID* GetUID* ProcessStatus* \n\
   SetDirectory SetEnv* System* TemporaryName* MkSecureTemp* RealPath*\n\
Multiprocessing:\n\
   BiPipe* Fork* OpenShared* Shared* Wait*\n\ 
Utilities:\n\
   Date DateString* Definition* FromDate* ToDate ToDateString* Pause\n\
   MemoryCheck* Message Off On Sleep TimeUsed Timing TracePrint\n\n\
Functions listed above work basically in the same way as Mathematica's \n\
except those marked by *.\n\n\
FFS-dedicated-functions:\n\
   BeamMatrix CalculateOptics DynamicApertureSurvey Element Emittance FFS\n\
   FitValue FitWeight GeoBase LINE OptimizeOptics OrbitGeo RadiationField\n\
   RadiationSpectrum SymplecticJ SetElement TrackParticles Twiss VariableRange\n\
   TouschekLifetime WakeFunction\n\
Beam-line-functions:\n\
   BeamLine BeamLineName ExtractBeamLine PrintBeamLine WriteBeamLine",
    "expressions",
    Sort[
     {{"Object-oriented-programing",
      "\
Environment for an object-oriented-programming is supplied by:\n\n\
Class:          The function to define a class.\n\
context:        A class defines a context to define its all symbols for\n\
                the variables and methods within the context.\n\
                This automatically avoids conflicts of symbols between \n\
                classes, Global, and System. When c = Class[ ... ] is\n\
                done, a context c` is defined.\n\n\
members:        The set of Members of a class is a union of class variables,\n\
                instance variables, and class methods of the class.\n\n\
operator @:     A special operator to access class member. In a notation \n\
                f@g, g's context defaults the class of the class of f. \n\
                f@g@h[x] is recognized as ((f@g)@h)[x] , thus the context of\n\
                h defaults the class of f.\n\n\
superclasses:   A class inherits all class variables, instance variables,\n\
                class methods from its superclasses which are give by the\n\
                first argument of Class.   If a null list is given, Object` \n\
                is set as the default superclass. Multiple inheritance is\n\
                allowed.\n\n\
class variable: Class variables are given by the second argument of Class\n\
                as a list of symbols. They are unique in the class.\n\
                They can be initialized by declaring in a way such as \n\
                {a=1, {b, c} = {2, 3}} like Module. A form like\n\
                {a = b = c =1} is allowed.\n\n\
instance variable: \n\
                Instance variables are given by the third argument of Class\n\
                as a list of symbols. An instance has those symbols\n\
                separately. They can be initialized by declaring in a way\n\
                such as {a=1, {b, c} = {2, 3}} like as Module. A form like as\n\
                {a = b = c =1} is allowed. Also they\n\
                are initialized at the creation of instance by rules as\n\
                x = c[ a->1, b:>Print[d]], etc.\n\n\
class methods:  Class methods are given by the fourth(last) argument of\n\
                Class. They must be in the form of either one of\n\n\
                f_[arg___] := g_;\n\
                With[_, f_[arg___] := g_];\n\
                With[_, f_[arg___] := g_; .. ];\n\
                If[_,\n\
                  ft_[argt___] := gt_; ..,\n\
                  ft_[argf___] := gf_; ..,];\n\
                h_[f_[arg___], b___] ^:= g_; .\n\n\
                where f is the symbol for the method to be defined.\n\
                Set may be used instead of SetDelayed if necessary.\n\n\
This:           A symbol This in the definition of the method, it is \n\
                translated to the object (the instance or the class) which \n\
                refers the member.\n\n\
default reference:\n\
                In the definition of the class methods, whenever a member of\n\
                the class is appeared, it is recognized as This@member.\n\
                When a symbol of the member conflicts the symbol in System`,\n\
                the system symbol should be wrapped by Literal.\n\n\
reference of member of superclasses:\n\
                Members of the superclasses (denote cc) are referred by \n\
                cc`member in the definition of the method.\n\n\
copying an instance:\n\
                An instance c of a class can be copied to another symbol\n\
                by c1 = c. After the copying, c1 and c refer the identical\n\
                instance. Destructing one of them by such as c1=. clears\n\
                the instance and also all the assigned symbols.\n\n\
Constructor:    When an instance is defined, by x = c[arg], a method\n\
                x@Constructor[arg] is always invoked.\n\
                In evaluation of instance definition under class scope,\n\
                class member symbol appeared 1st slot of Rule or RuleDelayed\n\
                argument is sent to Constructor of new class instance\n\
                without evaluation. (In other term, class member symbol on\n\
                1st slot of Rule or RuleDelayed argument behaves like\n\
                evaluating with implicit Literal[]) One can configure\n\
                Constructor[] in the definition of the class.\n\
                x = c[arg] returns the returned value of Constructor[arg].\n\
                The rules in the argument work in two ways: (1) A rule for an\n\
                instance variable or a class variable sets the initial value\n\
                of the variable, (2) Other rules are stored in an instance\n\
                variable Options as a list.\n\n\
Destructor:     An instance x is cleared by (x=.), which invokes \n\
                x@Destructor[]. The default Destructor is Object`Destructor,\n\
                but one can reconfigure it in the definition of the class.\n\n\
Short:          When an instance x is returned as the result of expression\n\
                for Out[], x@Short[] is invoked to show the result.  The \n\
                default Short is Object`Short, but one can reconfigure it\n\
                in the definition of the class.\n\n\
other methods:  Class[] gives the class of the instance.\n\
                Parents[] gives the immediate superclasses.\n\
                AllParents[] gives the all superclasses.\n\
                Members[] gives a list of class variables, class methods,\n\
                and instance variables of the class.\n\
                AllMembers[] gives a list of class variables, class methods,\n\
                and instance variables of the class and its all parents.",
      "",
      {{"Class",
        "\
Class sets up a class of objects.\n\n\
Usage:   a = Class[\n\
               list of superclasses,\n\
               list of class-variables,\n\
               list of instance-variables,\n\
               class-methods];\n\n\
Example: a = Class[\n\
               {aa, bb},      (* aa and bb are superclasses *)\n\
               {a1, a2},      (* class-variables *)\n\
               {v1, v2},      (* instance-variables *)\n\
               Constructor[arg__] := (Print[{arg}]; v1 = Plus[arg]);\n\
               sum[] := v1 + v2 (* defining Constructor and method \"sum\"*)\n\
             ];\n\n\
         a1 = a[1, 2]          (* creating an instance of a *)\n\
         a1@v1                 (* accessing an instance variable *)\n\
         a1@v2 = 3             (* setting an instance variable *)\n\
         a1@sum[]              (* calling a method \"sum\" *)\n\
         a1=.                  (* delete an instance *)",
        "",
        {}}}},

      {"Functional-operations",
      "",
      "",
      Sort[{{"SwitchCases",
        "\
Usage: SwitchCases[list, {case1,..}]\n\n\
returns a list {list1, .. }, where list1 is a list of subexpressions which\n\
match case1, etc.   SwitchCases does what are done by Cases and DeleteCases\n\
simultaneously.  If the second argument is like {c1, .. , _}, the last of\n\
the returned list contains subexpressions which match none of c1, ...",
        "SelectCases",
        {}},

       {"SelectCases",
        "\
Usage: SelectCases[list, {test1,..}]\n\n\
returns a list {list1, .. }, where list1 is a list of subexpressions which\n\
makes test1 True, etc.   If the second argument is like {c1, .. , True&}, \n\
the last of the returned list contains subexpressions which make none of c1,\n\
... True.",
        "SwitchCases",
        {}},

       {"Difference",
        "\
Difference[list] returns Rest[list] - Drop[list, -1]",
        "",
        {}},

       {"FixedPoint",
         "\
FixedPoint[f, e] starts from f[e] then applies f repeatedly until the result\n\
no longer changes. FixedPoint[f, e, n] specifies the maximum number of iterations\n\
by n. An option SameTest->s specifies the test function. \n\
Threshold->re, and AbsoluteThreshold->ae set the relative and absolute\n\
accuracy, respectively, when SameTest->NearlySameQ (default).",
         "FixedPointList",
         {}},

       {"FixedPointList",
         "\
FixedPointList[f, e] returns the intermediate values of FixedPoint[f, e] as a list.\n\
FixedPointList[f, e, n] and options for FixedPoint are valid.",
         "FixedPoint",
         {}}

        }]},

     {"Utilities",
       "",
       "",
      {{"DateString",
        "\
DateString[] returns the current date and time as string \n\
\"mm/dd/CCYY HH:MM:SS\".\n\
DateString[date] converts date to string as above. The date can be either\n\
a real number (in second, date=0 is 1/1/1900 0:0:0) or a list of\n\
6 reals {Y,m,d,H,M,S}.",
        "",
        {}}}},

     {"Data-Manipulation",
       "",
       "",
      {{"Fit",
        "\
Usage: Fit[data, expr, var, \n\
         {par1, ini1, [{min1, max1}] }, .. ,{parn, inin, [{minn, maxn}]},\n\
         [options..] ]\n\n\
performs a nonlinear fitting of data with an expression expr.\n\n\
data: list of {xi,yi}, {xi,yi,dyi}, or {xi,yi,dxi,dyi}, where dxi and dyi\n\
      are the standard deviation of the i-th point.\n\
expr: an expression containing var as the x-variable, and \n\
      parameters par1,..,parn explicitly.  Use Evaluate[fun] if an implicit\n\
      expression is necessary.\n\
var:  a symbol to express the x-axis variable.\n\
par:  parameter symbol to be varied in the fitting.\n\
ini:  initial value of the parameter.   It must be specified.\n\
(min, max}: optional range of parameter.\n\n\
Fit returns the result as a list:\n\n\
{par1 -> v1, .., parn->vn, ChiSquare -> chisq, GoodnessOfFit -> good,\n\
ConfidenceInterval -> {c1, .., cn}, ConvarianceMatrix -> cov},\n\n\
where v1,..,vn are the values of the parameters which minimizes chi-square,\n\
chisq is the resulting minimum value of the total chi-square (when no \n\
error is given for yi, variance is returned), good is a number \n\
given by GammaRegularized[(ndata-npara)/2,chisq/2] to represent the goodness\n\
of the fit, c1, .., cn are the estimated errors in parameters, and cov is \n\
the covariance matrix.  A typical criterion of the goodness is (good > 0.1).\n\n\
   Options are\n\n\
MaxIterations        Maximum number of iterations.\n\
D                    If True (default), tries to use analytical derivative.\n\
Cutoff               If nonzero, set teh saturation point for each data as:\n\n\
chi-suare = Sum_i ( Min[Cutoff, Max[-Cutoff, (d_i - f_ i) / sigma_i]]^2 ) ,\n\n\
                     which is a sort of robust M-Estimates. By Cutoff, the fit\n\
                     tends to ignore tail data which are beyond Cutoff.\n\
                     If Cutoff is zero (default), it is ignored.",
      "FitPlot",
       {}},

        {"PolynomialFit",
        "\
Usage: PolynomialFit[data, n]\n\n\
performs a 1D linear regression of data.\n\n\
data: list of {xi,yi}\n\
n: the order of the polynomial\n\n\
Fit returns the result as a list:\n\n\
{{c0, .., cn}, {Residual -> res}} ,\n\n\
where c0 .. cn are the coefficients of the fitted polynomial,\n\
y = c0 + c1 x + .. + cn x^n . Res is the rms residual of the fit.",
      "FitPlot",
       {}},

       {"Spline",
         "\
Spline returns data for cubic-spline interpolation.\n\n\
Usage:   sp = Spline[list, [Derivative->{dy1,dy2}] ]\n\n\
where list contains data in the form as\n\
{{x1,y1}, ..} or {{x1,{y11, y12, ..}}, ..}.\n\
Complex number can be allowed for y, but not for x.\n\n\
This spline assumes y''=0 at the boundary, unless\n\
Derivative->{dy1,dy2} is specified to constrain the derivative\n\
at each end to dy1 or dy2. They can be Null to unspecify\n\
the constraint at one of the boundary.\n\
The resulting data of the spline is assigned sp as a SplineData\n\
object. Then one can calculate the interpolated data by\n\n\
    sp[x]                     value of y at x.\n\
    Derivative[1][sp][x]      value of y' at x.\n\
    Derivative[2][sp][x]      value of y'' at x.\n\
    Integrate[sp[x],{x, x0, x1}]   integral of sp[x] from x0 to x1.",
         "",
         {}},

       {"NIntegrate",
         "\
NIntegrate returns numerical integration of a Real or Complex\n\
function\n\n\
Usage:   NIntegrate[f, {x, x0, x1}, options]\n\n\
where f is a function containing Symbol x as the independent variable.\n\
The integral range is from x0 and x1. The function f must contain the\n\
symbol x explicitly.\n\n\
Options           Default      Description\n\
-------------------------------------------------------------\n\
AccuracyGoal      1e-13        Relative accuracy\n\
InitialPoints     20           Number of initial points where\n\
                               the function is evaluated.",
         "",
         {}}}},

     {"System-interface",
       "",
       "",
      {{"System",
       "\
System[string] executes string as a shell command.   It returns the system \n\
return code.",
       "",
       {}},

       {"TemporaryName",
        "\
TemporaryName[] returns a unique file name for a temporary use.",
        "",
        {}}}},

     {"Multiprocessing",
       "",
       "",
       {{"Fork",
         "\
Forks the process into a parent and a child processes.\n\n\
   Fork[]\n\n\
returns 0 and the pid of the child for the child and the parent, respectively.",
         "",
         {}},

         {"OpenShared",
         "\
Allocated shared memory of n bytes.\n\n\
   s = OpenShared[n] ,\n\n\
where s is a file number to be used by Shared function.\n\
The allocated memory can be released by Close[s].",
         "",
         {}},

        {"Shared",
          "\
Read/Write to the shared memory.\n\n\
   Shared[s]\n\
   Shared[s] = x\n\
   Shared[s] := x\n\n\
where s is given by OpenShared, and x is Real, built-in function,\n\
String, defined symbol, or list of them.",
          "",
          {}},

       {"SharedSize",
        "\
Returns the size of an object for OpenShared.\n\n\
   n = SharedSize[x] ",
         "",
         {}}}},

     {"Random-number-functions",
      "\
The random number functions use common seed given by SEED command or\n\
SeedRandom function.   It has an initial value 17 at the beginning of FFS.\n\
The cut-off value of GaussRandom[] is given by variable GCUT.",
      "special-variables: GCUT",
      {{"Random",
        "\
Random[]           gives a uniform random number between 0 and 1.\n\
Random[n]          gives a list of n uniform random numbers.\n\
Random[n1, n2, ..] gives a (n1 * n2 * .. ) tensor of uniform random numbers.",
        "GaussRandom ParabolaRandom SeedRandom",
        {}},

       {"GaussRandom",
        "\
GaussRandom[]           gives a Gaussian random number with average 0, \n\
                        standard deviation 1, cutoff at GCUT.\n\
GaussRandom[n]          gives a list of n Gaussian random numbers.\n\
GaussRandom[n1, n2, ..] gives a (n1 * n2 * .. ) tensor of Gaussian random\n\
                        numbers.",

        "Random ParabolaRandom SeedRandom",
        {}},

       {"ParabolaRandom",
        "\
ParabolaRandom[]           gives a parabola random number between -1 and 1. \n\
ParabolaRandom[n]          gives a list of n parabola random numbers.\n\
ParabolaRandom[n1, n2, ..] gives a (n1 * n2 * .. ) tensor of parabola random\n\
                           numbers.",

        "Random GaussRandom SeedRandom",
        {}},

       {"SeedRandom",
        "\
SeedRandom[plugin_String] selects new pseudo random-number generator\n\
                          plugin named as plugin.\n\
SeedRandom[seed_Real]     initializes the internal state of the current\n\
                          pseudo random-number generator plugin by seed.\n\
SeedRandom[{seeds__Real}] initializes the internal state of the current\n\
                          pseudo random-number generator plugin by {seeds}.\n\
SeedRadnom[state_List]    restores both the selection of the pseudo random-number\n\
                          generator plugin and the internal state of the selected\n\
                          plugin by using state dumped by SeedRandom[].\n\
SeedRandom[]              returns List containing both the current selected pseudo\n\
                          random-number generator plugin name and its internal state.",
        "ListRandom Random GaussRandom ParabolaRandom",
        {}},

       {"ListRandom",
        "\
ListRandom[] returns List of available pseudo random-number generator plugins.",
        "SeedRandom",
        {}}}},

     {"Graphics",
      "\
Graphics represents an object for 2D graphics with the form\n\
Graphics[primitives, options].   Up to now available primitives are:\n\n\
Circle[{cx,cy},rx, options]             : Circle. \n\
Circle[{cx,cy},{rx,ry}, options]        : Oval. \n\
Points[{{x1,y1} .. {x2,y2}}, options]   : Points.\n\
Points[{{x1,y1,dx,dy} .. {x2,y2,dx,dy}}, options]  : Points with error bars.\n\
Line[{{x1,y1} .. {x2,y2}}, options]     : Line.\n\
Line[{{x1,y1,dx,dy} .. {x2,y2,dx,dy}}, options]    : Line with error bars.\n\
Rectangle[{x1,y1}, {x2,y2}]             : A box.\n\
Rectangle[{x1,y1}, {x2,y2}, graphic]    : Graphics in a box.\n\
Polygon[{{x1,y1} .. {x2,y2}}, options]  : Polygon.\n\
Text[{string, {x,y}}, options]          : Text-string at {x,y}.\n\n\
Possible options and their defaults values of Graphics are:\n\n\
option           default         optional values\n\
------------------------------------------------\n\
AspectRatio      GoldenRatio     any positive number\n\
DisplayFunction  $DisplayFunction  Identity or Null to suppress display\n\
Detach           False           True to run tdr asynchronously\n\
Epilog           {}              List of primitives\n\
Frame            True            False to erase outline, ticks, ticklabels.\n\
FrameClick       True            to allow click on frame to change options.\n\
FrameLabel       {\"\",\"\",\"\",\"\"}   List of strings\n\
FrameTicks       {Both,Both,Ticks,Ticks}\n\
                                 None to turn off ticks and labels\n\
                                 Both to turn on ticks and labels\n\
                                 Ticks to turn on ticks only\n\
                                 << For bottom tick >>\n\
                                 False is same as Ticks\n\
                                 True is same as Both\n\
                                 << For top tick >>\n\
                                 False is same as None\n\
                                 True is same as Ticks\n\
                                 << For left & right ticks >>\n\
                                 False is same as None\n\
                                 True is same as Both\n\
                                 If a form {___, _List} is given where\n\
                                 the List is a list of {coord, label, opt___}\n\
                                 label is displayed at coord with option opt.\n\
                                 If a form {___, fun} is given and \n\
                                 fun[coord,exp,org] returns a list of options\n\
                                 for Canvas[Create$Text], it is displayed at major\n\
                                 ticks at coord. exp is the exponent and org is the\n\
                                 original label.\n\
GridLines        Automatic       Automatic to draw grid lines at major ticks\n\
                                 {Automatic,None} for only x\n\
                                 {None,Automatic} for only y\n\
                                 Both, Minor, and Major can be also used.\n\
PlotLabel        \"\"              string\n\
PlotRange        Automatic       {ymin,ymax} or {{xmin,xmax},{ymin,ymax}}\n\
Prolog           {}              List of promitives\n\
Scale            {Linear,Linear} Log, Date\n\
TickSize         1               relative size of ticks.\n\
FrameThickness   Automatic       thickness of the frame line incl. ticks.\n\
Legend           \"\"              shows legend-string.\n\
FontScale        1               Relative size of fonts for FrameLabel, FrameTicks.\n\
FrameFontScale   1               Relative size of fonts for FrameLabel.\n\
                                 If Real, applied to all frames. If List, applied to\n\
                                 bottom, left, top, right, supplemented 1s to the right.\n\
TickFontScale    1               Relative size of fonts for FrameTicks.\n\
                                 If Real, applied to all frames. If List, applied to\n\
                                 bottom, left, top, right, supplemented 1s to the right.\n\
LegendFontScale  1               Relative size of fonts for Legend.\n\n\
Options for primitives:\n\n\
For Text:\n\
option           default         optional values\n\
------------------------------------------------\n\
TextAlign        \"\"              \"CENTER\"\n\
TextCases        \"\"              string to represent CASES of TopDrawer\n\
TextPosition     \"\"              \"DATA\" to represent the position by data\n\
                                 coordinates\n\
TextRotate       0\n\
TextSize         1               relative size of a character\n\
PlotColor        \"Black\"         one of \"White\", \"Black\", \"Red\",\n\
                                 \"Green\",\"Blue\",\"Yellow\",\n\
                                 \"Magenta\",\"Cyan\"\n\n\
For Point\n\
option           default         optional values\n\
------------------------------------------------\n\
PointSize        1               relative size of a point\n\
PointSymbol      \"1O\"            Symbol for PLOT of TopDrawer, or Bar\n\
                                 \"6O\",\"7O\",\"8O\",\"9O\" are triangles\n\
                                 in CanvasDrawer.\n\
PlotColor        \"Black\"         one of \"White\", \"Black\", \"Red\",\n\
                                 \"Green\",\"Blue\",\"Yellow\",\n\
                                 \"Magenta\",\"Cyan\"\n\
ErrorBarTickSize 1               length of error bar ticks.\n\n\
For Line\n\
option           default         optional values\n\
------------------------------------------------\n\
Dashing          \"1\"             character string or a list of numbers to\n\
                                 represent the dashing of the line.\n\
Plot             True            whether plot symbols at data points.\n\
                                 If True, PointSize and PointSymbol are\n\
                                 effective (see above).\n\
PlotColor        \"Black\"         one of \"White\", \"Black\", \"Red\",\n\
                                 \"Green\",\"Blue\",\"Yellow\",\n\
                                 \"Magenta\",\"Cyan\"\n\
ErrorBarTickSize 1               length of error bar ticks.\n\
Thickness        1               thickness of line\n\n\
For Polygon\n\
option           default         optional values\n\
------------------------------------------------\n\
Plot             False           whether plot symbols at data points.\n\
                                 If True, PointSize and PointSymbol are\n\
                                 effective (see above).\n\
PointSize        1               relative size of a point\n\
PointSymbol      \"1O\"            Symbol for PLOT of TopDrawer, or Bar\n\
                                 \"6O\",\"7O\",\"8O\",\"9O\" are triangles\n\
                                 in CanvasDrawer.\n\
PointColor       \"forest green\"  point fill color.\n\
PointBorderColor Automatic       point border color.\n\
                                 Automatic measn PointColor.\n\
PointTags        Null            points tag string or list of tag strings.\n\
PlotJoined       True            whether plot border line of polygon.\n\
Thickness        1               thickness of border line\n\n\
Dashing          \"1\"             character string or a list of numbers to\n\
                                 represent the dashing of the line.\n\
PlotColor        \"black\"         border line color.\n\
LineTags         Null            border line tag string.\n\
FillColor        Null            polygon fill color.\n\
                                 Null means empty polygon.\n\
Tags             False           polygon tag string.\n\n\
   ListPlot accepts options for Graphics, Point, and Line.   Show accepts\n\
options for Graphics.   The output is written to file #9 (fort.9 in OSF1 and\n\
ftn09 in HP-UX) in TopDrawer commands.   If SAD is running on X, the plot is\n\
also done immediately.\n\n\
Examples:\n\
  g1=ListPlot[{{1,2},{10,20}},Scale->Log,PlotJoined->True,\n\
    DisplayFunction->Identity];\n\
  g2=ListPlot[{{1,15},{10,3}},Scale->Log,PlotJoined->True,Dashing->\"1 0.3\",\n\
    DisplayFunction->Identity,Plot->False];\n\
  g3=ListPlot[{{1,2.5},{5,10},{10,12}},Scale->Log,\n\
    DisplayFunction->Identity];\n\
  Show[g1,g2,g3,FrameLabel->{\"X (mm)\",\"Log(Y)\"},PlotLabel->\"Test Plot\",\n\
      AspectRatio->1];",
      "",
      {{"ListPlot",
        "\
Usage: ListPlot[{{x1,y1},..,{xn,yn}}, options]\n\n\
makes a graphic with points.\n\
ListPlot[{y1,..,yn}, options] assumes 1,..n for the x-xoordinate.\n\
ListPlot[{{x,y,dy}, ..}, options ] plots error bars of length dy in y.\n\
ListPlot[{{x,y,dx,dy}, ..}, options ] plots error bars in x and y.\n\n\
option           default         optional values\n\
------------------------------------------------\n\
PlotJoined       False           True\n\
                                 Step\n\
StepRatio        1               ratio of stepping position\n\
                                 between two data points\n\n\
Type ? to see other options for Graphics.",
        "Graphics Plot",
        {}},

       {"ColumnPlot",
        "\
Usage:  ColumnPlot[data, options, ...]\n\n\
plots a column plot.\n\
1) If data is a 1D vector, it makes a simple column plot.\n\
2) If data is a 2D matrix, it makes a multiple-column plot.\n\
3) If data is a 3D list, it makes a stacked, multiple-column plot.\n\n\
Besides options common for all plotting functions, ColumnPlot has its own\n\
options:\n\n\
Option           Value          Default             Action\n\
---------------------------------------------------------------------------\n\
ColumnOffset    0<number<1      0.15            Ratio of spacing of columns\n\
Reference        number         0               Where column starts\n\
Orientation     Vertical        Vertical        Orientation of columns\n\
                Horizontal\n\
ColumnLabel     List of Str.    Automatic       Lables for each column\n\
                Function                        Scale for column number\n\
                None                            No labels\n\
FillColor       color                           Colors to fill columns\n\
                list of colors\n\
MeshStyle       bitmap                          Bitmap to fill columns\n\
                list of bitmaps                 to distinguish stacking\n\
TextSize        positive number 1               relative label size",    
        "Graphics",
        {}},

       {"HistoPlot",
        "\
Usage:  HistoPlot[data, options, ...]\n\n\
plots a histogram using ColumnPlot(default) or ListPlot.\n\
Data can be a single list, or list of lists, which results in a multi-column\n\
histogram on a common axis.\n\
Besides options common for all plotting functions and ColumnPlot, it has\n\
its own options:\n\n\
Option           Value          Default             Action\n\
---------------------------------------------------------------------------\n\
Bins            number          Automatic           number of bins\n\
BinRange        {min,max}       Automatic           Range of bins\n\
PlotStyle       ColumnPlot      ColumnPlot          plot function\n\
                ListPlot\n\
                FitPlot\n\
Orientation     Vertical        Vertical            orientation of columns\n\
                Horizontal\n\
FitParameters   args for FitPlot in a list",
        "Graphics ColumnPlot ListPlot",
        {}},

       {"ListContourPlot",
        "\
Usage:  ListContourPlot[list, options, ...]\n\n\
plots a coutour plot by list which is a 2D List of Real data.\n\n\
Option           Value          Default             Action\n\
---------------------------------------------------------------------------\n\
Contours         Real           10                  number of contoure\n\
PlotRange        {min,max}      Automatic           depth of contours\n\
MeshRange        {{x0,x1},{y0,y1}}\n\
                                Automatic           Range of x and y axes\n\
AspectRatio      Real           1\n\
ColorFunction    Function or String\n\
                                Automatic           Null or None means \"white\"\n\
ContourColorFunction\n\
                 Function or String\n\
                                Automatic           Null or None to hide\n\n\
Example:\n\
  cf[x_]:=If[0.09<x<0.11,\"red\",Null,Null]; (* Draw red contour line only *)\n\
                                           (* around x = 0.1 *)\n\
  ListContourPlot[Table[-x^2+y^2,{x,-4,4,0.5},{y,-4,4,0.5}],\n\
  MeshRange->{{-4,4},{-4,4}},ContourColorFunction->cf,\n\
  ColorFunction->Automatic, FrameLabel->{\"x\",\"y\"}]",
        "Graphics ListPlot ListDensityPlot",
        {}},

       {"ListDensityPlot",
        "\
Usage:  ListDensityPlot[list, options, ...]\n\n\
plots a density plot by list which is a 2D List of Real data.\n\n\
Option           Value          Default             Action\n\
---------------------------------------------------------------------------\n\
PlotRange        {min,max}      Automatic           depth of density\n\
MeshRange        {{x0,x1},{y0,y1}}\n\
                                Automatic           Range of x and y axes\n\
AspectRatio      Real           1\n\
ColorFunction    Function or String\n\
                                Automatic           Null or None means \"white\"\n\
Mesh             True or False  False               True to draw mesh\n\
MeshColor        Function or String\n\
                                Automatic           Null or None to hide\n\
ColorScale       True or False  True                displays a color scale on the right\n\
Smoothing        integer >= 0   1                   number of linear interpolations\n\n\
Example:\n\
data = Table[Sin[x]/Cos[x^2 + y^2], {x, -2, 2, 0.1}, {y, -2, 2, 0.1}];\n\
   ListDensityPlot[data,PlotRange->{-5,5}, MeshRange->{{-2,2},{-2,2}},\n\
   FrameLabel->{\"x\",\"y\"}]",
        "Graphics ListPlot ListContourPlot",
        {}},

       {"GeometryPlot",
	 "\
Usage: GeometryPlot[options]\n\n\
plots a geometry of beam line.\n\n\
options       defaults\n\
-----------------------------------------\n\
Region        {1,LINE[\"LENGTH\"]}  {begin, end}, begin and end can be strings.\n\
                                  Both begin and end point of drawing region\n\
                                  could be given by \"S\" unit by using S[begin|end] form.\n\
Names         \"*\"                 A pattern of component names to be plotted.",
	 "Graphics OpticsPlot",
	 {}},

       {"BeamPlot",
         "\
Usage: BeamPlot[loc, axes, options]\n\n\
plots a beam ellipse at a location loc, for axes. Axes are given by a list \n\
{ax, ay}, where ax and ay are one of \"X\", \"PX\", \"Y\", \"PY\", \"Z\", \"DP\".\n\
The beam envelope should be calculated by (CODPLOT;EMIT) or BEAM commands before\n\
BeamPlot.\n\n\
options       defaults\n\
-----------------------------------------\n\
Orbit         True                Uses Twiss[\"DX\",loc], etc. as the center of\n\
                                  ellipse.\n\
SizeFunction  \"SIZE\"              If \"SIG\", LINE[\"SIG\"] is used.\n\
                                  LINE[\"SIZE\"] is the default.\n\
AspectRatio   1\n\
DataRange     Default             If Default, PlotRange becomes square for\n\
                                  axes = {\"X\", \"Y\"} or {\"PX\", \"PY\"}",
         "BEAMSIZE(BEAM) EMITTANCE(EMIT) flags CODPLOT",
         {}},

       {"OpticsPlot",
        "\
Usage: OpticsPlot[fun_list, options]\n\n\
makes a plot of built-in optical functions, user-defined functions, or\n\
list of data at components on the beam line.   The parameters are\n\
  fun_list: a list of objects to be plotted in a window.\n\
            The number of windows in a plot is the length of fun_list.\n\
            object plotted in a window MUST have same dimensions.\n\
            An element of fun_list is one of fun_label, fun, list_data or\n\
            a list as {object, options}, where\n\
            fun_label: one of \"AX\", \"BX\", \"NX\", \"EX\", \"EPX\", \"DX\", \"DPX\",\n\
               \"AY\", \"BY\", \"NY\", \"EY\", \"EPY\", \"DY\", \"DPY\", \"R1\", \"R2\", \"R3\",\n\
               \"R4\", \"DETR\",\"DZ\",\"DDP\",\"PEX\", \"PEPX\", \"PEY\", \"PEPY\",\n\
               \"GAMMA\", \"GAMMABETA\",\"SIGab\",\n\
               where a and b in \"SIGab\" are one of X, PX, Y, PY, Z, DP.\n\
            fun: Any function of the component number.   A fractional number\n\
               may be used to obtain the intermediate value.\n\
            list_data: a list of {{pos1, val1}..{posn,valn}}.\n\n\
options       defaults\n\
-----------------------------------------\n\
Region        {1,LINE[\"LENGTH\"]}  {begin, end}, begin and end can be strings.\n\
                                  Both begin and end point of drawing region\n\
                                  could be given by \"S\" unit by using S[begin|end] form.\n\
Lattice       True                False to turn of drawing lattice\n\
LatticeRegion Automatic           {low,high}, the region where lattice is drawn\n\
FrameHeight   Automatic           List of relative heights of each frame\n\
InfoLabel     False               If True, pressing Button shows Twiss, etc.\n\
Names         \"*\"                 A pattern of component names to be plotted.\n\
RemoveOverlap \"L$NAME\"            If not \"L$NAME\", overlapping of lattice names\n\
                                  remain untouched.\n\
Tags          False               True to attach tags \"C$\"//(component name)\n\
                                  to each rectangle for the lattice, and\n\
                                  \"L$\"//(component name) to the component \n\
                                  label (CanvasDrawer only).\n\
Legend        False               If Automatic, Legend is composed from FrameLabel\n\
                                  Automatically.\n\n\
options in a fun_list element:\n\
options       defaults\n\
-----------------------------------------\n\
Unit          1                  Unit of the object. \"Meter\", \"InvMeter\",etc.\n\
FrameLabel    \"\"                 Left frame label.\n\
Legend        False               If Automatic, Legend is composed from FrameLabel\n\
                                  Automatically.\n\n\
Example:\n\
  p2=OpticsPlot[\n\
    {{\"BX\",\"BY\"},\n\
     {\"DX\",{{{10,0.001},{20,0.002}},FrameLabel->\"DX meas.\",\n\
    Unit->Meter}}}];",
      "Graphics ListPlot",
      {}},

       {"FitPlot",
        "\
Usage: FitPlot[data, fun, var, {par1,ini1}, .. , {parn, inin}, opt].",
        "Fit",
        {}},

       {"Plot",
        "\
Usage: Plot[fun, range, options] or Plot[{fun1, .. }, range, options],\n\n\
where fun is a function and range is a list given as {x, xmin, xmax}.\n\n\
options        defaults\n\
-----------------------------------------\n\
MaxBend        0.04\n\
PlotPoints     25\n\
PlotDivision   250\n\
Dashing        {\"1\",\"0.8 0.24\",\"0.4 0.12\",\"0.2 0.08\",\"0.1 0.08\",\n\
                  \"0.8 0.08 0.08 0.08\",\"0.4 0.08 0.08 0.08\"}\n\
Options for ListPlot and Graphics are also available\n\n\
The independent variable should have been cleared (i.e., no value should\n\
not be set) when Plot is called. \n\n\
Example:  Plot[{Cos[x],Check[Sin[x]/x,1]}, {x,0,10}]",
      "Graphics ListPlot",
      {}}
     }},

     {"DownhillSimplex",
      "\
Usage: DownhillSimplex[initial, f, options]\n\n\
minimizes a function f by the downhill simplex method, starting from an\n\
initial simplex initial.  Suppose f is a function of n variables.   Then \n\
initial is a list of n+1 elements, each of which is a list of the form\n\n\
   {f[vi], vi} ,\n\n\
where vi is a list of n values correspoinding to each variable.\n\
The initial must be sorted in ascending order of f, i.e.,\n\n\
   initial=Sort[Map[{f[#],#}&,vlist]]\n\n\
generates initial from a list of variables vlist.\n\
   DownhillSimplex returns the final simplex in the same form as initial.\n\n\
Options:\n\
   VariableRange -> {{min1 .. minn}, {max1 .. maxn}} gives the range of n\n\
      variables.   The default is -Infinity to Infinity for all variables.\n\
   MaxIteration -> maxi gives the limit of number of iterations.   The\n\
      default is Max[100, 10*(n+1)].\n\
   Output -> lfn sets the output file number for the intermediate results.\n\
      the default is 6 (stdout).\n\
   Tolerance -> tol sets the tolerance to judge the local minimum.\n\
      If (fmax-fmin)/(abs(fmax)+abs(fmin)) becomes less than tol, the \n\
      iteration loop terminates.   The default is 10^-6.\n\n\
Examples:\n\
  f:=Apply[Function[{x,y},((x^2+y^2)-1)*(x^2+y^2)-(x-.5)/3.],#]&;\n\
  v={{1.,1.},{0.,-1.},{0.,1.}};\n\
  limit={{-0.5,-1.5},{0.65,1.5}};\n\
  p=Sort[Map[{f[#],#}&,v]]\n\
  DownhillSimplex[p,f,MaxIteration->100,\n\
     Tolerance->1e-4,VariableRange->limit]",
      "FFS-dediacted-functions:OptimizeOptics",
      {}},

     {"Beam-line-functions",
      "\
Functions/objects to construct/edit beam lines and elements in FFS.",
      "",
      Sort[
      {{"BeamLine",
       "\
Usage: BeamLine[e1, e2, ...];\n\n\
where e1, e2 has a form of\n\n\
   [ - ][ n* ] x ,\n\n\
with x being one of\n\n\
1) a name (either a symbol or a character string) of an element defined in MAIN.\n\
2) a name (either a symbol or a character string) of a LINE defined in MAIN.\n\
3) a BeamLine object.\n\n\
An optional negative sign specifies the direction and a number n the repetition\n\
number in the same way as MAIN.   A BeamLine object is automatically expanded\n\
to the lowest level whenever it is evaluated.   Editing of BeamLine can be\n\
done using any List-handling functions such as Join, Insert, Delete, etc. of\n\
FFS.\n\n\
A BeamLine object can be used for FFS calculation when it is used as the\n\
argument of USE or VISIT commands:\n\n\
Examples:\n\
1) USE BeamLine[IP,QF,QD]\n\
2) aaa=ExtractBeamLine[];\n\
   USE Join[aaa,-aaa]\n\n\
In these cases the new beam line becomes a new LINE in the MAIN level, with\n\
a name which is created automatically.",
        "ExtractBeamLine PrintBeamLine WriteBeamLine USE VISIT",
        {}},

       {"BeamLineName",
        "\
BeamLineName[] returns the name of the current beam line.\n\
If a BeamLine object is used by USE or VISIT, the new beam line becomes a\n\
new LINE in the MAIN level, with a name which is created automatically.",
        "",
        {}},

       {"ExtractBeamLine",
        "\
Usage: ExtractBeamLine[line]\n\n\
returns a BeamLine object which represents the expanded form of line which has\n\
been defined in MAIN.   If line is omitted, the current line is assumed.",
        "BeamLine PrintBeamLine WriteBeamLine USE VISIT",
        {}},

       {"WriteBeamLine",
        "\
Usage: WriteBeamLine[f, b1,.. ,option]\n\n\
writes the BeamLine b1,.. to file f.  If b1.. is omitteed the current beam line\n\
is assumed.  If Format->\"MAIN\" is given, it writes in\n\
the MAIN-input format.  If Name->{name1,..} is given, names of BeamLines are\n\
also written.   The number of Name must be not smaller than number of BeamLines.",
        "BeamLine ExtractBeamLine PrintBeamLine USE VISIT",
        {}},

       {"PrintBeamLine",
        "\
Usage: PrintBeamLine[b1,.. ,option]\n\n\
writes the BeamLine b1,..  to stdout. If b1.. is omitteed the current beam line\n\
is assumed.  If Format->\"MAIN\" is given, it writes in\n\
the MAIN-input format.  If Name->{name1,..} is given, names of BeamLines are\n\
also written.   The number of Name must be not smaller than number of BeamLines.",
        "BeamLine ExtractBeamLine WriteBeamLine USE VISIT",
        {}}}]},

     {"FFS-dedicated-functions",
      "\
Functions dedicated to the optics calculations and simulations in FFS.",
      "",
      Sort[
      {{"OptimizeOptics",
        "\
Usage: OptimizeOptics[options]\n\n\
optimizes (1 + MatchingResidual) or any function using DownhillSimplex\n\
with variables specified by FREE.   Unlike GO, any keyword of any\n\
element can be a variable.\n\
   OptimizeOptics returns the final simplex.  The variables are set to\n\
the values which give the minimum of the function so far at the end.\n\n\
Options:\n\
   All options for DownhillSimplex are valid.\n\
   OptimizeFunction -> fun is the function to be minimized.   The default is\n\
      ((FFS[\"CALC\"];1+MatchingResidual)&).\n\
   InitialSimplex -> initial sets the initial simplex to initial.   The\n\
      default is Null, which mean to create initial from the current value\n\
      of the variables.   Its format is same as for initial of \n\
      DownhillSimplex\n\
   SimplexSize -> size is the initial size of the simplex.   Each variable\n\
      is relatively shifted by this amount from the current value.\n\n\
Example:\n\
   free Q* Q* L\n\
   fit nx .3 ny .2\n\
   OptimizeOptics[]\n\n\
optimizes the optics by changing the lengths of quads which are not allowed\n\
by GO, as well as K1 of quads.",
        "DownhillSimplex",
        {}},

       {"FFS",
        "\
FFS[command-string] executes command-string as FFS commands.   Any commands\n\
can be used.   Some commands CALCULATE(CAL), GO, VARIABLES(VAR), SHOW \n\
returns their result, otherwise Null is returned.  All outputs of the \n\
commands are suppressed.\n\
   FFS[command-string,lo] directs the output of the commands to file-number\n\
lo.   The file-number lo may be given by OpenWrite or OpenAppend.\n\
   The IF structure and REPEAT(REP) loop must be closed in a single FFS.",
        "Input/Output OpenWrite OpenAppend",
        {}},

       {"ExternalMap",
        "\
With MAP elements, ExternalMap defines a user-defined map of particles.\n\
It also allows a user to do anything (doing statistics, etc.) at any\n\
point of a beam line during a tracking. \n\n\
Usage: First define a MAP element at MAIN level:\n\n\
     MAP    name=(L=leng);\n\n\
Right now L is the only keyword.    Insert it at the location(s) \n\
where you want to use it.\n\n\
1) Tracking\n\
In FFS, define the function ExternalMap as\n\n\
    ExternalMap[\"TRACK\",n,nt_,x_]:=body;\n\n\
The second argument n is the position of MAP counting from the beginning,\n\
which can be obtained using LINE[\"POSITION\",\"name.m\"].    The third \n\
argument nt_ is used to receive the number of turns which is incremented \n\
by the tracking. The last argument x_ is used to receive the coordinates \n\
of particles. It is a (7, np) list of real numbers.    The elements \n\
(1..6, i) are (x, px ,y ,py ,z ,dp/p0) of the i-th particle.   The (7, i) \n\
element is True(==1) if the i-th particle has been survived, and False(==0)\n\
if it has been lost.\n\n\
You can define ExternalMap to change the coordinates of each particle as \n\
you like by returning a new x in the same format as above.    If you do \n\
not return it or you return in a different format, the tracking routine does\n\
not change the particle coordinates.    You can neither rebirth a lost \n\
particle nor kill a surviving particle.\n\n\
After defined ExternalMap, tracking calls it in every turn.\n\n\
Example:\n\n\
   MAP P1=();\n\
   ....\n\
   LINE A=(... P1 ... P1 ...);\n\
   ....\n\
   FFS USE=A;\n\
     ExternalMap[\"TRACK\",LINE[\"POSITION\",\"P1.2\"],nt_,x_]:=\n\
	(Print[x];x*2);\n\
   ....\n\n\
   TRACK USE=A ....;\n\n\
This example defines ExternalMap to print out the coordinates of all\n\
particles at the second P1 in the line A.    It also makes all coordinates\n\
of all particles twice in every turn.\n\n\
2) Emittance\n\
In FFS, define the function ExternalMap as\n\n\
    ExternalMap[\"EMIT\",n,cod_]:=body;\n\n\
The second argument n is the position of MAP counting from the beginning,\n\
which can be obtained using LINE[\"POSITION\",\"name.m\"]. The last \n\
argument cod_ is used to receive the orbit at the entrance of the element,\n\
as a list of 6 real numbers. \n\
ExternalMap must return a list, either {cod1, trans} or \n\
{cod1, trans, dtrans, dbeam}, where cod1 is the orbit at the exit,\n\
trans is the 6 by 6 transfer matrix of this element, dtrans is the\n\
radiation damping part of the transfer matrix (6 by 6), and dbeam\n\
is the radiation excitation of the beam matrix (6 by 6). \n\
Only j >= i parts of dbeam[[i, j]] are taken into account.\n\n\
Example:\n\n\
    ExternalMap[\"EMIT\",LINE[\"POSITION\",\"P1\"],cod_]:=(\n\
      Print[cod];\n\
      {cod+{0,0.001,0,0,0,0},IdentityMatrix[6]});\n\n\
3) Optics\n\
In FFS, define the function ExternalMap as\n\n\
    ExternalMap[\"OPTICS\",n,cod_]:=body;\n\n\
The second argument n is the position of MAP counting from the beginning,\n\
which can be obtained using LINE[\"POSITION\",\"name.m\"]. The last \n\
argument cod_ is used to receive the orbit at the entrance of the element,\n\
as a list of 6 real numbers. ExternalMap must return a list {cod1, trans},\n\
where cod1 is the orbit at the exit and trans is the 6 by 6 transfer matrix\n\
of this element. So far only the 4 by 5 transfer matrix is effective.\n\n\
Example:\n\n\
    ExternalMap[\"OPTICS\",LINE[\"POSITION\",\"P1\"],cod_]:=(\n\
      Print[cod];\n\
      {cod+{0,0.001,0,0,0,0},IdentityMatrix[6]});\n\n\
4) Geometry\n\
In FFS, define the function ExternalMap as\n\n\
    ExternalMap[\"GEO\",n,geo_,pos_]:=body;\n\n\
The second argument n is the position of MAP counting from the beginning,\n\
which can be obtained using LINE[\"POSITION\",\"name.m\"]. The argument\n\
geo_ receives the geometry of the beam line at the MAP element, in the\n\
same format as LINE[\"GEO\",n], i.e., {{GX,GY,GZ},{CHI1,CHI2,CHI3}}.The last\n\
argument pos_ receives the orbit length S at the element.\n\
ExternalMap must return an updated list {geo1, pos1},\n\
as { {{GX,GY,GZ},{CHI1,CHI2,CHI3}}, S} as the values at the exit of the\n\
element.\n\
Example:\n\n\
    ExternalMap[\"GEO\",LINE[\"POSITION\",\"P1\"],geo_,pos_]:=(\n\
      Print[cod];\n\
      { {geo[[1]]+{1,0,0}, geo[[2]]}, pos+0.1})",
        "",
        {}},

       {"Element",
        "\
Element[key-string, {element-pattern-string | element-position}] returns \n\
values for key-string of elements which match element-pattern-string or\n\
located at element-position.  It returns a list if more than one elements \n\
match.   The key-string and element-pattern-string can be symbols, unless\n\
values are not assigned to them.\n\
   If the second argument is omitted, it means all elements.\n\
   The element-position can be known by Element[\"POSITION\"].\n\
   Key-strings \"VALUE\" and element-keywords allows to be set (i.e.,\n\
Element[a,b] = v) when element-pattern-string chooses only one element.\n\
If a value is set to Element, it is automatically distributed to all \n\
components those belong to the element.  If the keyword is the default \n\
variable, the error given by machine-error-command DK is applied.\n\
   The arguments of Element can be lists.   It automatically maps as\n\n\
   Element[{a,b,c..},y]  means {Element[a,y],Element[b,y],Element[c,y]..}\n\
   Element[x,{a,b,c..}]  means {Element[x,a],Element[x,b],Element[x,c]..},\n\n\
where both x and y can be also a list.\n\n\
   If an option Saved->True is given, Element refers the save-buffer which\n\
can be transferred to other beam lines.   Otherwise values set by Element\n\
are not saved when FFS is stopped, unless they are the default-keyword or\n\
keywords once used in matching.",
        "elements wildcards components LINE SetElement",
        {{"key-strings",
          "\
The key-string is not case-sensitive. Available key-strings are:\n\n\
\"LENGTH\"       Number of elements in the beam line.   No second argument.\n\
\"POSITION\"     Position of the element in the element-list.\n\
\"NAME\"         Name of the element.\n\
\"VALUE\"        Current value of the default keyword of the element.\n\
\"KEYWORDS\"     List of available keywords of the element.\n\
\"DEFAULT\"      The default keyword of the element\n\
\"TYPE\"         The internal code-number of the type of the element.\n\
\"TYPENAME\"     The name of the type of the element.\n\
keyword        If keyword is the default keyword, it means the current \n\
               value.   If not, it means the saved value.   Changing the\n\
               non-default keyword by Element does not affects the current\n\
               setting of the components.\n\
\"EXPAND\"       Distribute the value of the default-keywords and the \n\
               keywords used in the matching to all components in the\n\
               beam line.   No second argument.\n\n\
Setting by Element[\"VALUE\",..] or Element[keyword,..] to the DEFAULT \n\
keyword or a matching-variable keyword changes the current value, and \n\
distributed to the components in the succeeding calculation.",
          "set-value-of-element elements keywords default-keyword components",
          {}}}},

       {"SetElement",
        "\
Create/set/read a MAIN-level element.\n\n\
Usage: SetElement[ element-name, element-type, options]\n\n\
where\n\n\
   element-name: name of the element, either a symbol or a string\n\
   element-type: type of the element, a symbol, a string, or a number\n\
   options: one or more rules or list of rules of the form\n\
            keyword -> value or keyword :> value, to set the corresponding\n\
            value of keyword of the element.\n\n\
   SetElement returns a list of information of the element, in the suitable\n\
form for applying SetElement again.\n\
   You can define a new element by SetElement.\n\
   You can change the values of keywords of the element.  You cannot, \n\
however, change the type of the element, nor cannot delete the element.\n\
   The element-type can be Null. If so, a null type is assumed for a new\n\
element.\n\n\
Examples:\n\n\
   LINE A = ( .. );\n\
   QUAD QF = (K1 = 0.2);\n\
   ...\n\
   FFS USE = A;\n\
     ...\n\
    SetElement[\"QF\"]                     "//
"! reads values of QF.\n\
    SetElement[\"QF\",\"QUAD\"]              "//
"! same as above.\n\
    SetElement[\"QF\",\"BEND\"]              "//
"! error because QF is QUAD.\n\
    SetElement[\"QF\",,{\"K1\"->0.1}]        "//
"! set K1 of QF to 0.1 .\n\
    SetElement[\"QF\",\"QUAD\",{\"K1\"->0.1}]  "//
"! same as above.\n\n\
 "//
"!Assuming QF1 and QF2 are undefined yet:\n\n\
    SetElement[\"QF1\",\"QUAD\",{\"K1\"->0.1}] "//
"! create a new QUAD QF1 with K1=0.1 .\n\
    SetElement[\"QF2\",,{\"K1\"->0.1}]       "//
"! error because no type with key.\n\
    SetElement[\"QF2\"]                    "//
"! This is OK.\n\
    SetElement[\"QF2\",\"QUAD\"]             "//
"! Now the type of QF2 is defined.",
        "elements keywords",
        {}},

       {"LINE",
        "\
LINE[key-string, {component-pattern-string | component-position}] returns \n\
values for key-string of components which match component-pattern-string or\n\
located at component-position.  It returns a list if more than one components\n\
match.   The key-string and component-pattern-string can be symbols, unless\n\
values are not assigned to them.   The second arg can be a fractional number\n\
to denote an intermediate value of two components.\n\
   If the second argument is omitted, it means all components.\n\
   The component-position can be known by LINE[\"POSITION\"].\n\
   Key-strings \"DIR\" and component-keywords allows to be set (i.e.,\n\
LINE[a,b] = v) when component-pattern-string chooses only one component.\n\
   The arguments of LINE can be lists.   It automatically maps as\n\n\
   LINE[{a,b,c..},y]  means {LINE[a,y],LINE[b,y],LINE[c,y]..}\n\
   LINE[x,{a,b,c..}]  means {LINE[x,a],LINE[x,b],LINE[x,c]..},\n\n\
where both x and y can be also a list.",
        "components wildcards elements Element",
        {{"key-strings",
          "\
The key-string is not case-sensitive. Available key-strings are:\n\n\
\"LENGTH\"       Number of components in the beam line.   No second argument.\n\
\"POSITION\"     Position of the component in the beam line.\n\
\"NAME\"         Name of the component.\n\
\"TYPE\"         The internal code-number of the type of the component.\n\
\"TYPENAME\"     The name of the type of the component.\n\
\"ELEMENT\"      The name of the corresponding element.\n\
\"DIR\"          The orientation of the component, +-1.\n\
\"S\"            The orbit length to the entrance from the beginning of the\n\
               beam line.\n\
\"LENG\"         Same as \"S\".\n\
\"GEO\"          Geometric-parameters at the entrance of the component,\n\
               {{GX, GY, GZ}, {GCHI1, GCHI2, GCHI3}}.\n\
\"OGEO\"          Geometric-parameters of the orbit at the entrance of the component,\n\
               {{OGX, OGY, OGZ}, {OCHI1, OCHI2, OCHI3}}.\n\
\"GX\", \"GY\", \"GZ\", \"GCHI1\", \"GCHI2\", \"GCHI3\"\n\
               Each geometrical parameter.\n\
\"OGX\", \"OGY\", \"OGZ\", \"OCHI1\", \"OCHI2\", \"OCHI3\"\n\
               Each geometrical parameter at the orbit.\n\  
\"GAMMA\"        Lorentz factor gamma.\n\
\"GAMMABETA\"    Lorentz factor gamma*beta = Sqrt[gamma^2 - 1].\n\
\"SIGab\"        Beam matrix component, where a and b are one of X, PX, \n\
               Y, PY, Z, DP.   If b is omitted it returns Sqrt[SIGaa] is\n\
               returned. Just \"SIG\" returns the entire 6 by 6 beam matrix.\n\
\"SIZEab\"       Beam matrix component calculated by (CODPLOT;EMIT),\n\
               where a and b are one of X, PX, Y, PY, Z, DP.\n\
               If b is omitted it returns Sqrt[SIZEaa] is returned.\n\
               Just \"SIZE\" returns the entire 6 by 6 beam matrix.\n\
\"MULT\"         The ordered number of each component belonging to the\n\
               same element, starting from 1.\n\
keyword        The value of the keyword of the component (see below).\n\
\"EXPAND\"       Distribute the value of the default-keywords and the \n\
               keywords used in the matching to all components in the\n\
               beam line.   No second argument.\n\n\
Setting by LINE[keyword,..] to the DEFAULT keyword for the FIRST component\n\
changes the current value of the corresponding element, because the value\n\
of an element is stored in the first component.",
          "components geometric-parameters elements keywords default-keyword",
          {}}}},

       {"Twiss",
        "\
Twiss[optical-function, component] returns the value of the optical-function\n\
at the entrance of component.   The values are those calculated by the last\n\
CALCULATE(CALC) or GO commands, or CalculateOptics function.\n\
   The second argument, component can be a name of component, a component\n\
number, or a list of them.   If the number has a fraction, the intermediate\n\
value in the component is calculated.\n\
   Twiss[\"ALL\",component] or Twiss[\"*\",component] returns all 27\n\
optical-functions at the entrance of component as a list:\n\n\
{AX, BX, NX, AY, BY, NY, EX, EPX, EY, EPY, R1, R2, R3, R4, DX, DPX, DY, DPY,\n\
 DZ, DDP, AZ, BZ, NZ, ZX, ZPX, ZY, ZPY},\n\n\
which can be directly used in CalculateOptics.   In the current version,\n\
however, parameters after AZ are uninteresting, because it always returns 1\n\
for BZ and zeros for the others.\n\
   Keywords \"PEX\", \"PEPX\", \"PEY\", \"PEPY\" return dispersions in the\n\
physical coordinate.\n\
   Keywords \"LENGTH\", \"GAMMA\", \"GAMMABETA\", \"S\", \"SIGab\" return\n\
the same results as for the function LINE.\n\
   The units of NX, NY, NZ are radian.",
        "optical-functions extended-Twiss-parameters CalculateOptics LINE",
          {}},

       {"FitValue",
        "\
Usage:\n\n\
(1) FitValue[component, function, {id_,dp_}, goal_, now_] := body\n\n\
modifies the goal of the matching of function at component.   The argument\n\
id_ is the orbit id for MatchingAmplitude or InitialOrbits. The\n\
argument dp_ receives the value of dp/p0.   The argument goal_ is the value\n\
of the goal of the matching set by matching-function-commands.  The argument\n\
now_ is the current value of function.\n\n\
Example: FitValue[\"$$$\", \"NX\", {_,dp_}, goal_, now_] := goal + dp * xix * 2 * Pi\n\n\
sets the tune NX to have chromaticity xix.\n\n\
(2) FitValue[component1, component2, function, {id_,dp_}, goal_, now1_, now2_] := body\n\n\
modifies the value of the function at component1 for a two-component matching.\n\
Component1 is assumed upstream in the beam line. The value of body is\n\
used in place of the current value, now1. The argument id_ is the orbit id\n\
for MatchingAmplitude or InitialOrbits. The argument dp_ receives the value of dp/p0.\n\
The argument goal_ is the value of the goal of the matching set by\n\
matching-function-commands.  The argument now1 and now2 are the current\n\
values of the function at component1 and component2, respectively.\n\n\
Example: FitValue[\"QF1\", \"QF2\", \"NX\", _, goal_, now1_, now2_] := \n\
   If[Abs[now2-(now1+goal)] < 0.01*2*Pi , Null, now1]\n\n\
sets the tune difference between QF1 and QF2 gaol +- 0.01.\n\n\
   During the matching process the matching routine calls FitValue with\n\
arguments, then if body returns a number, it overrides the goal give by\n\
matching-function-commands.   If body returns Null, the matching of function\n\
is ignored.\n\
   The matching-function-command is necessary besides FitValue to perform\n\
the matching.   Only defining FitValue does not do the matching.\n\
   FitValue is cleared by USE. It is hidden by VISIT and restored by BYE",
        "matching-function-commmands off-momentum-matching",
        {}},

       {"VariableRange",
        "\
Usage:   VariableRange[element, keyword ,v_] := expression\n\n\
where the current value of the element:keyword is passed in v_, and \n\
expression should give False when the value is out of range.\n\n\
Example: VariableRange[\"QF\",\"ROTATE\",v_]:= -0.1 < v < 0.1;\n\n\
This restricts the range of the rotation angle of QF within +-100 mrad.\n\n\
         VariableRange[_,\"ROTATE\",v_]:= -0.1 < v < 0.1;\n\n\
This specifies the same for all elements.\n\
   The expression can also return the range as a list {vmin, vmax}, which\n\
may give more chance of solution-finding for the matching routine.\n\
   VarableRange only acts for variables used in the matching with the\n\
FREE command.",
        "FREE set-value-of-element",
        {}},

       {"VariableWeight",
        "\
Usage:   VariableWeight[element, keyword ,v_] := expression\n\n\
where the default weight for matching with element:keyword is passed in v_, and \n\
expression should return a modified value of weight. If non-real is returned,\n\
the default weight is used.\n\n\
Example: VariableWeight[\"QF\",\"K1\",v_]:= 0.1*v;\n\n\
reduces the weight of QF1:K1 to 1/10 of the default value.\n\n\
   The weight also affects the step size of the numerical derivative\n\
of the response. A smaller weight makes the step size larger.\n\n\
   VarableWeight only acts for variables used in the matching with the\n\
FREE command.",
        "FREE set-value-of-element",
        {}},

       {"FitWeight",
        "\
A defined function to modify the weight of matching of particular function\n\
at particular component with particular momentum offset.\n\n\
Usage:   FitWeight[component, function, {id_,dp_}, default_] := weight;\n\n\
where\n\
component  is the name of the location of the fit, like \"QF.2\", etc.\n\
function   is the name of the matching-function, like \"BX\", \"LENG\", etc.\n\
id_        is the id number of the orbit for MatchingAmplitude or \n\
           InitialOrbits.\n\
dp_        is a variable to receive the momentum deviation of the fit.\n\
default_   is a variable to receive the default fit weight.\n\
weight     is an expression which returns the desired weight.\n\n\
Example: FitWeight[\"$$$\",\"LENG\",{_,dp_},ws_]:=ws*10;\n\n\
makes the weight of LENG at $$$ 10 times (100 times in MatchingResidual) \n\
bigger than the default.",
        "matching-function-commands special-variables MatchingResidual",
        {}},

       {"Emittance",
        "\
Emittance[option] returns a set of rules as \n\n\
   {keyword1->value1, keyword2->value2, ..} .\n\n\
Its options and default values are Matrix(False), Orbit(False), \n\
OneTurnInformation(False), Emittance(True), ExpandElementValues(True),\n\
SaveEMIT(False), InitialOrbit(Null), InitialBeamMatrix(Null), and Output(0).\n\n\
If Emittance->False is specified, the resulting keywords are\n\n\
Stable                  True if all modes are stable and the closed orbit\n\
                        is found.\n\
Tunes                   {nux, nuy, nuz} .\n\
EnergyLossU0\n\
RfVoltageVc\n\
EquilibriumPosition     dz in meter.\n\
MomentumCompaction\n\
OrbitDilation           ds in meter.\n\
BucketHeight            dV/E0\n\
HarmonicNumber\n\
OrbitAtExit             physical c.o.d. at the end of line.\n\n\
If None of the options is given, the following keywords are added:\n\n\
DampingRate             {T0/taux, T0/tauy, T0/tauz}\n\
Emittances              {emitx, emity, emitz}\n\
MomentumSpread          sigma p/p0\n\
BunchLength             sigma_z\n\ 
TuneShiftByRadiation    {dnux, dnuy, dnuz}\n\n\
If OneTurnInformation->True, or Orbit->True, or Matrix->True, the followings\n\
are added.\n\n\
OrbitAtEntrance         physical c.o.d. at the entrance of the ring.\n\
OneTurnTransferMatrix   symplectic part of the one-turn transfer matrix.\n\
OneTurnDampingMatrix    deviation of transfer matrix due to radiation.\n\
NormalCoordinates       conversion matrix from physical to normal coords.\n\
OneTurnExcitation       excitation matrix by radiation.\n\
EquilibriumBeamMatrix   equilibrium beam matrix.\n\
ExtendedTwissParameters list of rules giving the extended Twiss parameters\n\
                        at the entrance of the ring.\n\n\
If Orbit->True or Matrix->True,\n\n\
ClosedOrbit             List of physical closed orbit at every element in the\n\
			ring.\n\n\
joins.\n\n\
If Matrix->True,\n\n\
TransferMatrices        List of physical transfer matrix from the beginning\n\
                        of the beam line to all elements.\n\
IntrabeamExcitation     List of the change of the 6 x 6 beam matrix due to\n\
                        the intrabeam scattering (only when INTRA),\n\
                        converted to the beginning of the beam line.\n\
join the result.\n\n\
   If the flag TRPT or NORING is set, the calculation assumes a transport line\n\
so that several quantities such as damping rate, eigen modes, equilibrium beam\n\
matrix, etc. are meaningless. Use RING or NOTRPT for such calculation.\n\
In the case of TRPT or NORING, the incoming beam envelope must be given by\n\
the option InitialBeamMatrix with a 6 x 6 symmetric matrix.  TRPT is useful for\n\
calculation of space charge and intrabeam in a transport line.\n\
   Please do not forget to put semicolon at the end of Emittance[] function,\n\
otherwise the output will be huge especially when Orbit or Matrix is True.\n\n\
If ExpandElementValues->False, calculation is made using the present\n\
values of each component (i.e., including machine errors).\n\n\
If SaveEMIT->True, the calculated values of emittances are stored in\n\
EMITX, EMITY, EMITZ variables.   The default is SaveEMIT->False.\n\n\
InitialOrbit->{x0,px0,y0,py0,z0,dp0/p0} specifies the incoming orbit\n\
which is valid when NOCOD is set. The option Output->filenum enables the\n\
print out of EMITTANCE(EMIT) to filnum.",
        "EMITTANCE(EMIT) SymplecticJ flags: COD",
        {}},

       {"TrackParticles",
        "\
TrackParticles[beam, destination-component, nbegin, nend]\n\n\
returns a beam after the tracking at the entrance of the destination-\n\
component.   The destination can be specified by the name of the component\n\
or by a number obtained by LINE[\"POSITION\", component].   \n\
If destination is omitted, the end of the line is assumed.\n\n\
The argument nbegin is the initial turn number to be passed to tracking to indicate\n\
it is in the n-th turn. The number is increased by 1 when it passes the end of beam line.\n\
If nbegin is omitted, 1 is assumed.\n\n\
The argument nend is the last turn number. The default is nbegin.\n\n\
   The variable beam and also the result of TrackParticles are lists of the\n\
form \n\n\
   {location, coordinates}\n\n\
where location is the position-number of the starting point.  If location is\n\
same as or in the downstream of destination, the tracking is done by \n\
folding across the beginning of the beam line. The coordinates are in a list of {7, np}\n\
form, where np is the number of particles. The first 6 elements of\n\
coordinates specifies\n\n\
   {x, px/p0, y, py/p0, z, dp/p0}\n\n\
in this order.   The {7, i} is the flag which is True(==1) when the \n\
particle is alive, and False(==0) when lost.\n\n\
   When a flag RADLIGHT is on, TrackParticles returns the trajectories of\n\
particles which are used to calculate the radiation fields.   See\n\
RadiationField and RadiationSpectrum.\n\n\
When PHOTONS is ON (default is OFF), TrackParticles generates a list of all\n\
photons radiated through the tracking. The list is assigned to a symbol PhotonList.",
        "components LINE PHOTONS PhotonList RADLIGHT TouschekLifetime WakeFunction\n\
SurvivedParticles",
        {}},

       {"SurvivedParticles",
"SurvivedParticeles[x]\n\n\
returns the list of 6 coordinates and the flag of the survivied particles in x.\n\
The form of x is {x, px/p0, y, py/p0, z, dp/p0, flag}, where each is a list of\n\
length of the number of particlse. If all particles are lost, it is a list of\n\
seven null lists.",
         "TrackParticles",
         {}},

       {"TouschekLifetime",
"TouschekLifetime interpolates the data calculated by EMIT or Emittance[].\n\
There are three ways of usage:\n\n\
   TouschekLifetime[Infinity, Infinity, nz]: Touschek lifetime in seconds\n\
     with momentum aperture nz * SIGE.\n\n\
   TouschekLifetime[nx, Infinity, nz]: Touschek lifetime in seconds\n\
     with acceptance 2Jx/(nx * (EMITX+EMITY)) + 2Jz/(nz * EMITZ) < 1.\n\n\
   TouschekLifetime[Infinity, ny, nz]: Touschek lifetime in seconds\n\
     with acceptance 2Jy/(ny * (EMITX+EMITY)) + 2Jz/(nz * EMITZ) < 1.\n\n\
EMIT or Emittance[] with INTRA must precede TouschekLifetime.",
         "EMITTANCE(EMIT) Emittance[] INTRA",
         {}},

       {"SynchroBetaEmittance",
        "\
SynchroBetaEmittance calculates equilibrium emittance under influence of \n\
synchrotron motion and chromaticity.\n\n\
Usage:\n\n\
   SynchroBetaEmittance[{nus0, nus1, dnus},options]\n\n\
or\n\n\
   SynchroBetaEmittance[nus0,options]\n\n\
where nus0, nus1, and dnus are the starting, ending and step size of\n\
synchrotron tune, respectively. If only nus0 is given, calculation is done\n\
only for nus0. The returned value is a list:\n\n\
   {{nus, emitx, emity, conv}, ... }\n\n\
where nus, emitx, emity, conv are the synchrotron tune, equilibrium horizontal\n\
and vertical emittance, and the convergence. When conv is negative, calculation\n\
failed to converge, and the returned emittances are not reliable.\n\n\
Options               Type        Default     Meaning\n\
-----------------------------------------------------------\n\
AzimuthalModes        Real        9           Number of azimuthal modes",
         "SYNCHTOBETA(SYNCHROB)",
         {}},

       {"AccelerateParticles",
        "\
AccelerateParticles does TrackParticles with acceleration in a ring for a given\n\
number of turns. The adiabatic damping is automatically taken cared.\n\n\
Usage:    AccelerateParticles[beam_,mom_,{n_Symbol,nturn_},opt___]\n\n\
where beam is a list of beam coordinates in the same format for TrackParticles.\n\
mom is an expression to determine MOMENTUM in each turn as a function of\n\
turn number n. nturn is the total number of turns. An option Synchronize\n\
specifies a routine to be executed at every turn of the tracking (e.g.\n\
changing voltages and magnet settings, or storing the results.)\n\n\
Example:\n\
  AccelerateParticles[\n\
    beam,\n\
    Which[\n\
      n < 100,  1e9,\n\
      n <= 200, 1e9 + (n - 100) * 1e7,\n\
      True, 2e9],\n\
    {n, 300},\n\
    Synchronize :> ((\n\
      d = {d, MOMENTUM/1e9 * (1 + #2[[2,6,1]])})&)];",
         "TrackParticles",
           {}},

       {"OrbitGeo",
        "\
OrbitGeo[location] returns the geometry {GX, GY, GZ}\n\
of the current (not design) orbit.",
        "GEO GeoBase",
         {}},

       {"GeoBase",
        "\
GeoBase[{chi1, chi2, chi3}] converts the rotation angles\n\
of the coordinate base vectors to a transformation\n\
matrix {{x_gx,x_gy,x_gz}, {y_gx,y_gy,y_gz}, {z_gx,z_gy,z_gz}}",
         "GEO OrbitGeo",
         {}},

       RADLIGHT$Message="\
To calculate the field of the synchrotron radiation from particles,\n\
first record trajectories of particles.   This is done by the function\n\
TrackParticles with a new flag RADLIGHT on.   When RADLIGHT is on,\n\
TrackParticles returns a list\n\n\
   {beam, trajectory} ,\n\n\
where beam is a list as {location, coordinates}, and trajectory is a list\n\n\
   { {t1 .. tm}, {x1 ..xm}, {y1 .. ym}, {z1 .. zm} }, ..\n\n\
where {t,x,y,z}_i is the coordinates of the particle at i-th point in the\n\
trajectory.   The origin and the direction of the spatial coordinates are\n\
the same as GEO coordinat {GX, GY, GZ}.   One can track many particles at the\n\
same time by TrackParticles, so the trajectory has the dimensions {np, m},\n\
where np is the number of particles.\n\n\
   After the trajectory is obtained, one can calculate the field in time domain\n\
at any observation point.   This is done by the function RadiationFiled as\n\n\
   field = RadiationField[ trajectory[[i]], obs];\n\n\
where trajectory[[i]] is the trajectory of the i-th particle, and obs is the\n\
spatial coordinate of the observation point in the GEO coordinate.   The \n\
output field is a list\n\n\
   { {tau1 .. taum},\n\
     {Ex1 .. Exm}, {Ey1 .. Eym}, {Ez1 .. Ezm},\n\
     {Hx1 .. Hxm}, {Hy1 .. Hym}, {Hz1 .. Hzm},\n\
     {Sx1 .. Sxm}, {Sy1 .. Sym}, {Sz1 .. Hzm} }\n\n\
where H = (n x E)/(c mu0) and S = E x H , and tau is the observation time.\n\
   RadiationField uses the Feynmann-Heviside formula\n\n\
   E = (mu0 e*CHARGE/4pi) (c^2n/R^2 + R/c d(c^2n/R^2)/dt + d^2n/dt^2) ,\n\n\
where n and R are the direction vector and the distance from the electron\n\
at the retarded time to an observation point.  \n\
   The derivatives in the above formula is calculated using the spline\n\
interpolation.\n\n\
   Next one can calculate the spectrum of the field by RadiationSpectrum as\n\n\
   spect = RadiationSpectrum[ {field[[1]], field[[k]]},\n\
        {lambda1, lambda2, dlambda} ] ,\n\n\
where filed[[k]] is one of the fields calculated by RadiationField.   The range\n\
of the wavelength is given as a list above.   The output spectrum spect is a\n\
list as\n\n\
   { {k1 .. kk}, {c1 .. ck}, {s1 .. sk} } ,\n\n\
where k1 .. kk is the wave number k = omega/c, c1 .. ck and s1 .. sk are the\n\
cosine and sine integrals of the field in tau1 .. taum , i.e.,\n\n\
   ck + I sk = Integrate[ field[tau] Exp[I c k tau] dtau] .\n\n\
   An example is seen in /users/oide/WORK/oldsad/sad/examples.sad .";

       {"RadiationField",
        RADLIGHT$Message,
        "TrackParticles Flags:RADLIGHT",
        {}},

       {"RadiationSpectrum",
        RADLIGHT$Message,
        "TrackParticles Flags:RADLIGHT",
        {}},

       {"WakeFunction",
         "\
   WakeFunction[Longitudinal, comp]={{z1, wl1}, ..., {zn, wln}};\n\
   WakeFunction[Transverse,   comp]={{z1, wt1}, ..., {zn, wtn}};\n\n\
specify logitudinal and transverse dipole wake functions at a component comp\n\
(string).  Each functions is a list of {z, w} where z is the distance (z>=0)\n\
and w is the value of the wake, in the unit of either V/C or V/C/m.\n\
   The wake functons are applied at the componet comp, giving kicks to each\n\
orbit whose initial conditions are given by InitialOrbits. The sufficient\n\
number of orbits depends on the situation.\n\
   WakeFunction is valid only when TRPT and INS, and also either TWAKE or\n\
LWAKE is ON.\n\
   For tracking, it is only valid in TrackParticles.",
         "TrackParticles Flags:TRPT INS TWAKE LWAKE",
         {}},

       {"DynamicApertureSurvey",
        "\
Usage: DynamicApertureSurvey[range,nturn,options]\n\n\
where\n\n\
range: a list of {xrange,yrange,zrange}, with\n\
       xrange: {xmin, xmax},\n\
       yrange: {ymin, ymax},\n\
       zrange: {zmin, zmax},\n\
       and for the horizontal plane, specified by the Axes option, \n\
       the corresponding range must be given as {v1, ..., vn}.\n\
       These values are the initial amplitude divided by the equilibrium \n\
       values, i.e., Sqrt[2Jx,y/(EMITX+EMITY)], Sqrt[2Jz/EMITZ].\n\
       See EMITTANCE(EMIT) command or Emittance function.\n\
nturn: number of turns to track.\n\
options: Output->lfn : output to the unit lfn (see OpenWrite).\n\
         Axes->axes : one of \"XY\", \"XZ\", \"YX\", \"YZ\", \"ZX\", \"ZY\",\n\
          where the first character specifies the horizontal axis, and\n\
          the second the vertical, respectively. The default is \"ZX\".\n\
         ReferenceOrbit->{x0, px0, y0, py0, z0, dp0} : Survey is done around\n\
          this orbit.\n\
         PhaseX->phix : The initial amplitude is rotated in (X, PX) phase space\n\
          by phix. Default is zero.\n\
         PhaseY->phiy : The initial amplitude is rotated in (Y, PY) phase space\n\
          by phiy. Default is zero.\n\
         PhaseZ->phiz : The initial amplitude is rotated in (Z, PZ) phase space\n\
          by phiz. Default is -Pi/2.\n\
         ExpandElementValues->True(default) : set the values of the components\n\
          according to the values of elements.  Machine errors may be reset.\n\
          See machine-error-commands, CALCULATE(CALC).\n\n\
   DynamicApertureSurvey returns the result as a list:\n\n\
   {score,{{{xmin, xmax},{ymin, ymax},{z1, z2, .., zn}},\n\
           {{z1,score1,{turn1_1,..,turn1_50}},..,\n\
            {zn,scoren,{turnn_1,..,turnn_50}}}}} ,\n\n\
where score = Sum[scorei,{i,n}], scorei is the \"score\" of i-th momentum,\n\
and turni_j is the lossed turn of the particle with  i-th momentum and\n\
j-th intial amplitude.\n\
   DynamicApertureSurvey tracks number of particles with different initial\n\
conditions in the range given by range.   It outputs a z-x diagram of the \n\
dynamic aperture of the ring.   Fifty one initial conditions are chosen\n\
in the range x-range for each point of z-range.  The initial y-amplitude is\n\
linearly dependent on the x-amplitude.   It tracks from xmax to downward for\n\
each z-amplitude zn, until the particles turns nturn with successive \n\
DAPWIDTH x-amplitudes.   The default DAPWIDTH is 7.\n\
  DynamicApertureSurvey does parallel processing up to NPARA processes.",
        "NPARA",
        {}},

       {"BeamMatrix",
        "\
BeamMatrix[i] returns a 6 by 6 beam-matrix (i.e., <x_k x_l>) at location i.\n\
The index i can have a fraction to specify intermediate numbers (see LINE\n\
or Twiss).   The calculation is based on linear 4 by 5 calculation in the\n\
present version, so the z-direction is meaningless.  Flag GAUSS affects the\n\
result.",
        "LINE Twiss Flags:GAUSS",
        {}},

       {"SymplecticJ",
        "\
SymplecticJ[n] returns a n by n symplectic matrix like\n\n\
   {{0, 1, ...}, {-1, 0, ...}, {0, 0, 0, 1, ...}, {0, 0, -1, 0, ...}, ...} .",
        "",
        {}}

      }]
    }}]},

   {"example",
    Module[{f=OpenRead[ExamplesDirectory//"design_example.sad"],s="",l},
      If[f<=>$Failed,
        While[l=ReadString[f];l<=>EndOfFile,
          s=s//"\n"//l];
        Close[f];
        s,
        ""]],
    "",
    {}}
   }]
}});

Protect[Help$Messages]
