!Help$Update="$Date: 2/25/2019 18:00:00  $"[8,18];
Help$Update=("$Date: "//DateString[][1,10]//" $")[8,17];
Help$Version=$Version;

N$pole[2]="dipole";
N$pole[4]="quadrupole";
N$pole[6]="sextupole";
N$pole[8]="octupole";
N$pole[10]="decapole";
N$pole[12]="dodecapole";
N$pole[n_]:=StandardForm[n//"-pole"];
N$deriv[0]="";
N$deriv[1]="'";
N$deriv[2]="''";
N$deriv[3]="'''";
N$deriv[n_]:=StandardForm["^{("//n//")}"];

Help$Messages=(Print["SAD/FFS Help Update: ",Help$Update];{
{" ",
 "\
Usage: Help [item [subitem ...]]\n\n\
displays (un)helpful information on the input item. \n\n\
>>> Wildcards or abbreviations can be used to specify the item. \n\
>>> Help prompts sub items or items on lower levels. \n\
>>> At the prompt \".. Topic?\", type sufficient number of <Return>s to exit.\n\
>>> Type ?<Return> to see the information of the current item.\n\n\
   The FFS commands are shown in uppercases. The minimum abbreviated form \n\
of each command is enclosed in (). Down to that form each command can be\n\
shorten. The optional arguments for the commands are usually enclosed in\n\
[].\n\
   These messages are also available at http://acc-physics.kek.jp/SAD/SADHelp.HTML.",
  "",
 Sort[{

{"data-structure",
   "\
All data and \"programs\" in SAD Script are expressed either by an atom or a list-structure:\n\n\
   head[body1 [,body2...]]\n\n\
where head and body1... are atom or list-structure. Defined atoms are:\n\t\n\
Real      a real number\n\
Symbol    a symbol\n\
String    a character-string\n\
Pattern   a pattern structure for argument matching\t\n\n\
Currently the lengths of a list-structure, a character-string, and the name of a symbol are limited to 2^31-1. A real number has an accuracy of 8 bytes.",
  "character-string pattern",
   Sort[{
     {"Head",
       "\
Head[f] takes the head of an expression f.",
       "",
       {}},

     {"List",
       "\
 List is a special symbol to be the head of generic list-structure.\n\
 List[a, b, c, ...] is represented as {a, b, c, ...}.\n\
 A list is also used to represent a mathematical vector and matrices.\n\
 Most of mathematical functions are operated at each element of a list.",
       "",
       {}},

     {"Part",
       "\
  Part[f, a [,b ,...]] ===> f[[a, [,b ...]]]\n\n\
takes the a-th element of structure f. f[[a, b]] is equivalent to f[[a]][[b]].\n\
 If a is zero, it takes the head of f.\n\
 if a is negative, f[[a]] os equivalent to f[[Length[f] + 1 + a]].\n\
 If a is a list of Reals {a1, a2, ...}, f[[a]] returns {f[[a1]], f[[a2]], ...}.\n\
 If a is Null, f[[,b]] is returns {f[[1,a]], ..., f[[Length[f], b]]}.",
       "Length Head Extract",
       {}},

     {"Length",
       "\
 Length[f] returns the number of elements in the body of a structure f.",
       "",
       {}},

     {"Extract",
       "\
   Extract[f, part [,head]]\n\n\
takes elements specified by part, which is a list of indices or Null. Optional head is applied at each element before evaluation.\n\n\
Example: Extract[{a,b,c,d,e},{3}]       returns c\n\
         Extract[{a,b,c,d,e},{3,4}]     is an error\n\
         Extract[{a,b,c,d,e},{{3},{4}}] returns {c,d}\n\
         Extract[Hold[{a,b,c,d,e}],{1,3}, Hold] returns Hold[c]",
       "Part",
       {}}

   }]},

   {"beam-line",
     "\
 A beam line is defined in the MAIN level by LINE command as:\n\n\
   LINE a = ( [n1*][-]l1 [ [n2*]l2 ...] ) [b = ( ... )];\n\n\
where l1, l2 are either an element or a line. n1, n2 are positive integers to repeat the same element. An optional negative sign in fromt of element means the negative orientation of the element of the line. A negative orientation of a line is inherited by its elements.\n\
 The first element of a beam line must be a MARK element, if it is used by FFS, USE, VISIT.\n\
 Please do not confuse the LINE command in the MAIN level with the LINE function in FFS.\n\
 A beam line can be accessed within FFS via beam-line-functions as shown below.",
     "elements orientation-of-an-element USE VISIT",
     Sort[{
       {"orientation-of-an-element",
         "\
 An element with negative orientation means a reversal of the element along the z-axis. Thus all magnets except for a solenoid does not change the polarity. A solenoid changes the polarity. An RF cavity should change, however, it does not in the current implementation. The edge angles and fringe parameters of the entrance and the exit swap.\n\
 AX, AY, AZ, EPX, EPY, ZPX, ZPY, R2, R3 of a MARK element are reversed.\n\
 The orientation is printed out by DISP. It can be accessed by LINE[\"DIR\"] . ",
         "beam-line BeamLine LINE",
         {}},

       {"beam-line-functions",
      "\
Functions/objects to construct/edit beam lines and elements in FFS.",
      "",
      Sort[
      {{"BeamLine",
       "\
Usage: BeamLine[e1, e2, ...];\n\n\
where e1, e2 has a form of\n\n\
   [ - ][ n* ] x ,\n\n\
with x being one of\n\n\
1) a name (either a symbol or a character string) of an element defined in MAIN.\n\
2) a name (either a symbol or a character string) of a LINE defined in MAIN.\n\
3) a BeamLine object.\n\n\
An optional negative sign specifies the direction and a number n the repetition number in the same way as MAIN. A BeamLine object is automatically expanded to the lowest level whenever it is evaluated. Editing of BeamLine can be done using any List-handling functions such as Join, Insert, Delete, etc. of FFS.\n\n\
 A BeamLine object can be used for FFS calculation when it is used as the\n\
argument of USE or VISIT commands:\n\n\
Examples:\n\
1) USE BeamLine[IP,QF,QD]\n\
2) aaa=ExtractBeamLine[];\n\
   USE Join[aaa,-aaa]\n\n\
 In these cases the new beam line becomes a new LINE in the MAIN level, with a name which is created automatically.",
        "ExtractBeamLine PrintBeamLine WriteBeamLine orientation-of-an-element USE VISIT",
        {}},

       {"BeamLineName",
        "\
BeamLineName[] returns the name of the current beam line. If a BeamLine object is used by USE or VISIT, the new beam line becomes a new LINE in the MAIN level, with a name which is created automatically.",
        "",
        {}},

       {"ExtractBeamLine",
        "\
Usage: ExtractBeamLine[line]\n\n\
returns a BeamLine object which represents the expanded form of line which has been defined in MAIN. If line is omitted, the current line is assumed.",
        "BeamLine PrintBeamLine WriteBeamLine USE VISIT",
        {}},

       {"WriteBeamLine",
        "\
Usage: WriteBeamLine[f, b1,.. ,option]\n\n\
writes the BeamLine b1,.. to file f. If b1.. is omitted the current beam line is assumed. If Format->\"MAIN\" is given, it writes in the MAIN-input format. If Name->{name1,..} is given, names of BeamLines are also written. The number of Name must be not smaller than number of BeamLines.",
        "BeamLine ExtractBeamLine PrintBeamLine USE VISIT",
        {}},

       {"PrintBeamLine",
        "\
Usage: PrintBeamLine[b1,.. ,option]\n\n\
writes the BeamLine b1,.. to stdout. If b1.. is omitted the current beam line is assumed. If Format->\"MAIN\" is given, it writes in the MAIN-input format. If Name->{name1,..} is given, names of BeamLines are also written. The number of Name must be not smaller than number of BeamLines.",
        "BeamLine ExtractBeamLine WriteBeamLine USE VISIT",
        {}}}]}

       }]},

   {"BEAMSIZE(BEAM)",
   "Calculate the beam size with the current Twiss parameters. The calculation is in 5D and not correct if the synchrotron motion is significant. Use EMITTANCE(EMIT) with CODPLOT for a 6D calculation.",
   "DISPLAY(DISP) EMITTANCE(EMIT) CODPLOT",
   {}},

   {"GO",
   "\
Usage: GO [[NO]EXPAND]\n\n\
Does matching for fitting conditions given by matching-function-commands with variables specified by FREE.\n\n\
If an option EXPAND is given (default), it expands the beam line before the calculation. If NOEXPAND is given, it avoids any expansion."//
   (FFSGO$Message="\
   FFS[\"CAL\"] and FFS[\"GO\"] returns the result as a list, whose format is\n\n\
   {dp, kind, reslist, function-values},\n\n\
where\t\n\n\
dp:        a list contains dp/p0 .\n\
kind:      a list of kind of the orbit (usually 0, but 1 to 6 for the finite amplitude matching, see MatchingAmplitude).\n\
reslist:   a list of {residual, xstab, ystab}, where\t\n\
       residual: matching residual,\n\
       xstab:    True when the matrix is stable in X,\n\
       ystab:    True when the matrix is stable in Y, for each orbit.\n\n\
Above are lists with length nf (== number of orbits).\n\n\
function-values: a list of length nc (== number of calculated items). Each element has the form:\n\n\
       {component1, component2, function, list-of-values},\n\n\
       where\n\n\
       component1, component2: fit locations (see FIT).\n\
       function: name of the function (see matching-function-commands).\n\
       list-of-values: list of the value of the function for each orbit Length nf.\n\
       The central orbit comes at the Floor[(n+1)/2]-th element."),
   "FIT SHOW matching-function-commands off-momentum-matching FREE FIX VARIABLES(VAR) COUPLE(COUP) ATTRIBUTE(ATTR) CAL VARY SHOW CONV CONVERGENCE MatchingResidual MatchingAmplitude FitFunction FFS OptimizeOptics",
   {}},

   {"EXPAND",
     "\
 EXPAND distributes all variable keys to each corresponding components. Individual deviations (machine errors) are cleared.",
     "GO CAL EMIT",
     {}},

  {"CALCULATE(CAL)",
   "\
Usage: (1) CAL [[NO]EXPAND]]\n\
       (2) CAL matching-function1[-] [matching-function2[-]..]\n\
 \n\
(1) With no argument or with an option [NO]EXPAND, calculates the optics and the matching-functions using the current values of the components. It prints out the values of the matching-functions specified either by the matching-function-commands or the second usage of CAL, as described below. If an option EXPAND is given(default), it expands the beam line before the calculation. If NOEXPAND is given, it calculates without any expansion."//
    FFSGO$Message//"\n\n\
(2) With matching-function names, sets the matching-functions at the current fit point to be printed out after calculation. If the matching-function is followed by a minus sign, it suppresses the print-out.\n\\n\
Example: CALC BX BY CAL",
   "GO DISPLAY(DISP) COUPLE(COUP) ATTRIBUTE(ATTR) SHOW FIT matching-function-commands EXPAND CONV CONVERGENCE MatchingResidual FFS",
    {}},

  {"DISPLAY(DISP)",
   "Usage: DISP_LAY [keywords] [pattern-string] [region]\n\n\
Displays values of various optical-/geometric-functions at the components given by the pattern-string in the region (see region) in the current beam line. It has several display modes specified by the keywords. As the default, it displays AX, BX, NX, EX, EPX, AY, BY, NY, EY, EPY, LENG, the length and the value of the default-keyword of the component. Each line refers to the entrance of each component of the line. The end of the beam line has the name \"$$$\". The first component can be specified by \"^^^\".\n\
   DISP suspends the output to the terminal at every 66 lines, asking (q_uit, c_ontinue, a_ll)?. The further output depends on the first character of the answer from the terminal input. This dialog is suppressed by specifying ALL.\n\
   DISP does not calculate the functions to be displayed, so CALCULATE(CALC) or GO is necessary whenever values of components are updated.",
   "TYPE(T) optical-functions geometric-functions",
    Sort[
    {{"GEOMETRY(G)",
      "DISP G displays geometric information of the beam line. It shows the geometry of the coordinate.",
      "geometric-functions matching-function-commands OGEOMETRY(OG)",
      {}},

      {"GAMMA(GA)",
       "DISP GA displays gamma functions for x and y, instead of dispersions, as well as gamma*L, which is nealry equal to the natural chromaticity.",
       "",
       {}},

      {"OGEOMETRY(OG)",
      "DISP OG displays geometric information at the orbit.",
      "geometric-functions matching-function-commands GEOMETRY(G)",
      {}},
 
     {"ORBIT(O)",
      "\
DISP O displays the orbits DX, DPX, DY, DPY together with the other \n\
optical-functions.",
      "optical-functions matching-function-commands",
      {}},

     {"RMATRIX(R)",
      "DISP R displays the components of the x-y coupling matrix R together with the 1D optical parameters. See x-y-coupling.",
      "x-y-coupling optical-functions matching-function-commands",
      {}},

     {"PHYSICAL(P)",
      "DISP P displays the physical dispersions PEX, PEPX, PEY, PEP, together with the 1D optical parameters.",
      "optical-functions matching-function-commands",
      {}},

     {"BEAM(B)",
      "DISP B displays the beam sizes and the projected Twiss parameters calculated either by Twiss parameters or the EMIT command with the CODPLOT flag.\n\n\
Example: EMITX=...; EMITY=...;DP=...; \n\
         BEAMSIZE(BEAM)\n\
         DISP B",
      "BEAMSIZE(BEAM) EMITTANCE(EMIT) CODPLOT GAUSS UNIFORM special-variables EMITX EMITY DP",
      {}},

     {"ACCELERATION(A)",
      "\
DISP A displays the nominal energy, energy deviation(DDP), longitudinal position(z), and emittances for a transport line with accelerating cavities. The flag TRPT must be on.",
      "TRPT RING elements CAVI special-variables EMITX EMITY DP",
      {}},

     {"DUMPOPTICS(D)",
      "DISP D displays all matching-functions in one line suitable to be read by a spread-sheet program.",
      "optical-functions geometric-functions matching-function-commands",
      {}},

      {"Z",
       "DISP Z displays muatching functions related to the Z plane: AZ BZ NZ DZ DDP ZX ZPX ZY ZPY GMZ , which are obtained by CAL/GO with CALC6D.",
      "extended-Twiss-parameters CALC6D CALC4D",
      {}},

      {"REFERENCE(RE)",
        "Specify the reference optics to be displayed.",
        "reference-optics REFERENCE(REF) DISPLAY(DISP) DREFERENCE(DRE) Twiss OpticsPlot",
        {}},

      {"DREFERENCE(DRE)",
        "Display the difference between the reference optics. (beta - betaR)/betaR are displayed for BX, BY, BZ.",
        "reference-optics REFERENCE(REF) DISPLAY(DISP) REFERENCE(RE) Twiss OpticsPlot",
        {}},

     {"region",
      "Region for DISPLAY(DISP) is specified as \n\n\
        DISP .... begin [end] \n\n\
with begin and end having the form name[.order][{+-}offset], or the component number (see components).\n\n\
Example:   DISP ... QF.2-10 QD+5\n\
           DISP ... 100 200\n\n\
displays functions starting at 10 elements upstream from the entrance of the second QF through 5 elements downstream from the entrance of the first QD. The region for DISP is kept after once set. It is shown in the second part of the prompt when FFSPRMPT is ON, and also seen by the STATUS(STAT) command.\n\
   If begin points to a component after end, DISP displays from begin to $$$, then from ^^^ to end.\n\
   ALL can be specified before the region. In such a case, the dialog for the output control is suppressed.\n\
   The components which match the pattern-string in DISP are only chosen in the current region.",
      "ALL pattern-string components STATUS(STAT)",
      {}},

     {"ALL",
      "\
ALL is a word to choose the entire beam line for the region to be displayed. If ALL is given, a dialog at every 66 lines to control the output to the terminal is suppressed. Thus \"DISP ALL e1 e2\" works to suppress the dialog for the output region e1 from e2.",
      "region pattern-string",
      {}},

     {"pattern-string",
      "The components in the current region can be selectively displayed by the DISP command using the pattern-string. The pattern-string is a character string involving the wildcards to match the name of the components. Note that the components are chosen in the current region, and the keyword ALL is necessary to extend it to the entire beam line.",
      "DISP wildcards components region ALL",
      {}}}]
  },

  {"STOP",
   "Exits FFS and returns to SAD/MAIN level, with saving the values of the elements.",
   "QUIT SAVE ABORT USE VISIT BYE",
   {}},

  {"QUIT",
   "Exits FFS and return to SAD/MAIN level, without saving the values of the elements.",
   "STOP SAVE ABORT USE VISIT BYE",
   {}},

  {"ABORT",
   "Terminates SAD immediately.",
   "STOP QUIT SAVE USE VISIT BYE",
   {}},

   {"SUSPEND(SUSP)",
   "Suspend reading from the current input stream, and wait for input from the console. Resumes by RESUME(RES)",
   "RESUME(RES) END",
     {}},

   {"RENUMBER(RENUM)",
   "RENUM comp renumbers the component number starting from a component comp.",
   "components",
     {}},

   {"RESUME(RES)",
   "Resumes reading from the previous input stream suspended by SUSPEND(SUSP) or END.",
   "SUSPEND(SUSP) END",
     {}},

  {"SAVE",
   "Usage: SAVE [element-pattern]\n\n\
saves the values of the elements. What are saved are the value of the default keyword of all elements, the values of the non-default keywords which have been changed manually or by the matching. If ALL is given it resets all keywords. If element-pattern is given, it is only limited to the elements which match the pattern, otherwise all elements are saved.",
   "RESET USE VISIT BYE STOP QUIT wildcards",
   {}},

  {"RESET",
   "Usage: RESET [ALL] [element-pattern]\n\n\
restores the value of the elements. What are restored are the value of the default keyword of all elements, the values of the non-default keywords which have been changed manually or by the matching. If ALL is given, it resets all keywords. If element-pattern is given, reset is limited to the elements which match the pattern.",
   "SAVE USE VISIT wildcards RECOVER(REC)",
   {}},

  {"REFERENCE(REF)",
    "REFERENCE(REF) sets the current optics as the reference optics.",
    "reference-optics",
    {{"reference-optics",
      "Optics stored as a reference. Can be refered by DISP REF (mode), DRAW, Twiss, OpticsPlot. Set automatically by the first CALC or GO after USE. Can be updated by REFERENCE(REF).",
      "REFERENCE(REF) DISPLAY(DISP) DRAW Twiss OpticsPlot",
      {}}}},

  {"wildcards",
   "\
   Many commands and functions accept the wildcards as a specification for the name of elements or components. The valid wildcards are:\n\n\
       *         matches any zero or more characters.\n\
       %         matches one character.\n\
       {..}      matches any character enclosed.\n\
       {^..}     matches any character not enclosed.\n\
       ..|..     alternative pattern.",
   "elements components DISPLAY(DISP) TYPE(T) SAVE RESET FREE FIX ATTRIBUTE(ATTR)\
 REJECT CALCULATE(CAL) functions Element LINE Twiss",
   {}},

  {"END",
   "Closes the current output-stream and set the output stream to the standard output(6). It also suspends all the input streams and switches to the standard input(5). Since this command affects all input and output streams, you may consider to use TERMINATE(TERM) or CLOSE(CLO) to suspend or close them selectively.",
   "TERMINATE(TERM) CLOSE(CLO) INPUT(IN) READ OUTPUT(OUT) APPEND(APP)",
   {}},

  {"TERMINATE(TERM)",
   "\
   TERM [INPUT(IN)] suspends the current input stream and switches it to the previous input stream.\n\
   TERM OUTPUT(OUT) suspends the current output and switches it to the previous output stream.",
   "CLOSE(CLO) INPUT(IN) READ OUTPUT(OUT) APPEND(APP) END",
   {}},

  {"CLOSE(CLO)",
   "\
   CLOSE [INPUT(IN)] closes the current input stream and switches it to the previous input stream.\n\
   CLOSE OUTPUT(OUT) suspends the current output and switches it to the previous output stream.",
   "TERMINATE(TERM) INPUT(IN) READ OUTPUT(OUT) APPEND(APP) END",
   {}},

  {"INPUT(IN)",
   "\
IN {filename | file-number} switches the input stream to the specified file or the file-number. The original stream is kept and to be returned by TERMINATE(TERM). The input file is not rewound.",
   "TERMINATE(TERM) CLOSE(CLO) READ OUTPUT(OUT) APPEND(APP) END",
   {}},

  {"READ",
   "\
READ {filename | file-number} switches the input stream to the specified file or the file-number. The original stream is kept and to be returned by TERMINATE(TERM). The input file is rewound.",
   "TERMINATE(TERM) CLOSE(CLO) INPUT(IN) OUTPUT(OUT) APPEND(APP) END",
   {}},

  {"OUTPUT(OUT)",
   "\
OUT {filename | file-number} switches the output stream to the specified file or the file-number. The file is written from the beginning.",
   "TERMINATE(TERM) CLOSE(CLO) INPUT(IN) READ APPEND(APP) END",
   {}},

  {"APPEND(APP)",
   "\
APP {filename | file-number} switches the output stream to the specified file or the file number. The output is appended to the existing file.",
   "TERMINATE(TERM) CLOSE(CLO) INPUT(IN) READ OUTPUT(OUT) END",
   {}},

  {"EXECUTE(EXEC)",
   "Usage: EXEC character-string-expression\n\n\
executes the character-string-expression as FFS commands.",
   "expression FFS ToExpression",
   {}},

  {"FIT",
   "\
Usage: (1) FIT [component]\n\
       (2) FIT component1 component2\n\n\
sets the current location where the matching condition is applied. The component is given with the form name[.order][{+-}offset] (see components). If component is omitted, the end of the beam line is chosen.\n\
   If two components are given, it means a relative-fitting or zone-fitting. If the fitting condition is not maximum-fitting, the condition means to make values at two components equal (for AX, BX, GMX, AY, BY, GMY, EX, EPX, EY, EPY, R1, R2, R3, R4, DX, DPX, DY, DPY, PEX, PEPX, PEY, PEPY, CHI1, CHI2, CHI3),  or have the specified difference (for NX, NY, LENG, GX, GY, GZ). If the fitting condition is maximum-fitting, the condition means a zone-fitting (for AX, BX, GMX, AY, BY, GMY, EX, EPX, EY, EPY, R1, R2, R3, R4, DX, DPX, DY, DPY, PEX, PEPX, PEY, PEPY, CHI1, CHI2, CHI3), which suppress the maximum of the function in the region between component1 and component2, or maximum-fitting for the difference of the function (for NX,  NY, LENG, GX, GY, GZ). The fit region is shown in the first part of the prompt when FFSPRMPT is ON.\n\n\
Examples: (1) FIT QF.2-10\n\n\
sets the current fit point at  10 components upstream from the entrance of the second QF.\n\n\
          (2) FIT QF QD NX 0.5 BXM 10\n\n\
sets the two-point fitting between QF and QD, then set the difference of NX between QF and QD to be 0.5, and the maximum of BX to be 10 in the region between QF and QD.",
   "matching-function-commands components SHOW GO CAL",
   {}},

   {"FREE",
    "Usage: FREE element-pattern [keyword] [element-pattern1 [keyword1]..]\n\n\
specifies elements which match element-pattern as the matching variables. The optional keyword specifies the non-default variables. See default-keyword. \n\
   For the MARK element at the beginning of the beam line, a special form can be used for the FREE command. That is a form <matching-function>I  (appending \"I\" to a matching-function name) which means the incoming condition of the matching-function is varied in the matching.\n\n\
Example: FREE AXI BXI AYI BYI\n\n\
changes incoming AX, BX, AY, and BY to find the solution.",
    "FIX FIT SHOW GO CAL wildcards elements",
    {
     DefaultKeywordMessage=
     {"default-keyword",
      "\
The default and available non-default variable keywords are:\n\n\
type    default-keyword  non-default variable keyword\n\
DRIFT   L                -\n\
BEND    ANGLE            K1,K0,E1,E2\n\
QUAD    K1               ROTATE\n\
SEXT    K2               ROTATE\n\
OCT     K3               ROTATE\n\
DECA    K4               ROTATE\n\
DODECA  K5               ROTATE\n\
MULT    K1               K0,K2..K21,SK0,SK1,SK2..SK21,ROTATE,ANGLE\n\
MARK    -                AX,BX,EX,EPX,AY,BY,EY,EPY,R1,R2,R3,R4,DETR,\n\
                         DX,DPX,DY,DPY,DZ,DDP,AZ,BZ,ZX,ZPX,ZY,ZPY",
      "keywords",
      {}}
    }},

   {"FIX",
    "Usage: (1) FIX element-pattern [keyword] [element-pattern1 [keyword1]..]\n\n\
removes elements which match element-pattern from the matching variables. The optional keyword specifies the non-default variables. If the keyword is omitted, all keywords are removed.\n\
   For the MARK element at the beginning of the beam line, a special form can be used for the FIX command. That is a form <matching-function>I (appending \"I\" to a matching-function name).\n\n\
Example: FIX AXI BXI AYI BYI\n\n\
removes incoming AX, BX, AY, and BY from the matching variables.\n\n\
Usage: (2) FIX\n\n\
sets the standard optics for the orbit correction commands.",
    "FREE FIT SHOW GO CAL wildcards elements",
    {}},

   {"VARIABLES(VAR)",
    "\
VARIABLES displays a list of current matching-variables and their present, previous, saved, minimum, and maximum values together with the COUPLEd master elements and their coefficients.\n\
   When executed in the FFS function, it returns the result as a list.\n\n\
   Usage:   FFS[\"VAR\"]\n\n\
returns a list of nvar elements, where nvar is the number of current matching-variables given by the FREE command. Each element has the form\n\n\
  {name, keyword, present, previous, saved, minimum, maximum, coupled-master-element, coupling-coefficient} ,\n\n\
which corresponds to the output of the VARIABLES(VAR) command.",
    "FREE COUPLE FFS",
    {}},

   {"USE",
    "Usage: USE [[NO]EXPAND] beam-line\n\n\
switches the beam line used in FFS to the beam line given by beam-line. beam-line can be an BeamLine object or the name of a beam line defined in MAIN. All information specific to the current beam line, such as matching conditions is lost. If the keyword EXPAND is given (default), the new beam line is expanded, i.e., the values of components are refreshed to the saved values.\n\
   If a BeamLine object is used by USE or VISIT, the new beam line becomes a\n\
new LINE in the MAIN level, with a name which is created automatically.",
    "VISIT BYE EXPAND BeamLine BeamLineName",
    {}},

   {"VISIT",
    "Usage: VISIT [[NO]EXPAND] beam-line\n\n\
switches the beam line used in FFS to the beam line given by beam-line. beam-line can be an BeamLine object or the name of a beam line defined in MAIN. All information specific to the current beam line, such as matching conditions are reserved, and the previous beam line is restored when BYE command is issued. If the keyword EXPAND is given (default), the new beam line is expanded, i.e., the values of components are refreshed to the saved values.\n\
   If a BeamLine object is used by USE or VISIT, the new beam line becomes a new LINE in the MAIN level, with a name which is created automatically.",
    "USE BYE EXPAND BeamLine BeamLineName",
    {}},

   {"BYE",
    "Exits from the current beam line and returns to the original beam line where VISIT command was issued. All information specific to the beam line, such as matching conditions are restored.\n\
   Note that BYE does neither SAVE the values of elements of the leaving beam line, nor RESET the values of elements of the returning beam line.",
    "VISIT USE SAVE RESET STOP QUIT ABORT",
    {}},

   {"SPLIT",
    "\
Usage: SPLIT component length\n\n\
splits the component into two pieces at the point where the distance from the entrance is length. The new components have the same name as the original, and the strengths are proportional to the new lengths. Only magnets and cavities can be split. You should CALCULATE(CAL) after SPLIT to get optical parameters after SPLIT. Matching using SPLIT element as a variable may degrade the speed of convergence.",
    "",
    {}},

   {"ATTRIBUTE(ATTR)",
    "Usage: ATTR element-pattern\n\n\
prints out the current value, minimum and maximum values, COUPLEd element and its coefficient for elements which match the element-pattern.",
    "COUPLE set-value-of-element wildcards",
    {}},

   {"FITPOINTS(FITP)",
    "Usage: FITP n\n\n sets n to the number of off-momentum points in the off-momentum matching. If the fitting condition is on-momentum only, it is not affected.",
    "matching-function-commands",
    {}},

   {"RECOVER(REC)",
    "REC exchanges the values of FREEd elements with those when the last GO command was issued. FIXed elements are not affected.",
    "GO FREE FIX RESET SAVE",
    {}},

   {"TYPE(T)",
    "Usage: TYPE [element-pattern [element-pattern1..]]\n\n\
prints out the values of elements which match element-pattern in the SAD MAIN input format. Keywords which have zero values are omitted unless it is the default variable. If non element-pattern is given, all elements are printed out.",
    "DISPLAY(DISP) VARIABLES(VAR) elements",
    {}},

   {"ORG",
    "Usage: ORG location, dgx, dgy, dgz, dchi1, dchi2, dch3\n\n\
sets the origin of the geometrical coordinate relative to the location with a relative shift (dgx, dgy, dgz) and rotation (dchi1, dchi2, dchi3).",
    "",
    {}},

   {"EMITTANCE(EMIT)",
    "\
Usage: (1) EMIT\n\
       (2) EMIT dp\n\n\
(1) EMIT calculates the closed orbit, the normal coordinate, and the equilibrium emittance assuming the current beam line is a positron ring. One of EMITTANCE(EMIT), the Emittance[] function, or the EMIT command in the MAIN level are necessary to be done in prior to multi-turn tracking. See multi-turn-tracking.\n\n\
(2) EMIT dp, where dp is |df_rf/f_rf|/(alpha_p == momentum compaction), does EMIT for five rf frequencies:\n\n"//
EquAlign["\\frac{1}{\\alpha_p}\\frac{\\varDelta f_{\\rm rf}}{f_{\\rm rf}}=-|{\\tt DP}|, -|{\\tt DP}|/2, 0, |{\\tt DP}|/2, |{\\tt DP}|\\ ,","\
   df_rf/f_rf/alpha_p = -|dp|, -|dp|/2, 0, |dp|/2, |dp|,"]//"\n\n\
then prints out a table of the dependences of various quantities on the frequency shift.\n\n\
   The results of EMITTANCE(EMIT) are affected by flags COD, RADCOD, RFSW, INTRA, WSPAC, EMIOUT, CODPLOT and special-variables MOMENTUM, CHARGE, FSHIFT, MINCOUP, PBUNCH. The flag TRPT or RING affects only Emittance[], as EMITTANCE(EMIT) automatically set RING.\n\
   EMITTANCE(EMIT) returns the equilibrium emittances in variables EMITX, EMITY, EMITZ, and the equilibrium bunch length in SIGZ, the relative momentum spread in SIGE, and the longitudinal equilibrium position DTSYNCH. \n\n\
   The map used in EMIT is slightly different from that used in the tracking. For instance, the edge angle of a bend is approximated by a thin quad. If the edge angle is large and the curvature is small, EMIT may give a wrong answer. This will be corrected in near future.",
    "multi-turn-tracking extended-Twiss-parameters COD RADCOD RFSW INTRA EMIOUT WSPAC \n\
 CODPLOT TRPT MOMENTUM CHARGE FSHIFT MINCOUP PBUNCH EMITX EMITY EMITZ SIGE SIGZ DTSYNCH Emittance equilibrium-beam-envelope",
    {}},

   {"multi-turn-tracking",
    "\
The multi-turn tracking can be done by the TRACK command of the MAIN level, the TRACK command in FFS, or the DynamicApertureSurvey[] function in FFS. The latter only perform the DAPERT mode.\n\n\
   The multi-turn tracking uses the closed orbit, normal coordinate, and the equilibrium emittances. Therefore One of EMITTANCE(EMIT), the Emittance[] function, or the EMIT command in the MAIN level are necessary to be done once in prior to the multi-turn-tracking. The values of EMITX, EMITY, EMITZ, SIGE can be changed between EMITs and the multi-turn-tracking.",
    "EMITTANCE(EMIT) RFSW RAD FLUC RADCOD SPAC WSPAC special-variables equilibrium-beam-envelope",
    {}},

   {"machine-error-commands",
    "\
Usage: machine-error-command [options] amount component-pattern ..\n\n\
where machine-error-command is one of\n\n\
command    keyword affected     applicable types\n\
DELX       DX                   BEND QUAD SEXT OCT DECA DODECA SOL CAV\n\
DELY       DY                   BEND QUAD SEXT OCT DECA DODECA SOL CAV\n\
DL         L                    DRIFT SOL\n\
DTHETA     ROTATE               QUAD SEXT OCT DECA DODECA CAV\n\
DTHETA     DROTATE              BEND\n\
DK         default-keyword      DRIFT BEND QUAD SEXT OCT DECA DODECA MULT SOL CAV\n\
DDK        K0 or DBZ            BEND SOL\n\n\
   amount is the amount of the error,\n\
   component-pattern is the pattern to specify the components to be applied.\n\n\
   Options are\t\n\n\
RANDOM(R)        Set amount*GaussRandom[] to the keyword. \n\
UNIFORM(U)       Set the specified amount to the keyword without random number.\n\
INCOHERENT(INC)  GaussRandom[] is called for each component. Default.\n\
COHERENT(C)      GaussRandom[] is called once for each component-pattern.\n\
PUT(P)           Set the error to the keyword. Default.\n\
ADD(A)           Add the error to the keyword.\t",
    "components wildcards keywords default-keyword DUMP SEED",
    {}},

   {"DUMP",
    "\
Usage: DUMP component-pattern [component-pattern1..]\n\n\
prints out the current machine errors of components which match component-pattern.",
    "machine-error-commands components wildcards",
    {}},

   {"elements",
    "An element in FFS represents an object which has a unique name and several keywords with values. This simulates a power supply of a magnet. An element has one or more components, which correspond to individual magnets in a beam line. Each component may have different values from the values of the corresponding element. This simulates the machine error which varies magnet to magnet\n\
   The value of an element can be saved to or recovered from the element-save-buffer by SAVE or RESET commands. Different beam lines can share the same element, and their values can be different to each other, but they have the common element-save-buffer. Therefore the value of an element can be transferred between beam lines by SAVE and RESET command through the element-save-buffer.\n\
   An element is created only in SAD MAIN level. In the definition, if a keyword is omitted, the previous definition is unchanged. All keywords have the default value zero. In FFS, it is only possible to change their values.",
    "TYPE(T) set-value-of-element Element",
    ElementsMessage=Sort[
      {DefaultKeywordMessage,

       KeywordsMessage=
       {"keywords",
        "Available keywords are:\t\n\n\
type    keywords\n\
DRIFT   L RADIUS\n\
BEND    L ROTATE DROTATE DX DY ANGLE K0 K1 E1 E2 AE1 AE2 F1 FB1 FB2 FRINGE DISFRIN DISRAD EPS RANKICK\n\
QUAD    L ROTATE DX DY K1 F1 F2 FRINGE DISFRIN DISRAD EPS\n\
SEXT    L ROTATE DX DY K2 DISFRIN DISRAD\n\
OCT     L ROTATE DX DY K3 DISFRIN DISRAD\n\
DECA    L ROTATE DX DY K4 DISFRIN DISRAD\n\
DODECA  L ROTATE DX DY K5 DISFRIN DISRAD\n\
MULT    L DX DY DZ CHI1 CHI2 ROTATE(=CHI3) K0..K21 SK0..SK21 DISFRIN F1 F2 FRINGE DISRAD EPS VOLT DVOLT HARM PHI DPHI FREQ RADIUS ANGLE E1 E2 AE1 AE2 DROTATE\n\
SOL     BZ DX DY DZ DPX DPY BOUND GEO CHI1 CHI2 CHI3 DBZ DISFRIN\n\
CAVI    L ROTATE DX DY VOLT DVOLT V1 V20 V11 V02 FREQ PHI HARM RANVOLT RANPHASE DISFRIN FRINGE\n\
TCAVI   L ROTATE DX DY K0 V1 FREQ PHI HARM RANKICK RANPHASE\n\
COORD   DX DY CHI1 CHI2 CHI3 DIR\n\
MARK    AX BX AY BY EX EPX EY EPY R1 R2 R3 R4 DETR DX DPX DY DPY DZ DDP AZ BZ NZ ZX ZPX ZY ZPY EMITX EMITY DP AZ SIGZ GEO OFFSET\n\
APERT   DX1 DX2 DY1 DY2 DP AX AY DX DY",
        "default-keyword set-value-of-element Element",
        {}},

      {"DRIFT",
        "A drift space.",
        "",
        {{"L",
          "The length, can be negative.",
          "",
          {}},

         {"RADIUS",
          "Radius of the vacuum chamber. Effective when SPAC is ON.",
          "SPAC",
          {}},

         {"transformation:DRIFT",
          DRIFT$trans="\
The transformation of a drift is written as\n\n"//
EquAlign["\\exp(:H:)\\ .",
"\
   exp(:H:),"]//"\n\n\
with\n\n"//EquAlign["H(x,p_x,y,p_y,z,p)=(-\\sqrt{p^2-p_x^2-p_y^2}+1-E/v_0){\\tt L}\\ .",
"\
   H(x, px, y, py, z, p) = (-(p^2 - px^2 - py^2)^(1/2) + 1 - E/v0) L ."],
          "coordinates",
          {}}}},

      {"APERT",
       "\
An aperture. Only valid in tracking. A particle with\n\n"//
EquAlign["&\\frac{(x-{\\tt DX})^2}{{\\tt AX}^2}+\\frac{(y-{\\tt DY})^2}{{\\tt AY}^2}<1\\\\\
 \\&\\&\\ &\\min({\\tt DX1},{\\tt DX2})<x<\\max({\\tt DX1},{\\tt DX2})\\\\\
 \\&\\&\\ &\\min({\\tt DY1},{\\tt DY2})<y<\\max({\\tt DY1},{\\tt DY2})",
"\
   (x - DX)^2/AX^2 + (y - DY)^2/AY^2 < 1\n\
 && Min[DX1, DX2] < x < Max[DX1, DX2]\n\
 && Min[DY1, DY2] < y < Max[DY2, DY2]"]//"\n\n\
can pass through the aperture, otherwise it is lost and a message is printed out. If AX or AY is zero (default), they are interpreted as infinity. If AX <=> 0 && AY <=> 0 and (DX1 == DX2 or DY1 == DY2) then the aperture is only determined by AX and AY.",
       "",
       {}},

      {"BEND",
       "A bending magnet.",
       "",
       Sort[
       {{"L",
          "The effective length along the arc of the orbit.",
          "",
          {}},

         ROTATE$Message=
         {"ROTATE",
          "\
Rotation in x-y plane. After displacing the magnet by DX and DY, rotate the magnet around the local s-axis by -(amount given by ROTATE), then place the component. At the exit rotate back the magnet around the local s-axis at the exit, then take out displacement.",
          "DX DY DROTATE",
          {}},
    
         DROTATE$Message=
         {"DROTATE",
          "\
Additional rotation in x-y plane to simulate a rotation error. DROTATE does not affect the geometry of the ring.",
          "DX DY ROTATE",
          {}},
    
         DX$Message=
         {"DX",
          "\
Horizontal displacement of magnet. This applied before the rotation by ROTATE.",
          "DY ROTATE DROTATE",
          {}},

         DY$Message=
         {"DY",
          "\
Vertical displacement of magnet. This applied before the rotation by ROTATE.",
          "DX ROTATE DROTATE",
          {}},

         ANGLE$Message={"ANGLE",
          "\
The bending angle. If positive, it bends the orbit in x-s plane toward negative-x-direction. ANGLE determines the geometry of the beam line, while K0 represents a dipole kick on top of the bending angle given by ANGLE, i.e., the total deflection of the beam is given of ANGLE + K0.",
          "K0",
          {}},

         E1$Message={"E1",
          "\
The ratio of the face-angle at the entrance to the bending angle. The effective face angle is E1 * ANGLE + AE1, and a positive angle at the entrance corresponds to a surface with dx/ds > 0. For example, a symmetrically-placed rectangular magnet has\n\
 E1 = 0.5 and E2 = 0.5.",
          "AE1 E2 ANGLE",
          {}},

         E2$Message={"E2",
          "\
The ratio of the face-angle at the exit to the bending angle. The effective face angle is E2 * ANGLE + AE2, and a positive angle at the exit corresponds to a surface with dx/ds < 0. For example, a symmetrically-placed rectangular magnet has E1 = 0.5 and E2 = 0.5.",
          "AE2 E1 ANGLE",
          {}},

         AE1$Message={"AE1",
          "\
The absolute face angle at the entrance. The effective face angle is E1 * ANGLE + AE1, and a positive angle at the entrance corresponds to a surface with dx/ds > 0.",
          "E1 AE2 ANGLE",
          {}},

         AE2$Message={"AE2",
          "\
The absolute face-angle at the exit to the bending angle. The effective face angle is E2 * ANGLE + AE2, and a positive angle at the exit corresponds to a surface with dx/ds < 0.",
          "E2 AE1 ANGLE",
          {}},

         Kn$Message[n_]:=
         {"K"//n,
          "\
The normal "//N$pole[2(n+1)]//" magnetic field component (times the length L).\n\n"//
EquAlign["{\\tt K"//n//"}=\\frac{B"//N$deriv[n]//"{\\tt L}}{B\\rho},",
"\
   K"//n//" = B^("//n//")L/(Brho),"]//"\n\n\
where L is the effective length of the component. Positive sign means horizontal focusing.",
          "L",
          {}};Kn$Message[0],

         Kn$Message[1],

         {"F1",
          "\
Length of the slope of the field at the edge as:\n\n\
                By(s) |   *******\n\
                      |  *\n\
                      | *\n\
                      |*\n\
                      *\n\
                     *|\n\
                    * |\n\
                   *  |\n\
        ----*******---+--------- s\n\
                  |       |\n\
                  |<----->|\n\
                  |   F1  |\n\n\
Only the effects up to y^4 in Hamiltonian are taken into account. A more rigorous definition is\n\n"//EquAlign[
"{\\tt F1}=6 \\int_{-\\infty}^\\infty{\\frac{B_y(s)}{B_0}-\\left(\\frac{B_y(s)}{B_0}\\right)^2}ds,","\
   F1 = 6 Integrate[By(s)/B0 - (By(s)/B0)^2, {s, -Inf, Inf}] ,"]//"\n\n\
where integration is done over one fringe.\n\n"//
(BF1$Message="\
   The transformation of the linear fringe of the entrance of a bend is\n\n"//EquAlign[
"\\exp(:V:),\\qquad V=-\\frac{1}{p}\\left(\\frac{{\\tt F1}^2}{24\\rho_b}p_x-\\frac{\\tt F1}{12\\rho_b}y^2\n\
+\\frac{y^4}{6{\\tt F1}\\ \\rho_b^2}\\right)","\
   exp(:V:),   V = -f^2/rhob px/p/24 - f/rhob^2 y^2/p/12 \n\
                   + 1/rhob^2/f y^4/p/6 ,"]//"\n\n\
where f is the length of fringe given by F1, and rhob bending radius at the design momentum. At the exit, the sign of rhob is changed. This linear fringe also changes the path length in the body of the bend as\n\n"//EquAlign[
"L'={\\tt L}-\\frac{({\\tt ANGLE\\ F1})^2}{24{\\tt L}}\\frac{\\sin(({\\tt ANGLE}(1-{\\tt E1}-{\\tt E2})-{\\tt AE1}-{\\tt AE2})/2)}{\\sin({\\tt ANGLE}/2)}","\
   l'=l-(phi0 f)^2/l/24 Sin[(phi0(1-E1-E2)-AE1-AE2)/2]/Sin[phi0/2]"]//"\n\n\
to maintain the geometric position of the design orbit, i.e., you have to increase the bend field a little bit to keep the orbit unchanged. Unlike a quadrupole, the effect of linear fringe is always applied at both the entrance and the exit, otherwise you cannot obtain a circular design orbit.\n\n\
   Use FB1 and FB2 to specify the values of entrance and exit separately."),
          "FRINGE FB1 FB2",
          {}},

         {"FB1",
           "\
   F1 at the entrance. Actually F1 + FB1 is used at the entrance.",
          "F1 FB2",
          {}},

         {"FB2",
           "\
   F1 at the exit. Actually F1 + FB2 is used at the exit.",
          "F1 FB1",
          {}},

         {"FRINGE",
          "\
When FRINGE is non-zero, the effect of the linear fringe F1 is taken into account both at the entrance and the exit.\n"
  //BF1$Message,
          "F1",
          {}},

         DISFRIN$Message=
         {"DISFRIN",
          "\
If nonzero, the nonlinear Maxwellian fringe is suppressed.",
          "",
          {}},

         DISRAD$Message=
         {"DISRAD",
          "\
If nonzero, the synchrotron radiation in the particle-tracking is inhibited.",
          "RAD",
          {}},

         {"transformation:BEND",
          BEND$trans="\
The transformation of a bend depends on the value of K1. If K1 is zero, it is a series of transformations:\n\n\
    (transformation due to misalignments)\n\
   (drift to the entrance face)\n"//EquAlign["\
x_2   &= \\frac{x_1}{\\cos\\psi_1 - (p_{x1}/p_{z1})\\sin\\psi_1 }\\ ,\\\\\n\
p_{x2}&= p_{x1} \\cos\\psi_1 + p_{z1} \\sin\\psi_1\\ ,\\\\\n\
y_2   &= y_1 + \\frac{p_{y1}}{p_{z1}}x_2\\sin\\psi_1\\ ,\\\\\n\
z_2   &= z_1 - \\frac{p_1}{p_{z1}} x_2 \\sin\\psi_1\\ ,\\\\\n\
{\\rm where\\ } \\psi_1 &\\equiv {\\tt ANGLE} \\times {\\tt E1} + {\\tt AE1}","\
      x2  = x1/(cos(psi1) - sin(psi1) (px1/pz1))\n\
      px2 = px1 cos(psi1) + pz1 sin(psi1)\n\
      y2  = y1 + (py1/pz1) x2 sin(psi1)\n\
      z2  = z1 - (p1 /pz1) x2 sin(psi1) ,\n\
      where psi1 = ANGLE * E1 + AE1"]//"\n\
   (linear fringe at entrance face)\n"//EquAlign["\
x_2  =& x_1 + \\varDelta x_{fr} \\frac{p_1 - p_0}{p_1}\\ ,\\\\\n\
p_{y2} =& p_{y1} + y_1\\frac{\\varDelta y_{fr} - \\varDelta y_{fra} y_1^2}{p_1^2}\\ ,\\\\\n\
z_2  =& z_1 + \\frac{\\varDelta x_{fr} p_{x1} + (\\varDelta y_{fr} - \\varDelta y_{fra} y_1^2/2) y_1^2/(2 p_1)}{p_1}\\ ,\\\\\n\
{\\rm where\\ }\\varDelta x_{fr} \\equiv& \\frac{{\\tt F1}^2}{24 \\rho_b}\\ ,\\\\\n\
            \\varDelta y_{fr} \\equiv& \\frac{\\tt F1}{6 \\rho_b^2}\\ ,\\\\\n\
            \\varDelta y_{fra}\\equiv& \\frac{2}{3} \\frac{1}{{\\tt F1} \\rho_b^2}\\ ,\\\\\n\
            \\rho_b \\equiv& \\frac{L'}{{\\tt ANGLE} + {\\tt K0}}\\ ,\\\\\n\
L'\\equiv&{\\tt L}-\\frac{({\\tt ANGLE\\ F1})^2}{24{\\tt L}}\\\\\n\
&\\times\\frac{\\sin(({\\tt ANGLE}(1-{\\tt E1}-{\\tt E2})-{\\tt AE1}-{\\tt AE2})/2)}{\\sin({\\tt ANGLE}/2)}\\ .","\
      x2  = x1 + dxfr (p1 - p0)/p1\n\
      py2 = py1 + (dyfr - dyfra y1^2) y1/p1^2\n\
      z2  = z1 + (dxfr px1 + (dyfr - dyfra y1^2/2) y1^2/(2 p1))/p1\n\
      where dxfr = F1^2/(24 rhob) ,\n\
            dyfr = F1/(6 rhob^2) ,\n\
            dyfra= 2/3 1/(F1 rhob^2) ,\n\
            rhob = L'/(ANGLE + K0) ,\n\
            L'   = L - (ANGLE F1)^2 /(24 L)\n\
                     * sin((ANGLE (1 - E1 - E2) - AE1 - AE2)/2)/sin(ANGLE/2)"]//"\n\
   (nonlinear fringe at entrance)\n"//EquAlign["\
x_2&=x_1 + y_1^2 (1-\\frac{y_1^2}{12\\rho_b^2}) \\frac{p_1^2}{2 \\rho_b (p_1^2 - p_{x1}^2)^{3/2}}\\ ,\\\\\n\
p_{y2}&= p_{y1} - p_{x1} (1-\\frac{y_1^2}{6\\rho_b^2}) \\frac{y_1}{p_1 \\rho_b \\sqrt{p_1^2 - p_{x1}^2}}\\ ,\\\\\n\
z_2&=z_1  - p_{x1} y_1^2 (1-\\frac{y_1^2}{12\\rho_b^2}) \\frac{p_1}{2 \\rho_b (p_1^2 - p_{x1}^2)^{3/2}}\\ .","\
      x2  = x1  + y1^2 (1-y1^2/rhob^2/12) p1^2/(2 rhob (p1^2 - px1^2)^(3/2))\n\
      py2 = py1 - px1 (1-y1^2/rhob^2/6) y1/(p1 rhob sqrt(p1^2 - px1^2))\n\
      z2  = z1  - px1 y1^2 (1-y1^2/rhob^2/12) p1/(2 rhob (p1^2 - px1^2)^(3/2))"]//"\n\
   (body of bend)\n"//EquAlign["\
p_{x2}=&-\\frac{\\rho_0}{\\rho_b} (\\sin\\psi_2 + \\sin(\\omega + \\psi_1))\\\\\n\
            &+ p_{z1}\\sin\\omega  +  p_{x1}\\cos\\omega - \\frac{x_1}{\\rho_b \\sin\\omega}\\ ,\\\\\n\
x_2 =& x_1 \\cos\\omega + \\rho_b (p_{z2} - p_{z1}\\cos\\omega + p_{x1}\\sin\\omega)\\\\\n\
            &+\\rho_0 (\\cos(\\omega+\\psi_1) - \\cos\\psi_2)\\ ,\\\\\n\
y_2  =& y_1 + s \\frac{p_{y1}}{\\sqrt{p_1^2 - p_{y1}^2}}\\ ,\\\\\n\
z_2  =& z_1 - s \\frac{p_1}{\\sqrt{p_1^2 - p_{y1}^2}} + \\frac{v_1}{v_0} L'\\ ,\\\\\n\
{\\rm where\\ } \\rho_0  \\equiv& \\frac{L'}{\\tt ANGLE}\\ ,\\\\\n\
\\omega \\equiv& {\\tt ANGLE} - \\psi_1 - \\psi_2\\ ,\\\\\n\
s \\equiv&{\\tt ANGLE}\\times\\rho_b\\\\\n\
&\\times\\left(\\sin^{-1}\\frac{p_{x1}}{\\sqrt{p_1^2 - p_{y1}^2}}\n\
                    - \\sin^{-1}\\frac{p_{x2}}{\\sqrt{p_2^2 - p_{y2}^2}} + \\omega\\right)\\ .",
"\
      px2 = -rho0/rhob (sin(psi2) + sin(omega + psi1))\n\
            + sin(omega) pz1 + cos(omega) px1 - x1/rhob sin(omega)\n\
      x2  = x1 cos(omega) + rhob (pz2 - cos(omega) pz1 + sin(omega) px1)\n\
            + rho0 (cos(omega+psi1) - cos(psi2))\n\
      y2  = y1 + py1/sqrt(p1^2 - py1^2) s\n\
      z2  = z1 - s p1/sqrt(p1^2 - py1^2) + v1/v0 L'\n\
      where rho0  = L'/ANGLE\n\
            omega = ANGLE - psi1 - psi2\n\
            s     = rhob ANGLE (arcsin(px1/sqrt(p1^2 - py1^2))\n\
                    - arcsin(px2/sqrt(p2^2 - py2^2)) + omega)"]//"\n\
   (nonlinear fringe at exit)\n"//EquAlign["\
x_2&=x_1 - y_1^2 (1-\\frac{y_1^2}{12\\rho_b^2}) \\frac{p_1^2}{2 \\rho_b (p_1^2 - p_{x1}^2)^{3/2}}\\ ,\\\\\n\
p_{y2}&= p_{y1} + p_{x1} (1-\\frac{y_1^2}{6\\rho_b^2}) \\frac{y_1}{p_1 \\rho_b \\sqrt{p_1^2 - p_{x1}^2}}\\ ,\\\\\n\
z_2&=z_1  + p_{x1} y_1^2 (1-\\frac{y_1^2}{12\\rho_b^2}) \\frac{p_1}{2 \\rho_b (p_1^2 - p_{x1}^2)^{3/2}}\\ .",
"\
      x2  = x1  - y1^2 (1-y1^2/rhob^2/12) p1^2/(2 rhob (p1^2 - px1^2)^(3/2))\n\
      py2 = py1 + px1 y1 (1-y1^2/rhob^2/6)/(p1 rhob sqrt(p1^2 - px1^2))\n\
      z2  = z1  + px1 y1^2 (1-y1^2/rhob^2/12) p1/(2 rhob (p1^2 - px1^2)^(3/2))"]//"\n\
   (linear fringe at exit face)\n"//EquAlign["\
x_2  &= x_1 - \\varDelta x_{fr} \\frac{p_1 - p_0}{p_1}\\ ,\\\\\n\
p_{y2} &= p_{y1} + y_1\\frac{\\varDelta y_{fr} - \\varDelta y_{fra} y_1^2}{p_1^2}\\ ,\\\\\n\
z_2  &= z_1 + \\frac{-\\varDelta x_{fr} p_{x1} + (\\varDelta y_{fr} - \\varDelta y_{fra} y_1^2/2) y_1^2/(2 p_1)}{p_1}-\\varDelta z_{fr}\\ ,\\\\\n\
{\\rm where\\ } \\varDelta z_{fr}&\\equiv \\varDelta x_{fr} \\left(\\sin({\\tt ANGLE\\ E1} + {\\tt AE1}) + \\sin({\\tt ANGLE\\ E2} + {\\tt AE2}) \\right)\\ .",
"\
      x2  = x1 - dxfr (p1 - p0)/p1\n\
      py2 = py1 + (dyfr - dyfra y1^2) y1/p1^2\n\
      z2  = z1 + (-dxfr px1 + (dyfr - dyfra y1^2/2) y1^2/(2 p1))/p1 - dzfr\n\
      where dzfr = dxfr * ( sin(ANGLE E1 + AE1) + sin(ANGLE E2 + AE2) )"]//"\n\
   (drift from the exit face)\n"//EquAlign["\
p_{x2} =&  p_{x1}\\cos\\psi_2  + p_{z1}\\sin\\psi_2\\ ,\\\\\n\
x_2  =& x_1 (\\cos\\psi_2 + \\frac{p_{x2}}{p_{z2}} \\sin\\psi_2)\\ ,\\\\\n\
y_2  =& y_1 + \\frac{p_{y2}}{p_{z2}} x_1 \\sin\\psi_2\\ ,\\\\\n\
z_2  =& z_1 - x_1 \\frac{p_2}{p_{z2}}\\sin\\psi_2\\ ,\\\\ \n\
{\\rm where\\ } \\psi_2 \\equiv& {\\tt ANGLE} \\times {\\tt E2}\\ .",
"\
      px2 =  cos(psi2) px1 + sin(psi2) pz1\n\
      x2  = x1 (cos(psi2) + px2/pz2 sin(psi2))\n\
      y2  = y1 + py2/pz2 x1 sin(psi2)\n\
      z2  = z1 - x1 sin(psi2) p2/pz2\n\
      where psi2 = ANGLE * E2."]//"\n\
   (transformation due to misalignments)\n\n\
If K1 is nonzero, the effects from E1 and E2 are approximated by thin\n\
quadrupoles. Then the body is subdivided into\n\n\
   1 + floor(sqrt(abs(K1 L')/(12 10^-5 EPS)))\n\n\
pieces (EPS = 1 is used when EPS = 0), and the bend-body transformation above is done for each piece and the kick from K1 is applied alternatively. In FFS optics and Emittance calculations, or when the synchrotron radiation is turned on, the same algorithm as K1 <> 0 is applied.",
          "coordinates equilibrium-beam-envelope",
          {}}
          }]
         },

       {"QUAD",
        "A quadrupole magnet.",
        "",
        Sort[
        {L$Message=
         {"L",
          "The effective length.",
          "",
          {}},

         ROTATE$Message,

         DX$Message,

         DY$Message,

         Kn$Message[1],

         {"F1",
          F1F2$Message=EquAlign["Text[\
{\\tt F1} and {\\tt F2} are parameters to characterize the slope of the field at the edges defined as:\n\
\\begin{align}\n\
{\\tt F1} =& {\\rm sgn}(a)\\sqrt a,\\qquad a \\equiv 24\\left(\\frac{I_0^2}{2} - I_1\\right)\\ ,\\\\\n\
{\\tt F2} =& I_2 - \\frac{I_0^3}{3}\\\\\n\
{\\rm with\\ }I_n \\equiv& \\int_{-\\infty}^\\infty(s-s0)^n \\frac{K_1(s)}{K_{10}}ds\\ ,\n\
\\end{align}\n\
where $s_0$ is the location of the edge where the effective length is defined, and $K_{10}={\\tt K1}/{\\tt L}$.;;;3]","\
F1 and F2 are parameters to characterize the slope of the field at the edges defined as:\n\n\
     F1 = SIGN(Sqrt[a],a),    a = 24(I_0^2/2 - I_1),\n\
     F2 = I_2 - I_0^3/3\n\
with\n\
     I_n = Integrate[(s-s0)^n K1[s]/K1_0,{s,-Infinity,Infinity}],\n\n\
where s0 is the location of the edge where the effective length is defined, and K1_0 is the nominal value of K1, given by the keyword K1."]//"\n\
   The effects only in the first order of K1 is taken into account.",
          "F2 FRINGE",
          {}},

         {"F2",
          F1F2$Message,
          "F1 FRINGE",
          {}},

         FRINGEQ$Message={"FRINGE",
          "\
The effects of the linear fringe (characterized by F1 and F2), and the nonlinear Mexwellian fringe are controled as:\n\n\
                   DISFRIN=0                   DISFRIN<>0\n\
             Nonlinear      Linear       Nonlinear     Linear\n\
FRINGE=0    entr & exit      none          none         none\n\
FRINGE=1       entr          entr          none         entr\n\
FRINGE=2       exit          exit          none         exit\n\
FRINGE=3    entr & exit   entr & exit      none      entr & exit\n\n",
          "F1 F2 DISFRIN",
          {}},

         DISFRINQ$Message={"DISFRIN",
          "\
If nonzero, the nonlinear maxwellian fringe is suppressed. The effects of DISFRIN and FRINGE are summarized as\n\n\
                   DISFRIN=0                   DISFRIN<>0\n\
             Nonlinear      Linear       Nonlinear     Linear\n\
FRINGE=0    entr & exit      none          none         none\n\
FRINGE=1       entr          entr          none         entr\n\
FRINGE=2       exit          exit          none         exit\n\
FRINGE=3    entr & exit   entr & exit      none      entr & exit\n\n",
          "FRINGE",
          {}},

         DISRAD$Message,

         {"transformation:QUAD",
          QUAD$trans="\
The transformation in a QUAD is a sequence of:\n\n\
   (nonlinear fringe at entrance)\n"//
EquAlign["Text[\
\\begin{align}\
 G(x_1, p_{x2}, y_1, p_{y2}, p_1) =& H_0(x_1, p_{x2}, y_1, p_{y2}, p_1)\
+\\frac{1}{2}\\left(\\frac{\\partial H_0}{\\partial x_1} \\frac{\\partial H_0}{\\partial p_{x2}} + \\frac{\\partial H_0}{\\partial y_1} \\frac{\\partial H_0}{\\partial p_{y2}}\\right)\\ ,\
\\end{align}\
where \n\
\\begin{align}\
H_0  &=  p_{x2} \\varDelta x_1 + p_{y2} \\varDelta y_1\\ ,\\\\\
\\varDelta x_1 &=  x_1 (a/3 + b)\\\\\
\\varDelta y_1 &= -y_1 (a + b/3)\\\\\
a&=  {\\tt K1} \\frac{x_1^2}{4p_1}\\\\\
b&=  {\\tt K1} \\frac{y_1^2}{4 p1}\\ .\
\\end{align}\\\\;;;6]","\
      canonical transformation by a generating function\n\n\
      G(x1, px2, y1, py2, p1) = H0(x1, px2, y1, py2, p1)\n\
                + (D[H0, x1] D[H0, px2] + D[H0, y1] D[H0, py2])/2\n\n\
      where H0  =  px2 dx1 + py2 dy1\n\
            dx1 =  x1 (a/3 + b)\n\
            dy1 = -y1 (a + b/3)\n\
            a   =  K1 x1^2/p1/4\n\
            b   =  K1 y1^2/p1/4 ."]//"\n\
   (linear fringe at entrance)\n"//
EquAlign["Text[\
\\begin{align}\
      p_{x2} &= \\exp(-a) p_{x1}\\ ,\\\\\
      p_{y2} &= \\exp(\ a)  p_{y1}\\ ,\\\\\
      x_2  &= \\exp(\ a)x_1 + b p_{x1}\\ ,\\\\\
      y_2  &= \\exp(-a)y_1 - b p_{y1}\\ ,\\\\\
      z_2  &= z_1 - (a x_1 + b (1 + a/2) p_{x2}) p_{x1}\
               + (a y_1 + b (1 - a/2) p_{y2}) p_{y1}\\ ,\
\\end{align}\
      where\
\\begin{align}\
 a &= -{\\tt K1 F1} \\frac{|{\\tt F1}|}{24 p_1 {\\tt L}}\\ ,\\\\\
            b &=\\frac{\\tt K1 F2}{\\tt L}\\ .\
\\end{align};;;7]","\
      px2 = exp(-a) px1\n\
      py2 = exp(a)  py1\n\
      x2  = exp(a)  x1 + b px1\n\
      y2  = exp(-a) y1 - b py1\n\
      z2  = z1 - (a x1 + b (1 + a/2) px2) px1\n\
               + (a y1 + b (1 - a/2) py2) py1\n\
      where a = -K1 F1 abs(F1)/(24 p1 L)\n\
            b =  K1 F2/L ."]//"\n\
   (body of quad)\n"//
EquAlign["Text[\
The body is subdivided into\
\\begin{align}\
 n = 1 + {\\tt Floor}\\left[\\frac{10 |{\\tt K1 L}|}{\\tt EPS}\\right]\
\\end{align}\
slices. {\\tt EPS} = 1 is used when {\\tt EPS} = 0. Then a transversely linear transformation $\\exp(:H_{2n}:)$ is applied in each slice with\
\\begin{align}\
H_{2n} = \\frac{1}{n}\\left\\lbrace\\left(-p + \\frac{p_x^2 + p_y^2}{2 p} + \\frac{E}{v_0}\\right){\\tt L} + \\frac{\\tt K1}{2} (x^2 - y^2)\\right\\rbrace\\ .\
\\end{align}\\\\\
Between slices the correction $\\exp(:\\varDelta H:)$ for the kinematical term\
\\begin{align}\
\\varDelta H = \\frac{1}{n}\\left(p-\\sqrt{p^2 - p_x^2 -p_y^2} - \\frac{p_x^2 + p_y^2}{2 p}\\right) {\\tt L}\
\\end{align}\
is applied. In a solenoid, the forms of $H_{2n}$ and $\\varDelta H$ are modified.\\;;;3]","\
      The body is subdivided in n = 1 + floor(10 abs(K1 L)/EPS) (EPS = 1\n\
      is used when EPS = 0), then a transversely linear transformation\n\
      exp(:H:) is done in each slice with\n\n\
         H = ((-p + (px^2 + py^2)/(2 p) + E/v0) L + K1 (x^2 - y^2)/2)/n .\n\n\
      Between slices applied is the correction exp(:dH:) for the kinematical\n\
      term with\n\n\
         dH = (-sqrt(p^2 - px^2 -py^2) + p - (px^2 + py^2)/(2 p)) L/n .\n\n\
      In a solenoid, the forms of H and dH are modified."]//"\n\
   (linear fringe at exit)\n"//
EquAlign["Text[\
\\begin{align}\
      p_{x2} &= \\exp(\ a) p_{x1}\\ ,\\\\\
      p_{y2} &= \\exp(-a)  p_{y1}\\ ,\\\\\
      x_2  &= \\exp(-a)x_1 + b p_{x1}\\ ,\\\\\
      y_2  &= \\exp(\ a)y_1 - b p_{y1}\\ ,\\\\\
      z_2  &= z_1 + (a x_1 - b (1 - a/2) p_{x2}) p_{x1}\
               - (a y_1 - b (1 + a/2) p_{y2}) p_{y1}\\ ,\
\\end{align}\
      where\
\\begin{align}\
 a &= -{\\tt K1 F1} \\frac{|{\\tt F1}|}{24 p_1 {\\tt L}}\\ ,\\\\\
            b &=\\frac{\\tt K1 F2}{\\tt L}\\ .\
\\end{align}\\;;;7]","\
      px2 = exp( a)  px1\n\
      py2 = exp(-a) py1\n\
      x2  = exp(-a) x1 + b px1\n\
      y2  = exp( a) y1 - b py1\n\
      z2  = z1 + (a x1 - b (1 - a/2) px2) px1\n\
               - (a y1 - b (1 + a/2) py2) py1\n\
      where a = -K1 F1 abs(F1)/(24 p1 L)\n\
            b =  K1 F2/L ."]//"\n\
   (nonlinear fringe at exit)\n"//
EquAlign["Text[\
a canonical transformation by a generating function:\n\
\\begin{align}\n\
G(x_1, p_{x2}, y_1, p_{y2}, p_1) = H_0(x_1, p_{x2}, y_1, p_{y2}, p_1) + \\frac{1}{2}\\left(\\frac{\\partial H_0}{\\partial x_1} \\frac{\\partial H_0}{\\partial p_{x2}} + \\frac{\\partial H_0}{\\partial y_1} \\frac{\\partial H_0}{\\partial p_{y2}}\\right)\\ ,\n\
\\end{align}\n\
where\n\
\\begin{align}\n\
 H_0&= p_{x2} \\varDelta x_1 + p_{y2} \\varDelta y_1\\ ,\\\\\n\
 \\varDelta x_1 &=  x_1 (a/3 + b)\\ ,\\\\\n\
 \\varDelta y_1 &= -y_1 (a + b/3)\\ ,\\\\\n\
 a &= -{\\tt K1} \\frac{x_1^2}{4p_1}\\ ,\\\\\n\
 b &= -{\\tt K1} \\frac{y_1^2}{4p_1}\\ .\n\
\\end{align};;;6]","\
      canonical transformation by a generating function\n\n\
      G(x1, px2, y1, py2, p1) = H0(x1, px2, y1, py2, p1)\n\
                + (D[H0, x1] D[H0, px2] + D[H0, y1] D[H0, py2])/2\n\n\
      where H0  =  px2 dx1 + py2 dy1\n\
            dx1 =  x1 (a/3 + b)\n\
            dy1 = -y1 (a + b/3)\n\
            a   = -K1 x1^2/p1/4\n\
            b   = -K1 y1^2/p1/4 ."],
        "Hamiltonian 2nd-order-Hamiltonian solution-H2 solution-dH",
        {}}
         }]
        },

          SEXT$trans[name_,n_]:=EquAlign["Text[\
The transformation of a {\\tt "//name//"} is given as\n\
\\begin{align}\n\
   &\\exp(:F_{\\rm in}:)\\exp(:a {\\tt L}:)\\exp(:H_"//n//"/2:)\\exp(:b {\\tt L}:)\\nonumber\\\\\n\
   \\times&\\exp(:V_"//n//":)\\exp(:a {\\tt L}:)\\exp(:H_"//n//"/2:)\\exp(:b {\\tt L}:)\\exp(:F_{\\rm out}:)\\  ,\n\
\\end{align}\n\
where {\\tt L} and $H_"//n//"$ are the Hamiltonians of a drift of length {\\tt L} and a thin "//
N$pole[2(n+1)]//" kick with integrated strength {\\tt K"//n//"}:\n\
\\begin{align}\n\
   H_"//n//" = \\frac{{\\tt K"//n//"}}{"//n+1//
"\!} \\Re(x - i y)^{"//n+1//"}\\ ,\n\
\\end{align}\n\
respectively. The coeffients are $a\\equiv 1/2 - 1/\\sqrt{12}$ and $b = 1/2 - a$. Terms $\\exp(:F_{\\rm in}:)$ and $\\exp(:F_{\\rm out}:)$ are transformations for entrance and exit nonlinear fringes. The term $\\exp(:V_"//n//":)$ is a correction to adjust the third-order terms in {\\tt L}:\n\
\\begin{align}\n\
   V_"//n//" = \\sum_{j=(x,y),k=(x,y)} \n\
              - \\frac{\\beta}{2}H_{"//n//",k}^2 \n\
              + \\gamma H_{"//n//",j}H_{"//n//",k} H_{"//n//",j,k}\\ ,\n\
\\end{align}\n\
where $,i$ represents the derivative by $x$ or $y$. We have also introduced two coefficients $\\beta \\equiv 1/6 - 1/\\sqrt{48}$ and $\\gamma = 1/40 - 1/(24 \\sqrt3$)\\ .;;;3]","\
The transformation of a "//name//" is given as\n\n\
   exp(:Fin:)exp(:a L:)exp(:H"//n//"/2:)exp(:b L:)\n\
         *exp(:V"//n//":)exp(:a L:)exp(:H"//n//"/2:)exp(:b L:)exp(:Fout:) ,\n\n\
where L and H"//n//" are Hamiltonians of a drift of length L and a thin "//N$pole[n]
//" kick of integrated strength K"//n//":\n\n\
   H"//n//
" = K"//n//"/"//n+1//"! Re((x - I y)^"//n+1//") ,\n\n\
respectively. The coeffients are a = 1/2 - 1/sqrt(12) and b = 1/2 - a. Terms exp(:Fin:) and exp(:Fout:) are transformations for entrance and exit nonlinear fringes. The term exp(:V"//n//":) is a correction to adjust the third-order terms in L:\n\n\
   V"//n//" = (SUM over j=(x,y), k=(x,y)) [\n\
              - beta/2 (H"//n//",k)^2 \n\
              + gamma (H"//n//",j H"//n//",k H"//n//",j,k)] ,\n\n\
where ,i represents the derivative by x or y. We have also introduced two coefficients beta = 1/6 - 1/sqrt(48) and gamma = 1/40 - 1/24/sqrt(3)."];
       SEXT$Message[name_,n_]:=
       {name,
        "A "//N$pole[2(n+1)]//" magnet.",
        "",
        Sort[
        {L$Message,

         ROTATE$Message,

         DX$Message,

         DY$Message,

         Kn$Message[n],

         DISFRIN$Message,

         DISRAD$Message,

         {"transformation:THIN",
        SEXT$trans[name,n],
        "",
        {}}
         }]
        };SEXT$Message["SEXT",2],

       SEXT$Message["OCT",3],

       SEXT$Message["DECA",4],

       SEXT$Message["DODECA",5],

       {"SOL",
        "\
A solenoid. Unlike other elements, SOL elements inserted at boundaries or of a solenoid or at where the field changes. Between SOL elements DRIFT, BEND(straight bend only), QUAD, and MULT elements can be inserted. The longitudinal field of the solenoid overlaps on those elements.\n\
   In a SOL region, the coordinate is shifted on the axis of the solenoid, no matter how the design orbit bends there. The x-direction of the coordinate in a solenoid is so chosen as to CHI3 = 0. At the exit of a solenoid, the coordinate is shifted back to the design orbit, but the value of CHI3 is so determined as to set CHI3 zero at the nearest MARK element which has GEO = 1 after the exit. The offset and orientation of the design orbit can be given by keywords DX, DY, DPX, DPY at a SOL element with GEO = 1. SOL can be used to shift the coordinate to the actual orbit even without BZ. It is useful to define the coordinate with magnets with DX and DY.",
        "geometric-functions MARK",
        Sort[
        {{"BOUND",
          "\
BOUND = 1 must be given at both sides of the boundaries of a solenoid, otherwise SOL only specifies the change of BZ",
          "",
          {}},

         {"BZ",
          "\
The longitudinal field of a solenoid. If a SOL is used with BOUND = 0 (default), only BZ is used to change the field, and no coordinate transformation is applied.",
          "",
          {}},

         {"GEO",
          "\
One of boundaries (with GEO = 1) of a solenoid must have GEO = 1 to specify the alignment of the design orbit. At a SOL element with GEO = 1, the design orbit is determined by DX, DY, DPX, DPY parameters",
          "DX DY DPX DPY geometric-functions DISPLAY(DISP) GEOMRTRY(G) OGEOMETRY(OG)",
          {}},

         {"DX",
          "\
An x-offset of the design ORBIT relative to the solenoid center at SOL with GEO = 1.",
          "GEO DY DPX DPY",
          {}},

         {"DY",
          "\
A y-offset of the design ORBIT relative to the solenoid center at SOL with GEO = 1.",
          "GEO DX DPX DPY",
          {}},

         {"DPX",
          "\
An offset of the design ORBIT angle CHI1 relative to the solenoid axis at SOL with GEO = 1.",
          "GEO DX DY DPY CHI1",
          {}},

         {"DPY",
          "\
An offset of the design ORBIT angle CHI2 relative to the solenoid axis at SOL with GEO = 1.",
          "GEO DX DY DPX CHI2",
          {}},

         {"F1",
           "\
The length of fringe of the solenoid field. It affects only the EMITTANCE calculation. If F1 = 0 (default), no radiation arises at the fringe.",
           "",
           {}},

         {"DISFRIN",
     EquAlign["Text[\
Disables the nonlinear fringe of solenoid if nonzero. The default is 0. The transformation for the nonlinear fringe is expressed by\n\
\\begin{align}\n\
\\exp(:H:)\ ,\\qquad H = -B_z/(8p^2B\\rho) p_\\phi p_r,\
\\end{align} where\
\\begin{align}\n\
   p_\\phi &= xp_y - yp_x\\ ,\\\\\n\
   p_r   &= xp_x + yp_y\\ ,\n\
\\end{align} whose canonical partners are\n\
\\begin{align}\n\
   \\phi &= {\\tt ArcTan}[y/x]\\ ,\\\\\n\
   r   &= {\\tt Log}[x^2 + y^2]/2\\ ,\n\
\\end{align} respectively.\
;;;5]","\
Disables the nonlinear fringe of solenoid if nonzero. The default is 0. The transformation for the nonlinear fringe is expressed by\n\n\
   exp(:H:) ,\n\
   H = -Bz/(8 Brho p^2) p_phi p_r, \n\n\
where\n\n\
   p_phi = x py - y px ,\n\
   p_r   = x px + y py ,\n\n\
whose canonical partners are\n\n\
   phi = ArcTan[y/x] ,\n\
   r   = Log[x^2 + y^2]/2 ,\n\n\
respectively."],
          "",
          {}}}]
       },

       {"COORD",
        "\
An element for an arbitrary coordinate transformation. This element can be used to express an off-axis element.\n\n\
Usage: COORD name=(DX=dx DY=dy CHI1=chi1 CHI2=chi2 CHI3=chi3 DIR=dir); .\n\n\
If dir is zero (default), the transformation of the coordinate by COORD is\n\n"//EquAlign["\
\\left(\\begin{matrix} x \\\\y\\\\z\\end{matrix}\\right)_1=\n\
\\left(\\begin{matrix} c_3 & -s_3 & 0\\\\s_3 & c_3 & 0 \\\\0&0&1\\end{matrix}\\right)\n\
\\left(\\begin{matrix}1&0&0\\\\0&c_2&s_2 \\\\0&-s_2&c_2\\end{matrix}\\right)\n\
\\left(\\begin{matrix}c_1&0&s_1\\\\0&1&0\\\\-s_1&0&c_1\\end{matrix}\\right)\n\
\\left(\\begin{matrix} x-{\\tt DX} \\\\y-{\\tt DY}\\\\z\\end{matrix}\\right)_0\\ ,","\
  {x      {c3 -s3 0     {1  0  0      {c1 0  s1   {x-dx\n\
   y   =   s3  c3 0      0  c2 s2      0  1  0     y-dy\n\
   z}_1      0   0  1}.    0 -s2 c2}.   -s1 0  c1}.  z   } ,"]//"\n\n\
and if dir is nonzero,\n\n"//EquAlign["\
\\left(\\begin{matrix} x \\\\y\\\\z\\end{matrix}\\right)_1=\n\
\\left(\\begin{matrix} c_3 & -s_3 & 0\\\\s_3 & c_3 & 0 \\\\0&0&1\\end{matrix}\\right)\n\
\\left(\\begin{matrix}1&0&0\\\\0&c_2&-s_2 \\\\0&s_2&c_2\\end{matrix}\\right)\n\
\\left(\\begin{matrix}c_1&0&s_1\\\\0&1&0\\\\-s_1&0&c_1\\end{matrix}\\right)\n\
\\left(\\begin{matrix} x \\\\y\\\\z\\end{matrix}\\right)_0+\n\
\\left(\\begin{matrix} {\\tt DX} \\\\-{\\tt DY} \\\\0\\end{matrix}\\right)\\ ,","\
  {x      { dx    {c3 -s3 0     {1  0   0      {c1 0  s1   {x\n\
   y   =   -dy  +  s3  c3 0      0  c2 -s2      0  1  0     y\n\
   z}_1     0 }    0   0  1}.    0  s2  c2}.   -s1 0  c1}.  z} ,"]//"\n\n\
where {x, y, z}_1 are the new coordinates and\n\n"//EquAlign["\
c_{1,2,3}=&\\cos({\\tt CHI1},{\\tt CHI2},{\\tt CHI3})\\ ,\\\\\n\
s_{1,2,3}=&\\sin({\\tt CHI1},{\\tt CHI2},{\\tt CHI3})\\ .","\
  c1=cos(chi1), s1=sin(chi1), etc."]//"\n\n\
Note that these transformationis are NOT the inverse to each other.\n\n\
   To use this element, you have to calculate the values of those parameters carefully. DISP G may help you but there is no automatic way to get them. You may also have to be careful when you use a line with this element in the reverse direction.\n\n\
   A better way to do an equivalent thing in most cases is to use SOL. Unlike COORD, SOL automatically determines the parameters for the coordinate transformation.",
        "SOL DISPLAY(DISP)",
        {}},

       {"CAVI",
        "Accelerating structure.",
        "",
        Sort[
        {L$Message,

         ROTATE$Message,

         DX$Message,

         DY$Message,

         DISFRINCAV$Message={"DISFRIN",
          "\
If nonzero, the Maxwellian fringe is suppressed. The effects of DISFRIN and FRINGE are summarized as\n\n\
             DISFRIN=0          DISFRIN<>0\n\
FRINGE=0    entr & exit            none\n\
FRINGE=1       entr                none\n\
FRINGE=2       exit                none\n\
FRINGE=3    entr & exit            none",
          "FRINGE",
          {}},

         {"VOLT",
          "Accelerating peak voltage in Volt.\n\n"//
          (Acc$Message=EquAlign["\
\\varDelta E =& - e*\\left({\\tt VOLT}+{\\tt DVOLT} +{\\tt V1}\\ x+\\frac{{\\tt V20}\\ x^2+{\\tt V02}\\ y^2}{2}+{\\tt V11}\\ x y\\right)\\\\\n\
&\\times \\sin(2\\pi\\ {\\tt FREQ}(t-t_s) + {\\tt PHI} + {\\tt DPHI})\\ ,","\
     dE = - e*(VOLT+DVOLT +V1 x+V20 x^2/2+V11 x y+V02 y^2/2)\n\
                *Sin[2 Pi FREQ (t-ts) + PHI + DPHI],"])//"\n\n\
where ts is the equilibrium time determined by the valance between the acceleration and the radiation loss around the ring. (CAVI only) The non-relativistic corrections\n\n\
     (VOLT+DVOLT)*(2 Pi FREQ/c)^2/(gamma beta)^2/4 are\n\n\
automatically added to V20 and V02, respectively. The Lorentz factor is evaluated as inverse of average of 1/(beta gamma) at the entrance and the exit.\n\
   CAVI includes the edge effect at the lowest order, given by a Hamiltonian at the entrance edge at s0:\n\n\
   Hf = - (e (VOLT+DVOLT)/L)(Sin(omega t - dphi) + Sin(dphi) - offset) (x^2+y^2)/4 delta(s-s0)\n where dphi and offset are determined by the cavity phase and the radiation loss, which is nonzero only in the case of NORAD. The sign flips at the exit. This Hamiltonian should be consistent with what Kiyoshi Kubo derived.",
          "DVOLT",
          {}},

         {"DVOLT",
          "\
Additional accelerating voltage to be added to VOLT without affecting the design momentum.",
          "VOLT",
          {}},


         FREQ$Message={"FREQ",
          "\
 Rf frequency. If this keyword is nonzero, the keyword HARM is ignored.\n"//
          Acc$Message,
          "HARM",
          {}},

         HARM$Message={"HARM",
          "\
 A harmonic number. This is valid only when FREQ is zero.",
          "FREQ",
          {}},

         {"V1",
          "\
 The linear x-dependence of the acceleration. Tracking only.\n"//Acc$Message,
          "VOLT DVOLT V1 V11 V02",
          {}},

         {"V11",
          "\
 The xy-dependence of the acceleration. Tracking only.\n"//Acc$Message,
          "VOLT DVOLT V1 V20 V02",
          {}},

         {"V02",
          "\
 The y^2-dependence of the acceleration. Tracking only.\n"//Acc$Message,
          "VOLT DVOLT V1 V20 V11",
          {}},

         {"PHI",
          "\
 Relative phase offset. The stable synchrotron phase above the transition is near PHI = 0. The acceleration is given by \n\n"//Acc$Message//"\n\n\
where ts is the equilibrium time determined by the valance between the acceleration and the radiation loss around the ring.",
          "FREQ VOLT DVOLT V1 V20 V11",
          {}},

         {"DPHI",
          "\
 Relative phase offset. The stable synchrotron phase above the transition is near PHI = 0. The acceleration is given by \n\n"//
Acc$Message//"\n\n\
where ts is the equilibrium time determined by the valance between the acceleration and the radiation loss around the ring. DPHI is not taken into account to determine the design momentum p0(s).",
          "FREQ VOLT DVOLT V1 V20 V11",
          {}}

          }]},

       {"MULT",
        "\
A magnet with multipoles. Note that the reference plane is defined so that the skew quadrupole component becomes zero.\n\
   It can have a nonzero ANGLE to express a combined function bending magnet with multipoles. Note that the definition of the multipoles with nonzero ANGLE is very special The current version does not allow nonzero ANGLE inside a solenoid or with acceleration. Also the fringe field and emittance calculation are not installed properly for nonzero ANGLE.",
        "multipole_with_nonzero_ANGLE",
        ReleaseHold[Sort[
        {L$Message,

          ANGLE$Message,

          E1$Message,

          E2$Message,

          AE1$Message,

          AE2$Message,

         {"misalignments",
          "\
Misalignments of a MULT element are expressed by the keywords DX, DY, DZ, CHI1, CHI2, and ROTATE(=CHI3). They specify all misalignments of a rigid body,  At the entrance of MULT, the coordinates of a particle are transformed as\n\n"//EquAlign["\
\\left(\\begin{matrix}x\\\\y\\\\\\varDelta s\\end{matrix}\\right)_1=\n\
\\left(\\begin{matrix} c_3 & -s_3 & 0\\\\s_3 & c_3 & 0 \\\\0&0&1\\end{matrix}\\right)\n\
\\left(\\begin{matrix}1&0&0\\\\0&c_2&-s_2 \\\\0&s_2&c_2\\end{matrix}\\right)\n\
\\left(\\begin{matrix}c_1&0&-s_1\\\\0&1&0\\\\s_1&0&c_1\\end{matrix}\\right)\n\
\\left(\\begin{matrix} x-{\\tt DX} \\\\y-{\\tt DY}\\\\-{\\tt DZ}\\end{matrix}\\right)_0\\ ,","\
   { x  }    {  c3 -s3  0  } {  1   0   0  } {  c1  0  -s1 } { x - DX }\n\
   { y  }  = {  s3  c3  0  } {  0   c2 -s2 } {  0   1   0  } { y - DY }\n\
   { ds }1   {  0   0   1  }.{  0   s2  c2 }.{  s1  0   c1 }.{   - DZ } ,"]//"\n\n\
where c1 and s1 are Cos[CHI1] and Sin[CHI1], etc. The inverse is applied at the exit.\n\
   Those misalignments are also valid within a solenoid.\n\
   Other straight elements such as QUAD or THIN do not and will not have these full misalignment specifications, because they can be substituted by MULT.\n\
   The geometry of the design orbit is determined by the saved values of CHI1, CHI2, and DZ, while the current values are used for DX, DY, and ROTATE.",
          "",
          {}},

         {"multipole_with_nonzero_ANGLE","\
The multipoles in MULT with nonzero ANGLE are defined by\n\n"//EquAlign["\
H =& ... + A_s(x, y)\\ ,\\\\\n"//
"A_s(x, y) =& \\sum_{k,n=0}^\\infty g_{kn} \\frac{{\\tt K}n + i {\\tt SK}n}{(n + 1)!} (\\rho + x)^{1/2 - k}\
\\times \\frac{(x + i y)^{n + k}}{\\sqrt\\rho}\\ ,\\\\\n"//
"{\\rm with\\ }g_{kn}\\equiv& - \\frac{(2k - 1)!! (2k - 3)!! (n + 1)!}{8^k (n + k + 1)! k!}\\ ,\\\\\n\
\\rho\\equiv&\\frac{\\tt L}{\\tt ANGLE}\\ .","\
   H = ... + As(x, y) ,\n\n"//
"   As(x, y) = Sum[ g_kn (Kn + I SKn)/(n + 1)! (rho + x)^(1/2 - k)\n\
                  * (x + I y)^(n + k) / rho^(1/2),\n\
                  {k, 0, Infinity}, {n, 0, nmax}]\n\n"//
"with   g_kn = - (2k - 1)!! (2k - 3)!! (n + 1)! / (8^k (n + k + 1)! k!) ,\n\
and    rho = L/ANGLE ."]//"\n\
Actually the summation is truncated at n + k <= 21 in the current version. While this definition converges to the regular one for multipoles when ANGLE -> 0, K0 and K1 of MULT are different from those of BEND.",
         "ANGLE",
         {}},

         SKn$Message[n_]:=
         {"SK"//n,
          "\
The skew "//N$pole[2(n+1)]//" magnetic field component (times the length L).\n"//EquAlign["\
{\\tt SK"//n//"} = \\frac{B"//N$deriv[n]//"{\\tt L}}{B\\rho}\\ ,","\
   SK"//n//" = B^("//n//")L/(Brho),"]//"\n\n\
where L is the length of the component. Positive sign means a horizontally focusing magnet rotated around z-axis by -90/"//n+1//" degree, i.e., ROTATE = "//90/(n+1)//" DEG .",
          "L",
          {}};
         Hold[Apply[Sequence,
           Flatten[Table[{Kn$Message[i],SKn$Message[i]},{i,0,21}],1]]],

         {"RADIUS",
          "Radius of the vacuum chamber. Effective when SPAC is ON.",
          "SPAC",
          {}},

         {"F1",
          F1F2$Message,
          "F2 FRINGE",
          {}},

         {"F2",
          F1F2$Message,
          "F1 FRINGE",
          {}},

         {"FB1",
          "Linear Fringe length F1 for the K0 component at the entrance.",
          "BEND F1 FB1",
          {}},

         {"FB2",
          "Linear Fringe length F1 for the K0 component at the exit.",
          "BEND F1 FB2",
          {}},

         {"VOLT",
          "Accelerating peak voltage in Volt.\n"//
          Acc$Message//"\n\n\
where ts is the equilibrium time determined by the valance between the acceleration and the radiation loss around the ring.",
          "DVOLT",
          {}},

         {"DVOLT",
          "\
Additional accelerating peak voltage to be added to Volt, without affecting the design momentum p0(s).",
          "VOLT",
          {}},

          FREQ$Message,

          HARM$Message,

         {"PHI",
          "\
Relative phase offset. The stable synchrotron phase above the transition is near PHI = 0. \n\
The acceleration is given as \n\n"//Acc$Message//"\n\n\
where ts is the equilibrium time determined by the valance between the acceleration and the radiation loss around the ring.",
           "",
           {}},
      
         {"DPHI",
          "\
Relative phase offset. The stable synchrotron phase above the transition is near PHI = 0. The acceleration is given as \n\n"//Acc$Message//"\n\n\
where ts is the equilibrium time determined by the valance between the acceleration and the radiation loss around the ring. DPHI is not taken into account to determine the design momentum p0(s).",
          "FREQ VOLT DVOLT V1 V20 V11",
          {}},

         FRINGEQ$Message,

         DISFRINQ$Message,

         DISRAD$Message}]]
         },

       {"MARK",
        "\
MARK elements play special roles in FFS:\t\n\n\
(1) The first element of the beam line must be a MARK element to be used by FFS. In this case the MARK element contains the parameters of the incoming beam (see optical-functions, special-variables EMITX, EMITY, DP). \n\
(2) The calculated optical parameters at a MARK command is saved by SAVE or STOP commands, then it can be used as the incoming condition of other beam lines which have the same MARK element.\t\n\n\
Example: MARK P1 = (EMITX = .. EMITY = .. DP = ..);\n\
         LINE  A = ( .. P1 ..)\n\
               B = (P1 .. );\n\
         FFS USE = A;\n\
             ...           do matching on LINE A\n\
             SAVE P1       save the parameters at P1\n\
             USE B;        switch to LINE B\n\
             ...           do matching of LINE B whose entrance is to be\n\
                           matched P1.\t\n\n\
(3) If a MARK element has keyword GEO nonzero, this MARK element becomes the origin of the geometric rotation after the last SOL element.\n\
(4) The values of optical-functions of the MARK element at the beginning of the beam line can be specified as matching variables by the FREE command.\t\n\n\
 A MARK elements have all optical-functions as its keywords except NX, NY, TRX, TRY, and LENG. Also it has keywords EMITX, EMITY, and DP which give the values of the corresponding special-variables.",
       "SAVE USE optical-functions SOL special-variables EMITX EMITY DP",
       {{"OFFSET",
         "\
OFFSET is a relative position from the current position. A fraction is allowed to specify a location within an element.\n\
   If the MARK at the beginning of a beam line has OFFSET nonzero, the optics calculation starts from the shifted location. If the last component of a beam line is a MARK with nonzero OFFSET, the optics calculation stops at the shifted location. The periodic condition is applied between those shifted locations.\n\
   The geometric origin and the origin of LENG shift to the first MARK.\n\n\
Examples:\n\
(1)  LINE A    = ( ...  QF PQFC  ... );\n\
     QUAD QF   = (L=0.3 K1=0.2);\n\
     MARK PQFC = (OFFSET = -0.5);\n\n\
Here PQFC represents the center of QF.\n\n\
(2)  LINE A    = ( ...  PQFC QF  ... );\n\n\
     QUAD QF   = (L=0.3 K1=0.2);\n\
     MARK PQFC = (OFFSET =  1.5);\n\
Here PQFC represents the center of QF, too (consider why). The value of OFFSET is interpreted taking the direction of the LINE into account, i.e., a MARK in a line A represents the same location in a line -A.\n\n\
Restrictions:\n\
(1) Function TrackParticles does not take OFFSET into account if the start\n\
    or stop location is in the midst of a beam line and a Mark with nonzero\n\
    OFFSET, in the current version. Tracking for entire beam line or\n\
    MEASURE(MEA) command supports OFFSET.\n\
(2) The outputs by DISPLAY(DISP) outside of the narrowed region by OFFSET are\n\
    meaningless.",
        "",
        {}}}}
       }]},

   {"MATRIX(MAT)",
    "Usage: MATRIX [{SYMPLECTIC(S) | PHYSICAL(P)}] [from to]\n\n\
prints out the 4 by 5 (w/CALC4D) or 6 by 6 (w/CALC6D) transfer matrix from from-component to to-component. If SYMPLECTIC(S) is specified (default), the symplectic transfer matrix on {x,px/p0,y,py/p0,dp/p0} where p0 is the nominal momentum at the entrance, is given. Otherwise, in the case of TRPT, the transfer matrix on {x,px/p0(s),y,py/p0(s),dp/p0(s)} is printed out.\n\
   If the from- and to- components are omitted, entire beam line is assumed.\n\
If to-component is upstream the from-component, it gives the inverse matrix (TRPT) or one-turn-wrapped matrix (RING).",
    "DISPLAY(DISP) TRPT RING CALC4D CALC6D TransferMatrix",
    {}},

   {"CHROMATICITY(CHRO)",
    "CHRO prints out the chromaticity of QUAD and SEXT in the entire beam line using the simplest formula:\n\n\
     xi_{x,y}=Integrate[-(K1/L) beta_{x,y}(s) ds] for QUAD,\n\
     xi_{x,y}=Integrate[-(K2/L) eta_x (s) beta_{x,y}(s) ds] for SEXT.\n\n\
These formula are not valid when there is x-y coupling or vertical dispersion.",
    "",
    {}},

   {"RADINT",
    "RADINT prints out the radiation integrals involving the x-coupling for all components of the beam line.",
    "",
    {}},

   {"SEED",
    "The SEED command is obsolete. Use SeedRandom[] function instead of SEED.",
    "MEASURE(MEA) FIXSEED MOVESEED SeedRandom",
    {}},

   {"VARY",
    "Usage: VARY keyword element-pattern\n\n\
changes the default-keyword of the elements which match element-pattern to keyword.",
    "FREE elements wildcards",
    {}},

   {"REJECT(REJ)",
    "\
Usage: (1) REJ matching-function-pattern [matching-function-pattern1..]\n\
       (2) REJ TOTAL\n\
       (3) REJ TOTALFIT\n\n\
rejects the matching-functions which match matching-function-pattern at the current FIT location. If TOTAL or TOTALFIT is given, the entire matching conditions in all locations are rejected, then output parameters by CALCULATE are reset when TOTAL is given.",
    "matching-function-commands FIT wildcards",
    {}},

   {"COUPLE(COUP)",
    "\
   Usage: COUP slave-element master-element coefficient\n\n\
sets the value of the default-keyword of slave-element to be equal to coefficient times the value of the default-keyword of master-element. COUPLE(COUP) cannot be cascaded. The master-element cannot be COUPLEd to any other element. To reset COUPLE, say COUP slave-element slave-element 1.\n\
 Consider ElementValues to define universal coupling for any keywords.",
    "ATTRIBUTE(ATTR) FREE ElementValues",
    {}},

   SHOW$message="   FFS[\"SHOW\"] or FFS$SHOW[] returns the current matching conditions as a list. Each element has a form of\n\n\
{component1, component2, function, goal-value, number-of-momentums, scale},\n\n\
which corresponds to the format of the print-out by SHOW.";
   {"SHOW",
    "\
SHOW prints out the current matching conditions.\n\n"//SHOW$message,
    "matching-function-commands FIT FFS FFS$SHOW",
    {}},

   {"STATUS(STAT)",
    "STAT shows the current settings of flags, fit points, \n\
special-variables, the region for DISPLAY, seed of the random number generator, and elapsed CPU time, etc.",
    "special-variables flags",
    {}},

   {"REVERSE(REV)",
    "REV changes the sign of AX, AY, EPX, EPY, R2, R3, DPX, DPY at the\n\
entrance of the beam line.",
    "matching-function-commands",
    {}},

   {"DRAW",
    "\
Usage: DRAW [begin end] fun1 [fun2..] [& fun11 [fun12..]] [element-pattern]\n\n\
draws a plot of optical functions in multi columns. It calls OpticsPlot internally. Available functions are all matching-functions (except LENG, TRX, TRY, GX, GY, GZ, CHI1, CHI2, CHI3) and additional functions. If functions are separated by ampersand (&), these are plotted in a separated window.\n\
  Function name preceded by \"R\" and \"D\" refer the reference optics and the difference, respectively.\n\
  If begin- and end-components are specified, the plot region is limited between them. If the end-component comes earlier than the begin-components, it wraps the plot around the beam line.\n\
  If the optional element-pattern is given, it draws the beam-line lattice with the labels for elements which match element-pattern. If LAT is specified for element-pattern, the lattice is drawn without label.\n\
 A character string assigned to TITLE is shown as the FrameLabel on the top of the plot.\n\n\
 Example:\n\
   TITLE=\"FCCee_t_202_nosol_16_ipac.sad\";\n\
   Draw$Option={Thickness->2};\n\
   DRAW BX BY & EX EY Q*;\n\n\
<DRAW.png",
    "OpticsPlot special-variables TITLE matching-function-commands OUTPUT(OUT) TERMINATE(TERM) GEO DISPLAY(DISP) wildcards",
    Sort[{
      {"Draw$Option",
        "\
 Draw$Option is a list of rules to specify Graphics options for the entire DRAW. If you need option for each column, use OpticsPlot",
        "DRAW OpticsPlot Graphics REFERENCE(REF)",
        {}}

      }]},

   {"PRINT(PRI)",
    "PRI expression evaluates expression and prints out the result.",
    "expression Print",
    {}},

   {"IF",
    IF$Message=
    "\
Usage: IF expr1 body1 [ELSEIF expr2 body2 [ELSEIF ..]] [ELSE body3] ENDIF\n\n\
This is a FORTRAN77 like IF-structure. If the expression expr1 is True(==1) or nonzero, executes commands in body1. If it is False(==0), skip commands until ELSE, ELSEIF or ENDIF appears at the same level of the IF-structure, and executes commands after ELSE or ENDIF, or executes the ELSEIF command. If expr1 is not a real number, an error message is printed and ignores the command line.",
    "ELSE ELSEIF ENDIF expression command-syntax If",
    {}},

   {"ELSE",
    IF$Message,
    "If ELSEIF ENDIF",
    {}},

   {"ELSEIF",
    IF$Message,
    "IF ELSE ENDIF",
    {}},

   {"ENDIF",
    IF$Message,
    "IF ELSE ELSEIF",
    {}},

   {"REPEAT(REP)",
    REPEAT$Message=
    "\
Usage: REP [n] body UNTIL [expr1]\n\n\
executes commands in body n times until expr1 gives nonzero. The number n can be any expression which gives a number. If n is omitted, infinity is assumed. If expr1 is omitted, False(==0) is assumed.",
    "UNTIL",
    {}},

   {"UNTIL",
    REPEAT$Message,
    "REPEAT expression command-syntax functions Do",
    {}},

   {"MEASURE(MEA)",
    "\
Usage: MEA [end-component] [OUT file plot-spaces]\n\n\
tracks particles from the entrance to end-component and prints out the statistics at the end. If end-component is omitted, the component end used in the last MEASURE(MEA) (default: end of the beam line) is assumed.\n\
   If OUT file plot-spaces are attached, it plots phase space distribution on file. The phase-spaces are specified like as X-PX, \n\
or X-Y, etc., (up to any numbers).\n\
   Parameters for the tracking are specified by special-variables and flags:\n\n\
seed for the random-number generator:\n\
     SeedRandom[seed_Real] or SeedRandom[{seeds__Real}]\n\n\
special-variables (can be set with =):\n\
     NP        number of particles \n\
     EMITX     horizontal emittance\n\
     EMITY     vertical emittance\n\
     DP        relative momentum spread\n\
     DP0       relative momentum offset dp/p0\n\
     GCUT      cut-off value of the Gaussian tail\n\
flags:\n\
     GAUSS/UNIFORM    Gaussian/uniform(default) momentum distribution\n\
     JITTER/NOJITTER  off(default)/on nullifying the incoming centroid offset\n\
     RFSW/NORFSW      switch on(default)/off the rf-cavities\n\
     RAD/NORAD        synchrotron radiation on/off\n\
     RADCOD/NORADCOD  off/on compensation of energy loss due to radiation\n\
     FIXSEED/MOVESEED keep(default)/unkeep the initial random-number seed\n\n\
   The initial transverse distribution is Gaussian.",
    "special-variables TrackParticles SeedRandom RESULTOFTRACKING",
    {}},

   {"matching-function-commands",
    "\
Usage: (1) matching-function  goal-value [off-momentum-points]\n\
       (2) matching-functionM goal-value [off-momentum-points]\n\
       (3) matching-functionI incoming-value\n\
       (4) matching-functionSCALE scale\n\n\
(1) sets the matching condition for matching-function at the current fitting point or region with the goal-value and the off-momentum-points (see off-momentum-matching).\n\
   If off-momentum-points is omitted, the previous value for this matching-function at this fitting-point is assumed. If the previous value is not defined, 1 is assumed. If -1 is given for off-momentum-points, the matching-function is rejected from the matching (see REJECT(REJ)).\n\
   If \"*\" is given for goal-value, the previous value is used if exists.\n\n\
Example:   BX 10 3    (beta_x to be 10 at 3 momenta) \n\
           BX 20      (now beta_x to be 20 at 3 momenta (previous setting))\n\
           BX *  5    (now beta_x to be 20 (previous setting) at 5 momenta)\n\n\
(2) If the letter \"M\" is appended to matching-function, it means the maximum-fitting for the function. The maximum of either the value (for positive-definite functions) or the absolute value (for bipolar functions) are to be limited in the matching.\n\n\
(3) If the letter \"I\" is appended to matching-function, it specifies the value of the incoming beam.\n\n\
(4) If SCALE is appended to matching-function, it sets the scale of the input/output of the function to scale. This scale is used in the matching-function commands, DISPLAY(DISP), SHOW, etc.\n\
(5) If the current fit location is at a MARK, @ for the goal value refers the save value at the MARK. @- refers -(save value). These are useful to match between two beam lines.\n\n\
   Available matching-functions are:\n\
optical-functions (see optical-functions):\n\
AX BX GMX NX AY BY GMY NY EX EPX EY EPY R1 R2 R3 R4 DETR DX DPX DY DPY DZ DDP PEX PEPX PEY PEPY TRX TRY LENG\n\
geometric-functions (see geometric-functions):\n\
GX GY GZ CHI1 CHI2 CHI3",
    "FIT GO SHOW MARK optical-functions geometric-functions off-momentum-matching x-y-coupling REJ special-variables DP functions FitValue MatchingAmplitude",
    {}},

    {"off-momentum-matching",
     "\
FFS matches the optical functions for an orbit with finite momentum deviation.\n\n\
Example: \n\
   DP=0.01;      sets the range of momentum to DP0-0.01 < dp/p0 < DP0+0.01 .\n\
   BX 10 9;      sets the goal of betax to 10 m, at 9 points.\n\
                 in the range above, i.e.,\n\
                 dp/p0 = {-0.01,-0.0075,-0.005,-0.0025,0,\n\
                          0.0025,0.005,0.0075,0.01} + DP0 .\n\
   GO starts the matching.\n\n\
As this example, the off-momentum points are chosen with equal separation. If the off-momentum point n is an even number, the chosen points are same as the case of n+1, but the on-momentum point (==DP0) is excluded.",
     "matching-function-commands DP DP0",
     {}},

    {"optical-functions",
     "Available optical functions for matching are:\t\n\n\
AX      alpha_X\n\
BX      beta_X\n\
GMX     gamma_X\n\
NX      psi_X, the default scale is 1/(2Pi)\n\
AY      alpha_Y\n\
BY      beta_Y\n\
GMY     gamma_Y\n\
NY      psi_Y, the default scale is 1/(2Pi)\n\
EX      eta_X   (dispersion_X)\n\
EPX     eta_Px  (dispersion_PX) \n\
EY      eta_Y   (dispersion_Y)\n\
EPY     eta_Py  (dispersion_PY)\n\
R1      R_1     (see x-y-coupling)\n\
R2      R_2     (see x-y-coupling)\n\
R3      R_3     (see x-y-coupling)\n\
R4      R_4     (see x-y-coupling)\n\
DETR    R_1*R_4 - R_2*R_3 (see x-y-coupling)\n\
DX      dx\n\
DPX     dpx\n\
DY      dy\n\
DPY     dpy\n\
DZ      dz\n\
DDP     delta=dp/p0\n\
AZ      alpha_Z\n\
BZ      beta_Z\n\
GMZ     gamma_Z\n\
NZ      psi_Z, the default scale is 1/(2Pi)\n\
ZX      zeta_X  (z-dispersion_X)\n\
ZPX     zeta_Px (z-dispersion_PX) \n\
ZY      zeta_Y  (z-dispersion_Y)\n\
ZPY     zeta_Py (z-dispersion_PY)\n\
PEX     eta_x   (dispersion_x)\n\
PEPX    eta_px  (dispersion_px) \n\
PEY     eta_y   (dispersion_y)\n\
PEPY    eta_yy  (dispersion_py)\n\
TRX     trace(T_X), only defined at the end of the beam line.\n\
TRY     trace(T_Y), only defined at the end of the beam line.\n\
LENG    length of the design orbit\t\n\n\
In the above, upper case X, Px, Y, Py represents the x-y decoupled coordinate. EX, EPX, EY, EPY refer the decoupled coordinate, while PEX, PEPX, PEY, PEPY are in the physical coordinate. On the other hand,  DX, DPX, DY, DPY refer the physical coordinate.",
    "geometric-functions x-y-coupling matching-function-commands \
GO CAL DISPLAY(DISP) SHOW",
    {}},

   {"geometric-functions",
    "Available geometric-functions are:\n\n\
GX      geometrical coordinate xi\n\
GY      geometrical coordinate eta\n\
GZ      geometrical coordinate zeta\n\
CHI1    geometrical rotation angle ch1_1\n\
CHI2    geometrical rotation angle ch1_2\n\
CHI3    geometrical rotation angle ch1_3\n\n\
The geometrical coordinate {xi, eta, zeta} is set by the ORG command, and its default origin is at the entrance of the beam line, and the default directions are xi in s-direction, eta in -(x-direction), and zeta in -(y-direction) at the entrance. The set {xi, eta, zeta} forms a right-hand system.\n\
   The rotation angles are defined so as to give the local {x,y,s} is written\n\n\
    {x, y, s}_local\n\
   = rotate[s, chi3] rotate[x, chi2] rotate[y, -chi1]{x, y, s}_origin,\n\n\
where rotate[a, b] reads \"rotate around the new-a vector by b right-handedly.\n\n\
geometric functions disignate the geometry of the coordinate. If the geometry of orbit is needed, use LINE[\"OGEO\"], etc., or DISP OG.",
    "optical-functions matching-function-commands DISPLAY(DISP) GEOCAL GEOFIX ORG LINE",
    {}},

   {"flags",
    "Usage: [NO]flag\n\n\
turns the flag on. If NO is prepended to flag, the flag is turned off. Some flags have antonym which works in the opposite way. Flags can be accessed in the function-syntax with the form ?flag, which returns True (=1) when the flag is on, or False (=0) otherwise. Some flags can be accessed by the ON/OFF commands at the MAIN level.\n\
 Status of all flags are displayed by the STATUS(STAT) command.",
    "STAT PatternTest",
    Sort[
    {{"RAD",
      "RAD turns on the synchrotron radiation in the particle-tracking. Accessible in the MAIN level.",
      "RADCOD FLUC",
      {}},

     {"ECHO",
       "\
ECHO enables the echo of the main input in the MAIN level.",
       "",
       {}},

      {"LOG",
        "\
LOG enables the echo of all inputs in the MAIN level. Also suppresses the prompt in FFS.",
        "ECHO",
        {}},

      {"INTRES",
        "\
In the case of CELL, if the total tune deviates across an integer resonance, or the trace is larger than 2, it is counted as unstable (~?STABLE). Otherwise the optics is recognized as STABLE. The default is INTRES.",
        "HALFRES SUMRES DIFFRES STABLE",
        {}},

      {"HALFRES",
        "\
In the case of CELL, if the total tune deviates across a half-integer resonance, or the traces is less than -2, it is counted as unstable (~?STABLE). Otherwise the optics is recognized as STABLE. The default is HALFRES.",
        "INTRES SUMRES DIFFRES STABLE",
        {}},

      {"SUMRES",
        "\
In the case of CELL, if the total tune deviates across a sum resonance, it is counted as unstable. The default is SUMRES.",
        "INTRES HALFRES DIFFRES STABLE",
        {}},

      {"DIFFRES",
        "\
In the case of CELL, if the total tune deviates across a difference resonance, it is counted as unstable. The default is NODIFFRES.",
        "INTRES HALFRES SUMRES STABLE",
        {}},

     {"RFSW",
      "\
RFSW turns on the acceleration by CAVI and TCAVI element in the particle-tracking and the emittance calculation. Accessible in MAIN level, but FFS always turns RFSW on at the beginning of the session.",
      "",
      {}},

     {"RADCOD",
      "RADCOD turns on the energy loss due to synchrotron radiation at the closed-orbit in the emittance calculation. Also turns off the implicit acceleration in the tracking to compensate the energy loss automatically, in the case that TRPT is ON. Accessible in MAIN level.",
      "RAD FLUC TRPT",
      {}},

     {"RADTAPER",
      " Scales all magnets except for solenoids according to the local momentum (DDP) of the closed orbit. It uses the average of DDPs at the entrance and the exit. For tracking, RADCOD and ( CAL/GO with CALC6D or EMIT(Emittance[]) ) is necessary. CAL/GO with CALC4D will clear the necessary information for tracking with RADTAPER.\n\
 RADTAPER sets the momentum deviation of the closed orbit to DP0, which is an arbitrary choice of an under-deterministic problem of tapering. Thus the difference in the path length around the ring is adjusted by automatically updating FSHIFT.",
      "RADCOD CALC6D CALC4D EMIT CAL GO DP0 FSHIFT",
       {}},

     {"COD",
      "COD turns on finding the closed-orbit in the emittance calculation. Accessible in MAIN level.",
      "EMITTANCE(EMIT)",
      {}},

     {"INTRA",
      "INTRA turns on the calculation of intra-beam scattering in the emittance calculation. Accessible in MAIN level.",
      "EMITTANCE(EMIT) Emittance equilibrium-beam-envelope",
      {}},

     {"TRPT",
      "TRPT or NORING declares that the beam line is a transport line, not a part of a storage ring. The nominal momentum be changed in the beam line due to acceleration. The default momentum distribution becomes uniform distribution. The default is RING or NOTRPT. TRPT affects Emittance[] to ignore equilibrium calculation for a transport line.",
      "DISPLAY(DISP) RING UNIFORM GAUSS",
      {}},

     {"EMIOUT",
      "EMIOUT turns on the extended output of emittance calculation.\n\
Accessible in the MAIN level.",
      "EMIT",
      {}},

     {"GAUSS",
      "GAUSS or NOUNIFORM sets the momentum distribution of the incoming beam to be Gaussian, otherwise uniform(square) distribution is assumed. It affects the beam size calculated by Twiss parameters.",
      "UNIFORM MEASURE(MEA) BEAM special-variables DP",
      {}},

     {"BIPOL",
      "BIPOL or NOUNIPOL allows the change of sign of the value of the element during the matching. It affects the default keywords of all elements. This is overridden by MIN, MAX specification or VariableRange of each element.",
      "UNIPOL default-keyword set-value-of-element VariableRange",
      {}},

     {"CELL",
      "CELL or NOINS sets the periodic condition in calculating the optical-functions.",
      "INS CALCULATE(CAL) GO optical-functions matching-function-commands",
      {}},

     {"DAPERT",
      "DAPERT enables the DAPERT procedure in the multi-turn tracking to obtain the dynamic aperture diagram. Accessible in the MAIN level.",
      "functions DynamicApertureSurvey",
      {}},

     {"FIXSEED",
      "FIXSEED or NOMOVESEED disables the change of the seed of the random number generator after the particle tracking.",
      "MOVESEED MEASURE(MEA) SEED",
      {}},

     {"IDEAL",
      "IDEAL or NOREAL inhibits to use the component-specific deviations in the optics calculation.",
      "REAL CALCULATE(CAL) GO",
      {}},

     {"CODPLOT",
      "CODPLOT lets the emittance calculation return the information on the closed-orbit, extended Twiss parameters, and the beam size along the beam line into the FFS optics buffer, which can be shown by DISPLAY(DISP) or DRAW commands as well as Twiss and OpticsPlot functions.",
      "EMITTANCE(EMIT) DISPLAY(DISP) DRAW WSPAC RADTAPER",
      {}},

     {"WSPAC",
      "When on, performs space-charge simulation in a \"strong-weak\" mode. The beam size through the beam line is to be calculated by EMIT with CODPLOT. The space-charge force is calculated assuming Gaussian distribution in all dimensions, and particles/bunch given by PBUNCH. WSPAC is effective in optics and emittance calculations and tracking.\n\
   Do not confuse WSPAC with SPAC.",
      "EMITTANCE(EMIT) PBUNCH CODPLOT MINCOUP SELFCOD SPAC equilibrium-beam-envelope",
       {}},

     {"SELFCOD",
      "When on with WSPAC, in tracking, the space charge force is calculated relative to the center of mass of the current set of particles each time. Otherwise(default) it is calculated relative to the closed orbit given by EMIT. SELFCOD is useful when the closed orbits given by EMIT and TRACK are different.",
      "WSPAC",
       {}},

     {"PSPAC",
      "When on, performs space-charge simulation in a \"Particle-In-Cell\" method. PSPAC is effective in tracking only.\n\
   Do not confuse PSPAC with SPAC/WSPAC.",
      "PSPACNX PSPACNY PSPACNZ PSPACDX PSPACDY PSPACDZ",
       {}},

     {"LWAKE",
      "LWAKE turns on optics calculation with Longitudinal WakeFunction",
      "WakeFunction TrackParticles InitialOrbits TWAKE",
      {}},

     {"TWAKE",
      "TWAKE turns on optics calculation with Transverse WakeFunction",
      "WakeFunction TrackParticles InitialOrbits LWAKE",
      {}},

     {"FLUC",
      "FLUC or NODAMPONLY enables the diffusion due to synchrotron radiation in the particle tracking. Otherwise only the damping is enabled when RAD is ON.",
      "DAMPONLY RAD RADCOD",
      {}},

     {"CMPLOT",
      "CMPLOT enables the shift of the center of mass at the beginning of the tracking. This is almost obsolete.",
      "",
      {}},

     {"ABSW",
      "ABSW or NORELW sets the weights of variable elements independent from their values in the matching. Otherwise they are weighted relatively.",
      "RELW",
      {}},

     {"JITTER",
      "\
JITTER or NOQUIET allows jitter of the center-of-mass of the incoming beam in the case of TRPT. Otherwise the center-of-mass statistically fluctuates depending on the number of particles.",
      "QUIET MEASURE(MEA) TRPT",
      {}},

     {"CONV",
      "CONV is a flag set by the CALCULATE(CAL) or GO commands. It becomes True when MatchingResidual is less than CONVERGENCE.",
      "CALCULATE(CAL) GO MatchingResidual CONVERGENCE",
      {}},
 
     {"STABLE",
      "STABLE is a flag set by the CALCULATE(CAL) or GO commands in the case of CELL. It becomes True when the closed orbit is found and the optics is stable in both x and y.",
      "CALCULATE(CAL) GO INTRES HALFRES SUMRES DIFFRES",
      {}},

     {"PHOTONS",
       "\
When PHOTONS is ON (default is OFF), with RAD and FLUC, TrackParticles generates a list of all photons radiated through the tracking. The list is assigned to a symbol PhotonList.",
       "PhotonList TrackParticles RAD FLUC",
       {}},

     {"RADLIGHT",
      "\
When RADLIGHT is on, the function TrackParticles returns a list of trajectories which are used to calculate the synchrotron radiation field.",
      "TrackParticles RadiationField RadiationSpectrum",
      {}},

     {"SPAC",
      "When SPAC is on, tracking is done with space charge effect. The actual number of particles in the beam and the number of macro particles are given by PBUNCH and NP, respectively. This calculation assumes a cylindrical symmetry of the chamber whose radius is given by RADIUS of DRIFT and MULT elements. If RADIUS is positive, an aperture is also set at RADIUS to make particle loss. If RADIUS is zero, no space charge calculation is done. If RADIUS is negative, no space charge effect is taken, but the aperture is set at -RADIUS.\n\
   Do not confuse SPAC with WSPAC.",
      "NP PBUNCH WSPAC",
       {}},

     {"GEOCAL",
      "\
When GEOCAL is on(default), the geometry of the beam line is always updated by CALCULATE(CAL) or GO commands using the current values of components. The coordinate transformation by SOL is also updated. When GEOCAL is off, the geometry is never updated. It is useful to simulate misalignments within a solenoid, etc.",
      "GEOFIX CAL GO SOL",
      {}},

     {"GEOFIX",
      "GEOFIX is the antonym of GEOCAL.",
      "GEOCAL",
      {}},

     {"SORG",
      "SORG sets the origin of S (design orbit length) at the location set by ORG.",
      "ORG",
      {}},

     {"FFSPRMPT",
      "\
When FFSPRMPT is off(default) the input prompt is In[n]:= , where n is $Line+1. Otherwise the prompt is the traditional FFS prompt, showing the FIT location and the DISP range.",
      "$Line LOG",
      {}},

     {"RING",
      "RING is the antonym of TRPT.",
      "TRPT",
      {}},

     {"UNIFORM",
      "\
UNIFORM is the antonym of GAUSS. It assumes the momentum distribution to be a uniform(square) within +-DP.",
      "GAUSS TRPT",
      {}},

     {"UNIPOL",
      "UNIPOL is the antonym of BIPOL.",
      "BIPOL",
      {}},

     {"INS",
      "INS is the antonym of CELL.",
      "CELL",
      {}},

     {"MOVESEED",
      "MOVESEED is the antonym of FIXSEED.",
      "FIXSEED",
      {}},

     {"REAL",
      "REAL is the antonym of IDEAL.",
      "IDEAL",
      {}},

     {"DAMPONLY",
      "DAMPONLY is the antonym of FLUC.",
      "FLUC",
      {}},

     {"RELW",
      "RELW is the antonym of ABSW.",
      "ABSW",
      {}},

     {"QUIET",
      "QUIET is the antonym of JITEER.",
      "JITTER",
      {}},

     {"UNSTABLE",
      "UNSTABLE is the antonym of STABLE.",
      "STABLE",
      {}},

     {"CALC6D",
      "If CALC6D is on, the optics calculation in CAL and GO performs full 6D calculation, which may takes RADCOD into account. The antonyms is CALC4D. The Default is CALC4D.",
      "CALC4D CAL GO",
      {}},

     {"CALC4D",
      "If CALC4D is on, the optics calculation in CAL and GO performs a 4x5 calculation (4D + dispersion). The antonyms is CALC6D. The Default is CALC4D.",
      "CALC6D CAL GO",
      {}},

      {"POL",
       "\
POL turns on spin tracking and the calculation of equilibrium polarization in EMIT/Emittance[].",
       "RADPOL EMITTANCE(EMIT) Emittance TrackParticles",
        {}},

      {"LOSSMAP",
        "\
If LOSSMAP is on, TrackParticles returns the location and turn where the particle lost is detected, in the 7/9th and 8/10th element of the result, for  NOPOL/POL, respectively. The default is NOLOSSMAP",
        "TrackParticles POL",
        {}},

      {"RADPOL",
       "\
If POL is on, RADPOL turns on Sokolov-Ternov effect in tracking.",
      "POL",
      {}},

     {"CONVCASE",
      "\
When CONVCASE is on, FFS command line parser converts the input characters to the upper case.(Default on) CONVCASE actions for the element names and patterns CAN be overridden by PRSVCASE flag.",
      "PRSVCASE",
      {}},

     {"PRSVCASE",
      "\
When PRSVCASE is on, FFS command line parser preserves the input characters for the element names and patterns.(Default off)",
      "CONVCASE",
      {}},

      {"SUS",
        "If OFF, SUSPEND(SUSP) and END commands have no action. The default is ON.",
        "SUSPEND(SUSP) END",
        {}},

      Null[]}]},

   {"special-variables",
    "\
There are several variables which have special rolls in FFS. Some of them are also accessible in the MAIN level.",
    "constants expression flags",
    Sort[
    {{"EMITX",
      "\
EMITX is a real variable for the horizontal emittance (not normalized by gamma beta). It is automatically set by the keyword EMITX of the MARK element at the beginning of the beam line. The EMITTANCE(EMIT) command returns its calculated value in EMITX. The value of EMITX affects the default weight of variables in the matching. Accessible in MAIN.",
      "EMITY EMITZ SIGZ SIGE DP elements MARK",
      {}},

     {"EMITY",
      "\
EMITY is a real variable for the vertical emittance (not normalized by gamma beta). It is automatically set by the keyword EMITY of the MARK element at the beginning of the beam line. The EMITTANCE(EMIT) command returns its calculated value in EMITY. The value of EMITY affects the default weiht of variables in the matching. Accessible in MAIN.",
      "EMITX EMITZ SIGZ SIGE DP elements MARK",
      {}},

     {"EMITZ",
      "\
EMITZ is a real variable for the longitudinal emittance (not normalized by gamma beta). It is automatically set by the keyword EMITZ of the MARK element at the beginning of the beam line. The EMITTANCE(EMIT) command returns its calculated value in EMITZ. Accessible in MAIN.",
      "EMITX EMITY SIGZ SIGE DP elements MARK",
      {}},

      {"SIGZ",
        "\
 SIGZ is the equilibrium bunch length at the entrance of the beam line calculated by EMIT/Emittance[SaveEMIT->True].",
        "EMITX EMITY EMITZ SIGE EMIT Emittance",
        {}},

      {"SIGE",
        "\
 SIGE is the equilibrium momentum spread at the entrance of the beam line calculated by EMIT/Emittance[SaveEMIT->True].",
        "EMITX EMITY EMITZ SIGZ EMIT Emittance",
        {}},

      {"DTSYNCH",
        "\
 DTSYNCH is the equilibrium arrival time advance (= -c*delta t, in meter) where the synchrotron radiation loss balances with the RF, calculated by EMIT/Emittance[SaveEMIT->True]. This corresponds to the origin of the RF phase. The default is zero.",
        "EMITX EMITY EMITZ SIGZ SIGE EMIT Emittance PHICAV",
        {}},

     {"EMITXE",
      "\
EMITXE specifies the minimum horizontal emittance for EMITTANCE(EMIT) and Emittance[] calculations. It is useful to give emittance determined externally, such as for proton machines.",
      "EMITYE EMITZE",
      {}},

     {"EMITYE",
      "\
EMITYE specifies the minimum vertical emittance for EMITTANCE(EMIT) and Emittance[] calculations. It is useful to give emittance determined externally, such as for proton machines.",
      "EMITXE EMITZE",
      {}},

     {"EMITZE",
      "\
EMITZE specifies the minimum longitudinal emittance for EMITTANCE(EMIT) and Emittance[] calculations. It is useful to give emittance determined externally, such as for proton machines.",
      "EMITXE EMITYE",
      {}},

     {"DP",
      "\
DP represents the relative momentum spread of the beam. It is automatically set by the keyword DP of the MARK element at the beginning of the beam line. The value of EMITY affects the default weight of variables in the matching. In the off-momentum matching, the range DP0 - DP < dp/p0 < DP0 + DP is used for the matching. The assumed momentum-distribution in the BEAMSIZE(BEAM), MEASURE(MEA), etc. commands, is Gaussian with the standard deviation DP and the mean DP0 if the flag GAUSS is on, otherwise uniform (square) in the range DP0 - DP < dp/p0 < DP0 + DP.",
      "DP0 off-momentum-matching GAUSS UNIFORM elements MARK",
      {}},

     {"DP0",
      "\
 DP0 represents the central value of the relative momentum offset in the optics calculation, or the center of the momentum distribution of the beam. The on-momentum optics has the relative momentum deviation dp/p0 == DP0, and the off-momentum calculation is done in the range DP0 - DP < dp/p0 < DP0 + DP.\n\
 DP0 sets the momentum deviation of the closed orbit at the entrance for EMIT with RADTAPER.",
      "DP off-momentum-matching matching-function-commands EMIT RADTAPER",
      {}},

     {"CONVERGENCE",
      "\
CONVERGENCE is the goal of the convergence(==MatchingResidual) in the matching. If MatchingResidual becomes smaller than CONVERGENCE times the effective number of the conditions, the matching by GO terminates. The flag CONV is set when MatchingResidual is smaller than CONVERGENCE after GO or CALCULATE(CAL). The default value is 10^-9.",
      "GO MatchingResidual CONV",
      {}},

     {"MatchingResidual",
      "\
MatchingResidual holds the convergence in the last GO or CALCULATE(CAL) commands. It is calculated by\n\n\
     sw*(Sum[(w_i*df_i)^ExponentOfResidual,{i}]/sw)^(2/ExponentOfResidual)\n\
     +penalty\n where w_i is the weight of the i-th condition, df_i is the difference of the i-th function from the goal, penalty is an additional big number  (typically 10), when the optics is unstable or closed orbit is not found in the case of CELL. The parameter sw is defined as\n\n\
     sw=Sum[(OffMomentumWeight/2/woff)^2,{i}]\n with\n\n\
     woff = 1                               for on-momentum optics\n\
          = Sqrt[number-of-momentum-points] for off-momentum optics.\n The weight of the function is lighter in the case of off-momentum-matching so that all off-momentum deviations functions weight equal to the on-momentum one. However, the relative weight for the off-momentum part can be changed by setting OffMomentumWeight. \n\
   The weight of each function at each point with each momentum can be specified by defining the FitWeight function.",
      "ExponentOfResidual CONVERGENCE OffMomentumWeight off-momentum-matching FitWeight",
      {}},

      {"ExponentOfResidual",
        "\
The exponent to calculate MatchinResidual. The default is 2.",
        "MatchingResidual GO",
        {}},

     {"NetResidual",
      "\
The net residual of convergence except the penalty for unstable optics.",
      "MatchingResidual StablilityLevel",
       {}},

     {"StabilityLevel",
      "\
Number of unstable planes in the optics calculations. Equal to zero if all x and y optics are stable for on/off-momentum and finite amplitude matching.",
       "NetResidual MatchingResidual",
       {}},

     {"OffMomentumWeight",
      "Relative weight of the off-momentum deviation for the off-momentum matching. The default is 1.",
      "ExponentOfResidual CONVERGENCE MatchingResidual off-momentum-matching FitWeight",
      {}},

     {"TITLE",
      "TITLE is a character-string to make the title of the plot in DRAW or GEO commands.",
      "CASE DRAW GEO",
      {}},

     {"FFS$NumericalDerivative",
      "If False (default), the calculation of response matrix for each matching variables uses analytical expressions as much as possible. If True, performs numerical differentiation during the matching by GO. It is useful for some variables and matching functions in some cases. It is slow, so should be avoided for off-momentum-matching for a large beam line.",
      "GO off-momentum-matching",
      {}},

     {"CASE",
      "CASE is a character-string to be attached with TITLE to issue the CASE command of TopDrawer in DRAW or GEO commands.",
      "TITLE DRAW GEO",
      {}},

     {"NP",
      "NP is the number of particles in the tracking. Accessible in MAIN.",
      "MEASURE(MEA)",
      {}},

     {"CHARGE",
      "\
CHARGE contains the charge of the particle. The default is +1.",
      "",
      {}},
 
     {"MASS",
      "\
MASS is the rest mass of the particle in eV. The default is the electron mass.",
      "",
      {}},
 
     {"MOMENTUM",
      "MOMENTUM is the nominal momentum of the beam line at the entrance in eV/c. Accessible in MAIN.",
      "",
      {}},

     {"NPARA",
      "NPARA specifies the maximum number of parallel processes for various calculations such as CALC, GO, TrackParticles, DynamicApertureSurve, etc.",
      "CAL GO TrackParticles DynamicApertureSurvey",
      {}},

     {"OMEGA0",
      "\
OMEGA0 is 2*Pi*SpeedOfLight/LINE[\"s\",\"$$$\"] . Accessible in MAIN.",
      "SpeedOfLight LINE",
      {}},

     {"EFFVCRATIO",
      "\
 Ratio of (effective voltage)/(Sum[VOLT_k,{k}]) (default: 1). Set by EMITTANCE(EMIT) or Emittance[]. Effective with RING only.",
      "PHICAV EFFVC",
       {}},

      {"EFFVC",
        "\
 Effective peak rf voltage EFFVC is given by\n\n\
  Abs[ weff Vcacc + I dVcacc/dt ] / weff ,\n\n\
where Vcacc, weff are total acceleration voltage at the equilibrium phase PHICAV and the effective RF angular frequency (=2 Pi EFFRFFREQ). DVcacc/dt is the time derivative of Vcacc. The quantity Vcacc and its derivatives are summed over all CAVIs and MULTs.\n\
 It is set by EMITTANCE(EMIT) or Emittance[]. The unit is Volt. Effective with RING only.",
        "EFFVCRATIO EFFRFFREQ PHICAV",
        {}},

      {"EFFRFFREQ",
        "\
 The effective angular frequency weff (= 2 Pi EFFRFFREQ) is obtained using the second derivative\n\n\
  d^2Vcacc/dt^2 == -weff^2 Vcacc ,\n\n\
ehere Vcacc is the total acceleration voltage at the equilibrium phase PHICAV. These quantities Vcacc and its derivatives are summed over all CAVIs and MULTs.\n\
 It is set by EMITTANCE(EMIT) or Emittance[]. Effective with RING only.",
        "EFFVC PHICAV",
        {}},

     {"PHICAV",
      "\
The equilibrium RF phase (in radian, = 2 Pi EFFRFFREQ DTSYNCH/c) where the synchrotron radiation loss and acceleration balances. If there are phase, voltage, frequency variations in RF cavities, it is calculated based on \"effective voltage\". Effective with RING only.",
      "EFFVC EFFRFFREQ DTSYNCH CAVI MULT",
      {}},
 
     {"SpeedOfLight",
      "SpeedOfLight is 299792458.",
      "",
      {}},

     {"PBUNCH",
      "\
PBUNCH is the number of particles/bunch for the calculation of the intra-beam and space charge effects in EMITTANCE(EMIT), and WakeFunction. Accessible in MAIN.",
      "EMITTANCE(EMIT) INTRA WSPAC WakeFunction equilibrium-beam-envelope",
      {}},

     {"NBUNCH",
      "\
NBUNCH is the number of bunches for the calculation of WakeFunction. Accessible in MAIN.",
      "PBUNCH",
      {}},

     {"MINCOUP",
      "\
MINCOUP is the minimum emittance ratio to be assumed in the calculation of intrabeam effects in EMITTANCE(EMIT) and Emittance[]. Emittances Max[emit_k, MINCOUP*(emit_x+emit_y)] (k=x,y) are assumed in the intrabeam calculation. Accessible in MAIN.",
      "EMITTANCE(EMIT) Emittance INTRA equilibrium-beam-envelope",
      {}},

     {"LOSSAMPL",
      "\
LOSSAMPL is the transverse amplitude beyond which a particle is judged to have been lost. The default is 1 m. Accessible in MAIN.",
      "LOSSDZ APERT",
      {}},

     {"LOSSDZ",
      "\
LOSSDZ is the longitudinal position z beyond which a particle is judged to have been lost. The default is 100 m. Accessible in MAIN. LOSSDZ is effective only when SPAC is ON.",
      "LOSSAMPL APERT SPAC",
      {}},

     {"FSHIFT",
      "FSHIFT is the relative shift df/f0 of the revolution (or rf) frequency in a ring. This is valid in EMITTANCE(EMIT), the particle-tracking, and CAL/GO with CALC6D. For CAL/GO with CALC4D, DP0 should be used instead.",
      "EMIT CAL GO CALC6D CALC4D DP0",
      {}},

     {"GCUT",
      "\
GCUT specifies the cut-off value of Gaussian distribution in unit of the standard deviation. Accessible in MAIN.",
      "SEED GAUSS GaussRandom",
      {}},

     {"DAPWIDTH",
      "\
DAPWIDTH is the successive width of the x-amplitudes to terminate the tracking assuming that the aperture is enough. The default is 7.",
      "DynamicApertureSurvey",
      {}},

     {"MatchingAmplitude",
      "\
MatchingAmplitude is a list of amplitudes for the finite-amplitude matching.\n\n\
Usage: MatchingAmplitude := { {dp1,x1,y1}, ..};\n\n\
where dp1 is the momentum deviation to be matched, x1 and y1 are the horizontal and vertical amplitudes at the beginning of the beam line, normalized by Sqrt of the sum of the emittance, i.e., Sqrt[(EMITX+EMITY)]. Three orbits are chosen in each dimension. The initial conditions of the orbit is chosen as\n\n\
   {X,Px,Y,Py} =\n\
   { {x1,0,0,0}, {-x1/2,Sqrt[3]/2 x1,0,0}, {-x1/2,-Sqrt[3]/2 x1,0,0},\n\
     {0,0,y1,0}, {0,0,-y1/2,Sqrt[3]/2 y1}, {0,0,-y1/2,Sqrt[3]/2 y1} },\n\n\
and when x1==0 or y1==0 corresponding orbits are excluded. The above are labeled {x1,x2,x3,y1,y2,y3} in the output of CALCULATE(CAL) or GO, and also labeled 1 to 6 in the second element of FFS[\"CALC\"] and FFS[\"GO\"].\n\n\
    This matching is done when dp1 is within the off-momentum range given by DP, i.e., Abs[dp1] < DP. If dp1 is in the range, the nearest zero- amplitude optics is chosen. The maching conditions for the finite- amplitude optics are same as those for the zero-amplitude one.\n\
   Th orbit with finte initial condition never close after one revolution, but FFS simply ignores it and obtain the periodic optics around the open\n\
orbit.",
      "DP EMITX EMITY off-momentum-matching CALCULATE(CAL) GO",
      {}},

     {"InitialOrbits",
      "\
Usage: InitialOrbits = { {x1, px1, y1, py1, z1, dp1}, ...};\n\n\
or     InitialOrbits = { {ax1, bx1, nx1, ay1, by1, ny1,\n\
          ex1, epx1, ey1, epy1, r11, r21, r31, r41,\n\
          x1, px1, y1, py1, z1, dp1, 0, 0, 0, 0, 0, 0, 0}, ...};\n\n\
specifies initial conditions of a number of orbits for the optics calculation by CALCULATE(CAL) and GO. Those coordinates are offset from the central orbit. If six numbers are given, only the offsets of the orbits are affected. If 27 numbers are given, all Twiss parameters are set (values for non-orbit params are used directly. Orbits are giving offsets.)\n\
  If InitialOrbits are given, the off-momentum matching and finite-amplitude matching is disabled.\n\
  InitialOrbits is also necessary to calculate optics with wake field.",
       "CALCULATE(CAL) GO off-momentum-matching MatchingAmplitude",
      {}},

     {"ElementValues",
      "\
ElementValues is a symbol to assign rules to determine values of keywords of elements or components. This is used to give a dependence between keywords of different elements or components, or determine then by a parametric expression.\n\n\
Useage:  ElementValues = { key[elem] :> expr, ...}\n\n\
where\t\n\n\
   key:      keyword to specify a value (string).\n\
   elem:     String to specify the elements or components, wildcards are allowed.\n\
   expr:     an expression which returs a real number to be set to the elements or components.\t\n\n\
Example:  ElementValues = \n\
            { \"DX\"[\"QF1\"] :> \"DX\"[\"QD1\"]-0.001,\n\
              \"DY\"[\"QF2.3\"] :> -\"DY\"[\"QD1.2\"],\n\
              \"ROTATE\"[\"QF*\"] :> f[x] }\n\n\
Remarks:\n\t\n\
1. Iff elem contains \".\", it is recognized as components, otherwise as elements.\n\
2. In the r.h.s. of the rule, an expression like key[elem] is evaluated as either LINE[key, elem] or Element[key, elem], depending on elem has \".\".\n\
3. The expression expr can be any expression returning a real number.\n\
4. Later rules overrides the former, if many rules apply on the same keyword of the same element.\n\
5. The rule given by ElementValues overrides the relation given by COUP_LE command.\n\
6. Use a[b] in stead of a@b.\n\
7. ElementValues is cleared by USE. It is hidden by VISIT and restored by BYE.",
      "COUPLE",
      {}},

     {"FitFunction",
      "\
FitFunction is a symbol to assign user-defined functions for matching with the GO command. \n\n\
Usage:   FitFunction := fun, \n\n\
where fun is a function that returns a real number or a list of real numbers, to be matched to zero by GO. The goal of GO is to make fun zero or a list of zeros, together with built-in matching conditions. Thus the sum of fun^2 is added to MatchingResidual. GO also evaluates FitFunction to obtain the derivatives numerically. The function fun can refer the value of variables by Element or LINE functions, and the optical functions at DP0 by Twiss. The algorithm of matching is same as that for built-in conditions, but it is slower because of the numerical differentiation, when the beam line is long and the number of variables large.\n\n\
Example:  FitFunction := {Twiss[\"BX\",\"$$$\"]-20, Twiss[\"BY\",\"$$$\"]-20};\n\n\
which puts the same goal as\n\n\
   FIT $$$ BX 20 BY 20 .\n\n\
   FitFunction is cleared by USE. It is also hidden by VISIT and restored by BYE.",
      "GO FREE MatchingResidual DP0 Element LINE Twiss",
      {}},

     {"OpticsProlog",
      "\
OpticsProlog is a variable to assign a user-defined function which is to be executed every time before an optics calculation is done in the CALCULATE(CAL) or GO commands. In GO, OpticsProlog is called at the beginning of each iteration. This function is useful, for instance, for setting parameters which depends on the result of optics calculation itself.",
      "OpticsEpilog",
      {}},

     {"OpticsEpilog",
      "\
OpticsEpilog is a variable to assign a user-defined function which is to be executed every time after an optics calculation is done in CALCULATE(CAL) or GO commands. In GO, OpticsEpilog is called at the end of each iteration. This function is useful, for instance, for setting parameters which depends on the result of optics calculation itself.",
      "OpticsProlog",
      {}},

(*
     {"STACKSIZ",
      "\
STACKSIZ has the size of the stack for SADScript interpreter. It can be set by user at the MAIN level, right before the first FFS session. The default value is 200000.",
      "",
      {}},
*)
      {"$Line",
        "\
 %Line counts the number of the results in FFS Shown with Out[]:= . Out remembers all outputs up to Out[$Line]. $Line = 0 resets the counter and forgets the outputs.",
        "",
        {}},

     {"PhotonList",
       "\
When PHOTONS is ON (default is OFF), with RAD and FLUC, TrackParticles generates a list of all photons radiated through the tracking. The list is assigned to a symbol PhotonList. PhotonList is a list of\n\n\
{en, gx, gy, gz, nx, ny, nz, xi1, xi2, xi3, np, nele}\n\n\
where\n\n\
en:    photon energy [eV]\n\
gx:    GX coordinate of the emission point [m]\n\
gy:    GY coordinate of the emission point [m]\n\
gz:    GZ coordinate of the emission point [m]\n\
nx:    GX component of the photon direction vector\n\
ny:    GY component of the photon direction vector\n\
nz:    GZ component of the photon direction vector (nx^2+ny^2+nz^2)=1.\n\
xi1:   Stokes' parameter for polarization 45 degree to the GZ=0 plane.\n\
xi2:   Stokes' parameter for right-handed polarization\n\
xi3:   Stokes' parameter for polarization in the GZ=0 plane.\n\
np:    particle number\n\
nele:  component number in the beam line\n\n\
The probability of each polarization is given by each Stokes' parameter as (1+xi)/2 . TrackParticles always updates PhotonList. The length of PhtonList is the number of emitted photons.\n\
   Remember that the {GX, GY, GZ} = {0, 0, 0} and their directions are {z, -x, -y} at the entrance of the beam line by default. It is changeable by the GEO command anyway.",
       "PHOTONS TrackParticles",
       {}}
  
    }]},

   {"set-value-of-element",
    "\
Usage: element-pattern [keyword] [{MIN | MAX | MINMAX | MAXMIN}] value\n\n\
sets value to the specified keyword of the elements which match element-pattern. If keyword is omitted, the default-keyword is assumed. keyword can be a wildcard to apply all matching keywords.\n\
   If MIN, MAX, MINMAX, MAXMIN are specified, it sets the limit of the default-keyword. Both MINMAX and MAXMIN means MIN=-Abs[value] and MAX=+Abs[value].\n\
   If the keyword is not the default-keyword, it affects both the current and the saved value.",
    "ATTRIBUTE(ATTR) SAVE elements default-keyword wildcards Element",
    {KeywordsMessage,

     DefaultKeywordMessage}},

    {"command-syntax",
     "The command syntax in FFS is\n\n\
     expression1 [param1..] [;] expression2..\t\n\n\
(1) The input is first evaluated as an expression. If the expression returns a Symbol with the same name as the expression itself, it is interpreted as an FFS command, otherwise the returned value is printed out unless it is Null.\n\
(2) Each command takes succeeding its parameters if necessary. A command with indefinite number of parameters can be terminated by semicolon. Most commands terminate itself at the end of line.\n\
(3) A line can be continued to the next line if a backslash is placed at the end of the line.\n\
(4) An expression continues to the next line if it is not closed in the line.\n\
(5) An exclamation mark comments out the rest of the line.\t\n\n\
Example: A command line\n\n\
          QF* .1\n\n\
means the set-value-of-element command as unless the symbol QF has been defined otherwise. If QF has been defines as a number, such as QF=2.5, the above command line is interpreted as Times[QF,.1] then returns .25 .",
     "expression functions",
     {}},

    {"components",
     "\
Components are the objects which consist the beam line. A component simulates an individual magnet, drift space, or rf-cavity. The parameters of a component is specified the values in the corresponding element with the same name as the component, which simulates a power supply. Many components can be attached to the same element. Parameters of each component may deviate from the corresponding element if machine errors are given.\n\
   A component is specified with the form name[.order][{+-}offset], where name is the name of the component. The number order means the order-th component which belongs to name element, counted from the beginning of the line starting from 1. Offset is a positive or negative number to specify the downstream or upstream components from the given component. If order is omitted, the first element is assumed, and if offset is omitted, zero is assumed. The order can be renumbererd by RENUMBER(RENUM).\n\
   The end of line is specified by $$$. The first component can be specified by ^^^.",
     "elements RENUMBER(RENUM)",
     {}},

    {"expression",
     "\
An expression in FFS consists of a symbol, constants, and operators.\n\n\
>>> A symbol is a characters of any length starting with an alphabet or $.\n\
>>> There are two kinds of constants, real number and character-string.\n\
    real number is a number in fortran-line format.\n\
    character-string is a set of characters surrounded by \"\" or ''.\n\
    special-characters can be specified with backslash.\n\
>>> Available operators are (in the order of the priority):\n\
    #,##,\n\
    ?,\n\
    ::,\n\
    @,\n\
    [],\n\
    ++, --,\n\
    /@, //@, @@,\n\
    .,\n\
    ^,\n\
    *, /,\n\
    +, -,\n\
    ==, <>, >, <, >=, =>, <=, =<, \n\
    ===, <=>, \n\
    ~, \n\
    &&,\n\
    ||,\n\
    .., ...,\n\
    |,\n\
    :,\n\
    ->, :>,\n\
    /., //.,\n\
    +=, -=, *=, /=,\n\
    &,\n\
    //,\n\
    /:,\n\
    =, :=, ^=, ^:=, =.\n\
    ;,\n\
    {}\n\
An operator with higher priority is operated first. An expression enclosed in () is evaluated first. Most mathematical operations are threaded into a list, i.e., {a,b} + {c,d} gives {a + b,c + d}, etc.\n\
   Each operators can be used as a function using its name. For example, Plus[x,y] gives the same result as x + y.",
     "constants functions command-syntax character-string",
     Sort[
     {{"Plus(+)",
       "a + b returns the sum of a and b.",
       "",
       {}},

      {"(-)",
       "operator for subtraction or unary minus.",
       "",
       {}},

      {"Times(*)",
       "a * b returns the product of a and b.",
       "",
       {}},

      {"(/)",
       "operator for division.",
       "",
       {}},

      {"Dot(.)",
       "a . b returns the inner product of a and b.",
       "",
       {}},

      {"Power(^)",
       "a ^ b returns the power of a to b.",
       "",
       {}},

      {"Equal(==)",
       "a == b returns True(==1) if a and b have the same type and the same value. It returns False(==0) if a and b have the same type but the different values. Otherwise returns the expression a == b.",
       "",
       {}},

      {"Unequal(<>)",
       "\
a <> b returns True(==1) if a and b have the same type but the different values. It returns False(==0) if a and b have the same type but the same value. Otherwise returns the expression a <> b.",
       "",
       {}},

      {"Greater(>)",
       "If both a and b are real, a > b returns True if a is greater than b, False otherwise. It causes an error when a or b is not real.",
       "",
       {}},

      {"Less(<)",
       "If both a and b are real, a < b returns True if a is less than b, False otherwise. It causes an error when a or b is not real.",
       "",
       {}},

      {"GreaterEqual(>= or =>)",
       "If both a and b are real, a => b returns True if a is greater than or equal to b, False otherwise. It causes an error when a or b is not real.",
       "",
       {}},

      {"LessEqual(<= or =<)",
       "If both a and b are real, a <= b returns True if a is less than or equal to b, False otherwise. It causes an error when a or b is not real.",
       "",
       {}},

      {"SameQ(===)",
       "a === b returns True(==1) if a and b have the same type and same value, False(==0) otherwise.",
       "",
       {}},

      {"UnsameQ(<=>)",
       "\
a <=> b returns True(==1) if a and b have the different types or different values. False(==0) otherwise.",
       "",
       {}},

      {"Not(~)",
       " ~a returns True(==1) when a is zero, False(==0) when a is a nonzero real.",
       "",
       {}},

      {"And(&&)",
       " a && b returns True(==1) when both a and b are nonzero real,  False(==0) otherwise. b is not evaluated when a is zero.",
       "",
       {}},

      {"Or(||)",
       "\
a || b returns True(==1) when a is nonzero real or b is nonzero real, False(==0) otherwise. b is not evaluated when a is nonzero.",
       "",
       {}},

      {"StringJoin (//)",
       "a // b converts a and b to character-strings, then join them.",
       "StringJoin",
       {}},

      {"Alternatives(|)",
       "\
a | b | ... represents a pattern which matches one of patterns a, b, ...",
       "",
       {}},

      {"Sequence([])",
       "a[b,c,..] means a list of b, c,.. with the head a. It is evaluated as a function-reference when a is a function or a defined-function. When a is a list with head List, it is interpreted as a part specification of a list. When a is a character-string, it is interpreted as a substring specification. When a is an operator, it is an expression b (a) c (a) .. . When a is Null, it means a sequence.",
       "",
       {}},

      {"List({})",
       "{a,b,c...} is a list structure.",
       "",
       {}},

      {"Set(=)",
       "\
a = value sets the value b to the symbol a. {a,b,..}={v1,v2,..} sets a,b,c simultaneously. a[b,c,..]=v1 sets the part of a[b,c,..] if a is a list. a[b,c,..] = expression defines the value a[b,c,..] if a is not a list.",
       "",
       {}},

      {"SetDelayed(:=)",
       "same as Set but the right hand side is not evaluated when it is set.",
       "Set",
       {}},

      {"Unset(=.)",
       "a=. clears the definition assigned to a.",
       "Clear",
       {}},

      {"CompoundExpression(;)",
       "a ; b evaluates a, then evaluates b and returns its result.",
       "",
       {}},

      {"Function(&)",
       " a & is a pure-function whose argument is specified #, #n, ##, ##n.",
       "Slot(#) SlotSequence(##) functions Function",
       {}},

      {"PatternTest(?)",
       "\
pattern?test matches to an object which matches pattern then test[object] gives True.",
       "",
       {}},

      {"Rule(->)",
       "\
pattern->expr represents a rule for ReplaceAll.",
       "",
       {}},

      {"RuleDelayed(:>)",
       "\
pattern:>expr represents a rule for ReplaceAll, where expr is kept unevaluated until the replacement.",
       "Literal",
       {}},

      {"ReplaceAll(/.)",
       "\
expr/.rule replaces all subexpressions of expr using rule.",
       "",
       {}},

      {"ReplaceRepeated(//.)",
       "\
expr//.rule replaces all subexpressionso of expr using rule, while a replacement is performed.",
       "",
       {}},

      {"Repeated(..)",
       "\
p.. matches sequence of one ore more expressions, each matching p.",
       "",
       {}},

      {"RepeatedNull(...)",
       "\
p... matches sequence of zero ore more expressions, each matching p.",
       "",
       {}},

      {"Map (/@)",
       "\
f/@a maps function f to subexpressions of a. f/@[a,level] specifies a levelspec of map by level.",
       "Map",
       {}},

      {"MapAll(//@)",
       "\
f//@a maps function f to all subexpressions of a. f//@[a,Heads->True] maps including the heads of a and its subexpressions.",
       "",
       {}},

      {"Apply (@@)",
       "\
f@@a applies function f to subexpressions of a. f@@[a,level] specifies a levelspec to apply by level.",
       "Apply",
       {}},

      {"Member(@)",
       "\
f@a refers the member a of an instance or a class f. Otherwise it is same as f[a]. f@g@h means (f@g)@h, and f@g[h] (f@g)[h].",
       "",
       {}},

      {"Increment(++)",
       "\
a++ increments a by 1, returning the old value of a. ++a increments a by 1, returning the new value of a.",
       "",
       {}},

      {"Decrement(--)",
       "\
a-- decrements a by 1, returning the old value of a. --a decrements a by 1, returning the new value of a.",
       "",
       {}},

      {"AddTo(+=)",
       "a+=b is equivalent to a=a+b .",
       "",
       {}},

      {"SubtractFrom(-=)",
       "a-=b is equivalent to a=a-b .",
       "",
       {}},

      {"TimesBy(*=)",
       "a*=b is equivalent to a=a*b .",
       "",
       {}},

      {"DivideBy(/=)",
       "a/=b is equivalent to a=a/b.",
       "",
       {}},

      {"Part([[]])",
       "\
a[[b,..]] is a subexpression of an expression a.\n If an index is omitted or Null like as a[[,b]], Part returns a list of elements whose corresponding index takes the entire range. For instance,\n {{1, 2}, {3, 4}, {5, 6}}[[,2]] gives {2, 4, 6}.",
       "Part",
       {}},

      {"MessageName(::)",
       "\
symbol::tag returns a message associated with symbol and tag\n symbol::tag = message sets a message identified by symbol",
       "",
       {}},

      {"TagSet(/:)",
       "\
symb/:lhs = rhs sets rhs to lhs, associated with symbol symb. symb/:lhs := rhs sets rhs to lhs unevaluated, associated with symbol symb. symb/:lhs =. unsets lhs, associated with symbol symb.",
       "",
       {}}
    }]},

   {"pattern",
     "\
 Pattern is a special expression for mathing arguments in function definitions and rules with several forms:\n\n\
_           matches any single argument.\n\
__          matches a sequence of 1 or more arguments.\n\
___         matches a sequence of 0 or more arguments.\n\
x_          matches any single argument, which is names x.\n\
x__         matches a sequence of 1 or more arguments, which is named x.\n\
x___        matches a sequence of 0 or more arguments, which is named x.\n\
x:pattern   a pattern which is named x.\n\
pattern:v   a pattern which has a default value v when matching is failed.\n\
pattern..   a non-null sequence of arguments each of which matches pattern.\n\
pattern...  a sequence, which can be null, of arguments each of which matches pattern.\n\
expression  matches expression.",
     "MatchQ defining-functions rules",

     Sort[{
       {"MatchQ",
         "\
 MatchQ[x, pat] returns True if x matches pat",
         "",
         {}}
       }]},

  {"defining-functions",
    "\
 A function is defined by one of the following forms:\n\n\
f[pat1 [,pat2...]] (:)= body;\n\
f[pat1 [,pat2...]] ^(:)= body;\n\
g/:f[pat1 [,pat2...]] (:)= body;\n\n\
where pat1 [,pat2...] are patterns (including expressions).\n\
 If UpSet(^=) or UpSetDelayed (^:=) is used, the definition is associated with the symbol in the first level of l.h.s.\n\
 If TagSet(/:) is used, the definition is associated with the symbol on the left of /: .\n\n\
 The patters can be an expression including constants. The definition with constant arguments can be accessed faster than searching a list, in general, so they are suitable for a data base. Definitions with constant arguments have higher priorities than with patterns.",
    "UpSet UpSetDelayed TagSet pattern",
    {}},

   {"character-string",
     "\
 A character-string is expressed by enclosing in \"\". Special characters are expressed using \\:\n\n\
\\n     new line\n\
\\r     carriage return\n\
\\t     tab\n\
\\\"     double quote\n\
\\\\     backslash\n\
\\nnn   a character whose octal code is nnn.\n\n\
 If a character-string is written over multiple lines, \\ must be placed at the end of each line.\n\
 The length of a character-string is limited to 2^31-1.",
     "",
     Sort[{
       {"ToCharacterCode",
         "\
 ToCharacterCode[s] returns the list of character codes of character-string s.",
         "FromCharacterCode",
         {}},

       {"FromCharacterCode",
         "\
 FromCharacterCode[r_Real] returns a character whose character code is r.\n\
 FromCharacterCode[l_List] returns a character-string whose character codes are l.",
         "ToCharacterCode",
         {}},

       {"StringLength",
         "\
 StringLength[s] returns the length of string s.",
         "",
         {}},

       {"StringPosition",
         "\
 StringPosition[s, subs] returns a list of positions of subs in string s.\n\
 StringPosition[s, subs, n] returns a list of first n positions of subs in string s.\n\n\
Example: StringPosition[\"abcbcbcbcb\",\"bcb\"] returns {{2,4},{4,6},{6,8},{8,10}}.",
         "",
         {}},

       {"StringFill",
         "\
 StringFill[s, sf, n]  with strings s and sf, n > 0, returns (s//sf//sf...)[1,n] .\n\
 StringFill[s, sf, -n] with strings s and sf, n > 0, returns (...sf//sf//s)[-n,-1] .",
         "StringJoin // StringPart",
         {}},

       {"StringJoin",
         "\
 StringJoin[s1, s2, [,s3...]] ===> s1 // s2 [//s3...] concatenates strings s1, s2 [,s3...].",
         "//",
         {}},

       {"StringPart",
         "\
 s_String[n]      returns the n-th character in s.\n\
 s_String[n1, n2] returns the substring from n1-th through n2-th characters of s.\n\n\
 If n1, n2 are negative, they count from the end of the string.",
         "",
         {}},

       {"StringTrim",
         "\
 StringTrim[s] removes the leading and trailing spaces and tabs from s.",
         "",
         {}},

       {"StringMatchQ",
         "\
 StringMatchQ[s, spat] returns True/False whether string s matches string-patten spat.",
         "wildcards",
         {}},

       {"StringReplace",
         "\
 StringReplace[s, rules] replaces the parts of string s accoding to rules, which is a Rule or a list of Rules:\n\n\
   StringReplace[\"abcbcbcbc\",\"bcb\"->\"xyx\"] ===> \"axyxcxyxc\"\n\
   StringReplace[\"abcbcbcbc\",{\"bcb\"->\"xy\",\"cbc\"->\"pqrs\"}] ===> \"axypqrsbc\" .",
         "",
         {}},

       {"ToString",
         "\
 ToString[expr] evaluates an expression expr, then converts to a character-string.\n\
 ToString[expr, [FormatType ->] form [, form1...]] converts expr using one or more formats form [,form1...]. Available formats are:\t\n\n\
 InputForm special characters are quoted with \\.\n\
 HoldForm converts expr without evaluation.\n\
 StandardForm converts with the standard number format and PageWidth.\n\
 GenelicSymbolForm do not display the generation ($nnn) of local symbols for Module.\t",
         "$FORM PageWidth StandardForm Module ToExpression",
         {}},

       {"ToExpression",
         "\
 ToExpression[s] converts a character-string s to an expression and evaluate it.",
         "ToString",
         {}},

       {"Symbol",
         "\
 Symbol[s] returns a Symbol whose name is character-string s.",
         "",
         {}}

       }]},

   {"constants",
    "There are pre-defined special symbols for constants in FFS:\n\n\
symbol         value\n\
True           1\n\
False          0\n\
Infinity       INF\n\
INF            INF\n\
NaN            NaN\n\
Pi             ArcSin[1]*2\n\
E              Exp[1]\n\
I              Complex[0,1]\n\
Degree         Pi/180\n\
GoldenRatio    (1+Sqrt[5])/2\n\
EulerGamma     0.57721566490153286061",
    "special-variables physical-constants flags expression",
    {}},

   {"physical-constants",
     EquAlign["Text[\
Physical constants available in FFS are:\n\
\\begin{align*}\n\
{\\tt SpeedOfLight} &\\qquad c\\equiv 299792458 {\\rm\\ m/s}\\\\\n\
{\\tt PlanckConstant} &\\qquad h \\equiv 6.62607015\\times 10^{-34} {\\rm\\ Js}\\\\\n\
{\\tt PlanckHbar} &\\qquad \\hbar\\equiv h/(2\\pi)\\\\\n\
{\\tt ElectronCharge} &\\qquad  e_e \\equiv 1.602176634\\times 10^{-19} {\\rm\\ C}\\\\\n\
{\\tt FineStructureConstant}&\\qquad  \\alpha = 1/137.035999084 \\\\\n\
{\\tt ElectronMass}&\\qquad  m_e = 0.51099895000\\times 10^6 {\\rm\\ eV}\\\\\n\
{\\tt ElectronRadius}&\\qquad  {\\rm classical\\ radius\\ of\\ electron\\ in\\ m,} r_e \\equiv \\alpha \\hbar c / (e_e m_e)\\\\\n\
{\\tt ProtonMass}&\\qquad  m_p  = 938.27208816\\times 10^6 {\\rm\\ eV}\\\\\n\
{\\tt ProtonRadius}&\\qquad  {\\rm classical\\ radius\\ of\\ proton\\ in\\ m}\\\\\n\
{\\tt SIMu0}&\\qquad \\mu_0\\equiv 2\\alpha h/(c e_e^2)\\\\\n\
{\\tt SIEpsilon0}&\\qquad    \\varepsilon_0\\equiv 1/(\\mu_0 c^2)\\\\\n\
{\\tt ElectronGminus2over2}&\\qquad   (g-2)/2 {\\rm\\ of\\ electron} = 0.001159652181280002\\\\\n\
{\\tt BoltzmannConstant}&\\qquad   1.380649\\times 10^{-23} {\\rm\\ J/K .}\n\
\\end{align*}\
;;;0]","\
Physical constants available in FFS are:\n\n\
SpeedOfLight           c = 299792458 m/s\n\
PlanckConstant         h = 6.62607015d-34 Js\n\
PlanckHbar             hbar = h/2/Pi\n\
ElectronCharge         e_e = 1.602176634d-19 C\n\
FineStructureConstant  alpha = 1.d0 / 137.035999084d0\n\
ElectronMass           m_e in eV = 0.51099895000d6\n\
ElectronRadius         classical radius of electron = alpha hbar c / (e_e m_e), in m\n\
ProtonMass             m_p in eV = 938.27208816d6\n\
ProtonRadius           classical radius of Proton, in m\n\
SIMu0                  2 alpha h / e_e^2 / c\n\
SIEpsilon0             1/SIMu0/c^2\n\
ElectronGminus2over2   (g-2)/2 of electrons = 0.001159652181280002\n\
BoltzmannConstant      1.380649d-23 J/K"],
     "constants expression special-variables",
     {}},

   {"functions",
    "FFS functions:\n\n\
Constants:\n\
   Degree GoldenRatio I INF* Infinity NaN* Pi SpeedOfLight\n\
Elementary-functions:\n\
   ArcCos ArcCosh ArcSin ArcSinh ArcTan ArcTanh Cos Cosh Exp Log Sin Sinh\n\
   Sqrt Tan Tanh\n\
Special-functions:\n\
   BesselI BesselJ BesselK BesselY BesselJZero Erf Erfc Factorial \n\
   Gamma LogGamma LogGamma1 GammaRegularized GammaRegularizedQ*\n\
   GammaRegularizedP* GaussianCoulomb* GaussianCoulombU*\n\
   GaussianCoulombFitted* LegendreP*\n\
Numerical-functions:\n\
   Abs Ceiling Floor Max Min MinMax* Mod Negative NonNegative Positive\n\
   Round Sign FractionalPart\n\
Matrix-operations:\n\
   Det Eigensystem IdentityMatrix Inner LinearSolve Outer SingularValues*\n\
   Transpose\n\
Random-number:\n\
   GaussRandom* Random* SeedRandom\n\
Complex:\n\
   Arg Complex ComplexQ Conjugate Im Re\n\
Rational:\n\
   Rational FromRational ContinuedFraction FromContinuedFraction SmallPrime\n\
   Numerator Denominator\n\
Fourier-Transformation:\n\
   Fourier InverseFourier\n\
Data-Manipulation:\n\
   FindRoot Fit* NIntegrate* PolynomialFit* Spline*\n\
Calculus:\n\
   D NIntegrate\n\
Minimization:\n\
   DownhillSimplex*\n\
List-manipulations:\n\
   Append Complement Delete Depth Difference* Dimensions Drop Extract Flatten\n\
   FlattenAt HeldPart Insert Intersection Join Length Part Partition Prepend\n\
   Product Range ReplacePart Rest Reverse RotateLeft RotateRight Select \n\
   Sort Sum Take Table Union\n\
Character-strings:\n\
   FromCharacterCode CharacterPosition Characters DigitQ LetterQ StringDrop\n\
   StringFill* StringInsert StringLength StringPosition StringTrim*\n\
   Symbol SymbolName ToCharacterCode ToLowerCase ToUpperCase ToExpression\n\
Functional-Operations:\n\
   Apply Cases Count DeleteCases Identity FixedPoint* FixedPointList*\n\
   Fold Function Level Map MapAll MapAt MapIndexed MapThread Nest Position\n\
   Replace Scan ScanThread* SelectCases* SwitchCases* Thread\n\
Object-oriented programing and context:\n\
   Begin BeginPackage Class* End EndPackage\n\
Flow-Control:\n\
   Break Catch Check Continue Do For Goto If Label Return Switch Throw Which\n\
   While\n\
Tests:\n\
   AtomQ ComplexQ DirectoryQ* EvenQ FileQ* MatchQ MatrixQ MemberQ NearlySameQ* \n\
   Negative NonNegative NumberQ OddQ Order Positive RealQ StringQ* VectorQ\n\
   BoundQ* FBoundQ*\n\
Input/Output:\n\
   Close Flush* Get OpenRead OpenWrite OpenAppend Print Put Read ReadString SeekFile*\n\
   Short* StringToStream Write WriteString\n\
File System:\n\
   CopyDirectory CopyFile CreateDirectory DeleteDirectory DeleteFile\n\
   DirectoryName FileByteCount FileDate FileNames FileType\n\
   RenameDirectory RenameFile SetFileDate ToFileName\n\
Scoping:\n\
   Block Module With*\n\
Attributes:\n\
   Attributes* Clear Evaluate Head Hold Literal Protect ReleaseHold\n\
   SetAttributes* Unevaluated Unprotect\n\
GUI Widget:\n\
   Window* PanedWindow* Frame* LabelFrame* Canvas* TextLabel* TextMessage*\n\
   Button* CheckButton* RadioButton* Menu* OptionMenu* MenuButton*\n\
   Entry* SpinBox* ListBox* ScrollBar* Scale* TextEditor*\n\
Graphics:\n\
   BeamPlot* ColumnPlot* HistoPlot* ListContourPlot ListDensityPlot \n\
   ListPlot Plot Show FitPlot* GeometryPlot* OpticsPlot* TkPhotoPutBlock*\n\
System Interface:\n\
   Directory Environment GetEnv* GetGID* GetPID* GetUID* ProcessStatus* \n\
   SetDirectory SetEnv* System* TemporaryName* MkSecureTemp* RealPath*\n\
Multiprocessing:\n\
   BiPipe* Fork* OpenShared* Shared* Wait*\n\
Utilities:\n\
   Date DateString* Definition* FromDate* ToDate ToDateString* Pause\n\
   MemoryCheck* Message Off On Sleep TimeUsed Timing TracePrint\n\n\
Functions listed above work basically in the same way as Mathematica's \n\
except those marked by *.\n\n\
FFS-dedicated-functions:\n\
   BeamMatrix CalculateOptics DynamicApertureSurvey Element Emittance FFS\n\
   FitValue FitWeight GeoBase LINE OptimizeOptics OrbitGeo RadiationField\n\
   RadiationSpectrum SymplecticJ SetElement TrackParticles Twiss VariableRange\n\
   SynchroBetaEmittance TouschekLifetime WakeFunction\n\
Beam-line-functions:\n\
   BeamLine BeamLineName ExtractBeamLine PrintBeamLine WriteBeamLine",
    "expression constants physical-constants beam-line-functions",
    Sort[{
      {"Object-oriented-programing",
      "\
Environment for an object-oriented-programming is supplied by:\n\n\
Class:          The function to define a class.\n\
context:        A class defines a context to define its all symbols for\n\
                the variables and methods within the context.\n\
                This automatically avoids conflicts of symbols between \n\
                classes, Global, and System. When c = Class[ ... ] is\n\
                done, a context c` is defined.\n\n\
members:        The set of Members of a class is a union of class variables,\n\
                instance variables, and class methods of the class.\n\n\
operator @:     A special operator to access class member. In a notation \n\
                f@g, g's context defaults the class of the class of f. \n\
                f@g@h[x] is recognized as ((f@g)@h)[x] , thus the context of\n\
                h defaults the class of f.\n\n\
superclasses:   A class inherits all class variables, instance variables,\n\
                class methods from its superclasses which are give by the\n\
                first argument of Class. If a null list is given, Object` \n\
                is set as the default superclass. Multiple inheritance is\n\
                allowed.\n\n\
class variable: Class variables are given by the second argument of Class\n\
                as a list of symbols. They are unique in the class.\n\
                They can be initialized by declaring in a way such as \n\
                {a=1, {b, c} = {2, 3}} like Module. A form like\n\
                {a = b = c =1} is allowed.\n\n\
instance variable: \n\
                Instance variables are given by the third argument of Class\n\
                as a list of symbols. An instance has those symbols\n\
                separately. They can be initialized by declaring in a way\n\
                such as {a=1, {b, c} = {2, 3}} like as Module. A form like as\n\
                {a = b = c =1} is allowed. Also they\n\
                are initialized at the creation of instance by rules as\n\
                x = c[ a->1, b:>Print[d]], etc.\n\n\
class methods:  Class methods are given by the fourth(last) argument of\n\
                Class. They must be in the form of either one of\n\n\
                f_[arg___] := g_;\n\
                With[_, f_[arg___] := g_];\n\
                With[_, f_[arg___] := g_; .. ];\n\
                If[_,\n\
                  ft_[argt___] := gt_; ..,\n\
                  ft_[argf___] := gf_; ..,];\n\
                h_[f_[arg___], b___] ^:= g_; .\n\n\
                where f is the symbol for the method to be defined.\n\
                Set may be used instead of SetDelayed if necessary.\n\n\
This:           A symbol This in the definition of the method, it is \n\
                translated to the object (the instance or the class) which \n\
                refers the member.\n\n\
default reference:\n\
                In the definition of the class methods, whenever a member of\n\
                the class is appeared, it is recognized as This@member.\n\
                When a symbol of the member conflicts the symbol in System`,\n\
                the system symbol should be wrapped by Literal.\n\n\
reference of member of superclasses:\n\
                Members of the superclasses (denote cc) are referred by \n\
                cc`member in the definition of the method.\n\n\
copying an instance:\n\
                An instance c of a class can be copied to another symbol\n\
                by c1 = c. After the copying, c1 and c refer the identical\n\
                instance. Destructing one of them by such as c1=. clears\n\
                the instance and also all the assigned symbols.\n\n\
Constructor:    When an instance is defined, by x = c[arg], a method\n\
                x@Constructor[arg] is always invoked.\n\
                In evaluation of instance definition under class scope,\n\
                class member symbol appeared 1st slot of Rule or RuleDelayed\n\
                argument is sent to Constructor of new class instance\n\
                without evaluation. (In other term, class member symbol on\n\
                1st slot of Rule or RuleDelayed argument behaves like\n\
                evaluating with implicit Literal[]) One can configure\n\
                Constructor[] in the definition of the class.\n\
                x = c[arg] returns the returned value of Constructor[arg].\n\
                The rules in the argument work in two ways: (1) A rule for an\n\
                instance variable or a class variable sets the initial value\n\
                of the variable, (2) Other rules are stored in an instance\n\
                variable Options as a list.\n\n\
Destructor:     An instance x is cleared by (x=.), which invokes \n\
                x@Destructor[]. The default Destructor is Object`Destructor,\n\
                but one can reconfigure it in the definition of the class.\n\n\
Short:          When an instance x is returned as the result of expression\n\
                for Out[], x@Short[] is invoked to show the result. The \n\
                default Short is Object`Short, but one can reconfigure it\n\
                in the definition of the class.\n\n\
other methods:  Class[] gives the class of the instance.\n\
                Parents[] gives the immediate superclasses.\n\
                AllParents[] gives the all superclasses.\n\
                Members[] gives a list of class variables, class methods,\n\
                and instance variables of the class.\n\
                AllMembers[] gives a list of class variables, class methods,\n\
                and instance variables of the class and its all parents.",
      "Member",
      {{"Class",
        "\
Class sets up a class of objects.\n\n\
Usage:   a = Class[\n\
               list of superclasses,\n\
               list of class-variables,\n\
               list of instance-variables,\n\
               class-methods];\n\n\
Example: a = Class[\n\
               {aa, bb},      (* aa and bb are superclasses *)\n\
               {a1, a2},      (* class-variables *)\n\
               {v1, v2},      (* instance-variables *)\n\
               Constructor[arg__] := (Print[{arg}]; v1 = Plus[arg]);\n\
               sum[] := v1 + v2 (* defining Constructor and method \"sum\"*)\n\
             ];\n\n\
         a1 = a[1, 2]          (* creating an instance of a *)\n\
         a1@v1                 (* accessing an instance variable *)\n\
         a1@v2 = 3             (* setting an instance variable *)\n\
         a1@sum[]              (* calling a method \"sum\" *)\n\
         a1=.                  (* delete an instance *)",
        "",
        {}}}},

      {"functional-operations",
      "",
      "",
      Sort[{{"SwitchCases",
        "\
Usage: SwitchCases[list, {case1,..}]\n\n\
returns a list {list1, .. }, where list1 is a list of subexpressions which match case1, etc. SwitchCases does what are done by Cases and DeleteCases simultaneously. If the second argument is like {c1, .. , _}, the last of the returned list contains subexpressions which match none of c1, ...",
        "SelectCases",
        {}},

       {"SelectCases",
        "\
Usage: SelectCases[list, {test1,..}]\n\n\
returns a list {list1, .. }, where list1 is a list of subexpressions which makes test1 True, etc. If the second argument is like {c1, .. , True&},  the last of the returned list contains subexpressions which make none of c1, ... True.",
        "SwitchCases",
        {}},

       {"Map",
         "\
   Map[f, x [, level]] or f/@x [f/@[x, level]] \n\n\
operates f over each element of a list x and returns the result as a list:\n\n\
f/@{a, b, c} ===> {f[a], f[b], f[c]}\n\n\
An optional argument specifies the level-spec.",
         "@/ Scan Apply MapThread level-spec",
         {}},

       {"Scan",
         "\
   Scan[f, x [, level]]\n\n\
operates f over each element of a list without returning the result:\n\n\
Scan[f, {a, b, c}] ===> {f[a], f[b], f[c]};Null \n\n\
An optional argument specifies the level-spec.",
         "Map Apply MapThread level-spec",
         {}},

       {"Apply",
         "\
   Apply[f, x [, level]] or f@@x [f@@[x, level]] \n\n\
takes the bod of a list x as the argument sequence of f, and returns the result:\n\n\
f@@{a, b, c} ===> f[a, b, c]\n\n\
An optional argument specifies the level-spec.",
         "@@ Map Scan MapThread level-spec",
         {}},

        {"Position",
          "\
   Position[l, pat [, level [,n]]]\n\n\
returns a list of indices of parts of l, which match a pattern pat. Optional level-spec l and the maximum number of results n can be specified.",
          "level-spec pattern Cases DeleteCases",
          {}},

        {"Cases",
          "\
   Cases[l, pat [, level [,n]]]\n\n\
returns a list of parts of l, which match a pattern pat. Optional level-spec l and the maximum number of results n can be specified.",
          "level-spec pattern Position Deletecases",
          {}},

        {"DeleteCases",
          "\
   DeleteCases[l, pat [, level [,n]]]\n\n\
returns a list of parts of l, which do not match a pattern pat. Optional level-spec l and the maximum number of results n can be specified.",
          "level-spec pattern Cases Position",
          {}},

       {"Difference",
        "\
Difference[list] returns Rest[list] - Drop[list, -1] .",
        "",
        {}},

       {"FixedPoint",
         "\
FixedPoint[f, e] starts from f[e] then applies f repeatedly until the result no longer changes. FixedPoint[f, e, n] specifies the maximum number of iterations by n. An option SameTest->s specifies the test function. Threshold->re, and AbsoluteThreshold->ae set the relative and absolute accuracy, respectively, when SameTest->NearlySameQ (default).",
         "FixedPointList",
         {}},

       {"FixedPointList",
         "\
FixedPointList[f, e] returns the intermediate values of FixedPoint[f, e] as a list. FixedPointList[f, e, n] and options for FixedPoint are valid.",
         "FixedPoint",
         {}},

        {"level-spec",
          "\
Functions Map, Apply, Scan, Cases, Position, Count, Level, DeleteCases takes an optional argument level to specify which level to operate:\n\n\
value               operates\n\
n_Real              from level 1 through level n\n\
{n_Real}            only on level n\n\
{n1_Real, n2_Real}  from leveln1 through level n2\n\n\
If n is negative, it counts from the deepest level of each element.\n\n\
Examples: f@@[{{a, b}, {c, d}}, {1}] ===> {f[a, b], f[c, d]}",
          "Map Apply Scan Cases Position Count Level DeleteCases",
          {}},

        {"MapThread",
          "\
   MapThread[f, l] ===> f@@[Thread[l], {1}]\n\n\
Example: MapThread[f, {{1, 2}, {3, 4}}] ===> {f[1, 3], f[1, 4]}",
          "ScanThread Thread Map Apply",
          {}},

        {"ScanThread",
          "\
   ScanThread[f, l] ===> (f@@[Thread[l], {1}];Null) ,\n\n\
which is equivalent to MapThread without returning the results.",
          "MapThread Thread Map Apply",
          {}},

        {"Thread",
          "\
 Thread[l] returns a threaded list of l:\n\n\
   Thread[{{1, 2}, {3, 4}}] ===> {{1, 3}, {2, 4}}\n\
   Thread[{{1, 2}, {3, 4}, 5}] ===> {{1, 3, 5}, {2, 4, 5}}\n\n\
 If an optional second argument h is given, Thread operates only over on a structure whose head is h:\n\n\
   Thread[{{1, 2}, {3, 4}} , f] ===> {{1, 2}, {3, 4}}\n\
   Thread[{f[1, 2], f[3, 4]} , f] ===> f[{1, 3}, {2, 4}]\n\
   Thread[f[f[1, 2], f[3, 4]] , f] ===> f[f[1, 3], f[2, 4]]\n\n\
 Thread is equivalent to Transpose if l is a matrix.",
          "MapThread Transpose",
          {}}

        }]},

     {"Input/Output",
       "",
       "",
       Sort[{{"OpenRead",
         "\
f = OpenRead[file]\n\n\
opens file (_String) for read and returns the file number (_Real)",
         "Close OpenWrite OpenAppend",
         {}},

         {"OpenWrite",
           "\
f = OpenWrite[file]\n\n\
opens file (_String) for write and returns the file number (_Real)",
           "Close OpenRead OpenAppend",
           {}},

         {"OpenAppend",
         "\
f = OpenAppend[file]\n\n\
opens file (_String) for write and returns the file number (_Real)",
         "Close OpenRead OpenWrite",
           {}},

         {"StringToStream",
           "\
f = StringToStream[string]\n\n\
opens a character string for read and returns the file number (_Real)",
           "Close",
           {}},

         {"Close",
           "\
 Close[f] closes file number [f]. It is necessary to complete the output to an external file.\n\
 Close[f1, ...] and Close[{f1, ...}] close all files f1, ...",
           "OpenRead OpenWrite OpenAppend OpenShared StringToStream",
           {}},

         {"Read",
           "\
Read[f, item [, item1...] [, opts..]]\n\n\
reads item from file number f. If f is $Input, it reads from the current input stream. item can be one of or a list of:\n\
Word        a word, delimited by WordSeparators\n\
Real        a real expression\n\
Expression  an expression\n\
Character   a single character\n\n\
 A format n*item is possible with a positive integer n.\n\
 A list {item1,.., itemn} is possible. The result is also a list.\n\n\
 opts are options given by a Rule:\n\
Option         Value       Default    Effect\n\
WordSeparator  _String     \" ,\\t\"     the delimiters for Word\n\
ReadNewRecord  True/False  True       If true, read the next record of the file beyond the end of line\n\
NullWords      True/False  False      If True, \"\" is returned when the input contains adjavent word separators",
           "OpenRead Close",
           {}},

         {"ReadString",
"ReadString[f]\n\n\
reads the next record from file number f, and returns it as a _String.",
           "Read OpenRead Close",
          {}},

         {"Write",
           "\
   Write[f, expr1 [,expr2 ...]]\n\n\
converts expr1... to _String then write them to file number f. A newline character is appended at the end.",
           "WriteString Print OpenWrite OpenAppend Close $FORM PageWidth StandardForm",
           {}},

         {"WriteString",
           "\
WriteString[f, expr1 [,expr2 ...]]\n\n\
converts expr1... to _String then write them to file number f. No newline character is appended.",
           "Write OpenWrite OpenAppend Close $FORM PageWidth StandardForm",
           {}},

         {"Print",
           "\
   Print[expr1 [,expr2 ...]]\n\n\
converts expr1... to _String then write them to $Output. A newline character is appended at the end.",
           "Write WriteString",
           {}},

         {"$Output",
           "\
$Output holds the file number for console output. The default is -1.",
           "$Input",
           {}},
   
         {"$Input",
           "\
$Input holds the file number for console input stream. The default is -1.",
           "$Output",
           {}},

         {"$FORM",
           "\
$FORM is a character-string to specify the format of the output of a real number.\n\n\
Usage: $FORM=\"w.f\"\n\
       $FORM=\"Sw.f\"\n\
       $FORM=\"Fw.f\"\n\
       $FORM=\"Mw.f\"\n\n\
where w is the width of the output, and f is the length of the fractions. If S is attached, trailing zeroes are omitted. If F is attached, it becomes same as FORTRAN's F-format. If M is attached, the exponent is expressed as 10^n. If w and f are omitted, 17.15 is assumed.\n\
   The default is S17.15 .",
           "",
           {}},

         {"PageWidth",
           "\
PageWidth is the number of columns of the output. The default is set from GetEnv[\"WIDTH\"].",
           "",
           {}},

         {"StandardForm",
           "\
StandardForm[expr]\n\n\
resets $FORM and PageWidth to their defaults, then evaluate expr, returns the result, and resets $FORM and PageWidth to those at the beginning of StandardForm.",
           "$FORM PageWidth",
           {}}

         }]},

     {"Utilities",
       "",
       "",
       Sort[{
         {"DateString",
        "\
 DateString[] returns the current date and time as string  \"mm/dd/CCYY HH:MM:SS\".\n\
 DateString[date] converts date to string as above. The date can be either a real number (in second, date=0 is 1/1/1900 0:0:0) or a list of 6 reals {Y,m,d,H,M,S}.",
        "",
        {}},

        {"MemoryCheck",
          "\
MemoryCheck[n]\n\n\
checks the consistency of the memory allocation by SAD. The range of the check and the output depend on n:\t\n\n\
MemoryCheck[]  : checks the consistency of the free area and returns the allocation info,\n\
MemoryCheck[1] : checks the consistensy of the free and used areas. Returns the allocation info.\n\
MemoryCheck[2] : checks the consistensy of the free and used areas. Returns the allocation info. and a list of free segments.\t\n\n\
 The returned value is {used, allocated from system, # of free segments, missing size[, list of free segments]} in units of word (= 8 bytes).\n\
 If an inconsistency is found, messages are printed out.",
          "",
          {}},

        {"TracePrint",
          "\
TracePrint[fun]\n\n\
prints out all function calls and each expression compound in \";\" in the evaluation of fun.",
          "",
          {}},

        {"Timing",
          "\
Timing[fun]\n\n\
evaluates fun and returns {cputime, result}. cputime is in seconds.",
          "TimeUsed",
          {}},

        {"TimeUsed",
          "\
TimeUsed[] returns the cputime since the start of SAD in seconds.",
          "Timing",
          {}}
        }]},

     {"Data-Manipulation",
       "",
       "",
       Sort[{
         {"Fit",
        "\
Usage: Fit[data, expr, var, \n\
         {par1, ini1, [{min1, max1}] }, .. ,{parn, inin, [{minn, maxn}]},\n\
         [options..] ]\n\n\
performs a nonlinear fitting of data with an expression expr.\n\n\
data: list of {xi,yi}, {xi,yi,dyi}, or {xi,yi,dxi,dyi}, where dxi and dyi\n\
      are the standard deviation of the i-th point.\n\
expr: an expression containing var as the x-variable, and \n\
      parameters par1,..,parn explicitly. Use Evaluate[fun] if an implicit\n\
      expression is necessary.\n\
var:  a symbol to express the x-axis variable.\n\
par:  parameter symbol to be varied in the fitting.\n\
ini:  initial value of the parameter. It must be specified.\n\
(min, max}: optional range of parameter.\n\n\
Fit returns the result as a list:\n\n\
{par1 -> v1, .., parn->vn, ChiSquare -> chisq, GoodnessOfFit -> good,\n\
ConfidenceInterval -> {c1, .., cn}, ConvarianceMatrix -> cov},\n\n\
where v1,..,vn are the values of the parameters which minimizes chi-square, chisq is the resulting minimum value of the total chi-square (when no error is given for yi, variance is returned), good is a number given by GammaRegularized[(ndata-npara)/2,chisq/2] to represent the goodness of the fit, c1, .., cn are the estimated errors in parameters, and cov is the covariance matrix. A typical criterion of the goodness is (good > 0.1).\n\n\
   Options are\n\n\
MaxIterations        Maximum number of iterations.\n\
D                    If True (default), tries to use analytical derivative.\n\
Cutoff               If nonzero, set the saturation point for each data as:\n\n\
chi-suare = Sum_i ( Min[Cutoff, Max[-Cutoff, (d_i - f_ i) / sigma_i]]^2 ) ,\n\n\
                     which is a sort of robust M-Estimates. By Cutoff, the fit\n\
                     tends to ignore tail data which are beyond Cutoff.\n\
                     If Cutoff is zero (default), it is ignored.",
      "FitPlot",
       {}},

        {"PolynomialFit",
        "\
Usage: PolynomialFit[data, n]\n\n\
performs a 1D linear regression of data.\n\n\
data: list of {xi,yi}\n\
n: the order of the polynomial\n\n\
Fit returns the result as a list:\n\n\
{{c0, .., cn}, {Residual -> res}} ,\n\n\
where c0 .. cn are the coefficients of the fitted polynomial, y = c0 + c1 x + .. + cn x^n . Res is the rms residual of the fit.",
      "FitPlot",
       {}},

       {"FitGaussian",
         "\
Performs Gaussian fit of 1D list data:\n\n\
  FitGaussian[data, [opt, ...]]\n\n\
returns a list\n\n\
  {sigma, mean, {sigma_conf, mean_conf}, chisq} ,\n\n\
where sigma_conf and mean_conf are the confidence interval of the results sigma and mean, respectively. The arguments opt... are options for Fit. If Plot -> True is specified as the option, a plot of the fitting will be made.",
       "Fit FitEmit",
         {}},

       {"FitEmit",
         "\
Obtain the emittance, beta, alpha, etc. from data of particles x and px using FitGaussian.\n\n\
  FitEmit[x, px] ,\n\n\
where x and px are the lists of data of the particles in the phase space, returns a list\n\n\
  {{xmean, pxmean, alpha, beta, emittance},\n\
   {xmean, pxmean, alpha, beta, emittance}_conf},\n\n\
where the second component is the confidence intervals of the results.",
         "FitGaussian",
         {}},

       {"Spline",
         "\
Spline returns data for cubic-spline interpolation.\n\n\
Usage:   sp = Spline[list, [Derivative->{dy1,dy2}] ]\n\n\
where list contains data in the form as {{x1,y1}, ..} or {{x1,{y11, y12, ..}}, ..}.\n\
 Complex number can be allowed for y, but not for x.\n\n\
 This spline assumes y''=0 at the boundary, unless Derivative->{dy1,dy2} is specified to constrain the derivative at each end to dy1 or dy2. They can be Null to unspecify the constraint at one of the boundary. The resulting data of the spline is assigned sp as a SplineData object. Then one can calculate the interpolated data by\n\n\
    sp[x]                     value of y at x.\n\
    Derivative[1][sp][x]      value of y' at x.\n\
    Derivative[2][sp][x]      value of y'' at x.\n\
    Integrate[sp[x],{x, x0, x1}]   integral of sp[x] from x0 to x1.\n\n\
Example:\n\
   sp=Spline[{{1,2},{3,5},{4,2},{5,7}}];\n\
   Plot[{sp[x],Derivative[1][sp][x],Derivative[2][sp][x],Integrate[sp[y],{y,1,#}]&[x]}, {x,1,5}, FrameLabel->{\"x\"}, Thickness->2, Legend->{\"sp[x]\",\"sp'[x]\",\"sp''[x]\",\"Int sp[x]\"}];\n\
   Update[];\n\n\
<Spline.png",
         "defining-functions Plot NIntegrate",
         {}},

       {"NIntegrate",
         "\
NIntegrate returns numerical integration of a Real or Complex\n\
function\n\n\
Usage:   NIntegrate[f, {x, x0, x1}, options]\n\n\
where f is a function containing Symbol x as the independent variable. The integral range is from x0 and x1. The function f must contain the symbol x explicitly.\n\n\
Options           Default      Description\n\
-------------------------------------------------------------\n\
AccuracyGoal      1e-13        Relative accuracy\n\
InitialPoints     20           Number of initial points where\n\
                               the function is evaluated.",
         "",
         {}}}]},

     {"System-interface",
       "",
       "",
      {{"System",
       "\
System[string] executes string as a shell command. It returns the system return code.",
       "",
       {}},

       {"TemporaryName",
        "\
TemporaryName[] returns a unique file name for a temporary use.",
        "",
        {}}}},

     {"Multiprocessing",
       "",
       "",
       {{"Fork",
         "\
Forks the process into a parent and a child processes.\n\n\
   Fork[]\n\n\
returns 0 and the child's pid for the child and the parent, respectively.",
         "",
         {}},

         {"OpenShared",
         "\
Allocated shared memory of n bytes.\n\n\
   s = OpenShared[n] ,\n\n\
where s is a file number to be used by Shared function. The allocated memory can be released by Close[s].",
         "",
         {}},

        {"Shared",
          "\
Read/Write to the shared memory.\n\n\
   Shared[s]\n\
   Shared[s] = x\n\
   Shared[s] := x\n\n\
where s is given by OpenShared, and x is Real, built-in function, String, defined symbol, or list of them.",
          "",
          {}},

       {"SharedSize",
        "\
Returns the size of an object for OpenShared.\n\n\
   n = SharedSize[x] ",
         "",
         {}}}},

     {"Random-number-functions",
      "\
The random number functions use common seed given by SEED command or SeedRandom function. It has an initial value 17 at the beginning of FFS. The cut-off value of GaussRandom[] is given by variable GCUT.",
      "special-variables: GCUT",
      {{"Random",
        "\
Random[]           gives a uniform random number between 0 and 1.\n\
Random[n]          gives a list of n uniform random numbers.\n\
Random[n1, n2, ..] gives a (n1 * n2 * .. ) tensor of uniform random numbers.",
        "GaussRandom ParabolaRandom SeedRandom",
        {}},

       {"GaussRandom",
        "\
GaussRandom[]           gives a Gaussian random number with average 0, \n\
                        standard deviation 1, cutoff at GCUT.\n\
GaussRandom[n]          gives a list of n Gaussian random numbers.\n\
GaussRandom[n1, n2, ..] gives a (n1 * n2 * .. ) tensor of Gaussian random\n\
                        numbers.",

        "Random ParabolaRandom SeedRandom",
        {}},

       {"ParabolaRandom",
        "\
ParabolaRandom[]           gives a parabola random number between -1 and 1. \n\
ParabolaRandom[n]          gives a list of n parabola random numbers.\n\
ParabolaRandom[n1, n2, ..] gives a (n1 * n2 * .. ) tensor of parabola random\n\
                           numbers.",

        "Random GaussRandom SeedRandom",
        {}},

       {"SeedRandom",
        "\
SeedRandom[plugin_String] selects new pseudo random-number generator\n\
                          plugin named as plugin.\n\
SeedRandom[seed_Real]     initializes the internal state of the current\n\
                          pseudo random-number generator plugin by seed.\n\
SeedRandom[{seeds__Real}] initializes the internal state of the current\n\
                          pseudo random-number generator plugin by {seeds}.\n\
SeedRadnom[state_List]    restores both the selection of the pseudo random-number\n\
                          generator plugin and the internal state of the selected\n\
                          plugin by using state dumped by SeedRandom[].\n\
SeedRandom[]              returns List containing both the current selected pseudo\n\
                          random-number generator plugin name and its internal state.",
        "ListRandom Random GaussRandom ParabolaRandom",
        {}},

       {"ListRandom",
        "\
ListRandom[] returns List of available pseudo random-number generator plugins.",
        "SeedRandom",
        {}}}},

     {"Graphics",
      "\
Graphics represents an object for 2D graphics with the form\n\
Graphics[primitives, options]. Up to now available primitives are:\n\n\
Circle[{cx,cy},rx, options]             : Circle. \n\
Circle[{cx,cy},{rx,ry}, options]        : Oval. \n\
Points[{{x1,y1} .. {x2,y2}}, options]   : Points.\n\
Points[{{x1,y1,dx,dy} .. {x2,y2,dx,dy}}, options]  : Points with error bars.\n\
Line[{{x1,y1} .. {x2,y2}}, options]     : Line.\n\
Line[{{x1,y1,dx,dy} .. {x2,y2,dx,dy}}, options]    : Line with error bars.\n\
Rectangle[{x1,y1}, {x2,y2}]             : A box.\n\
Rectangle[{x1,y1}, {x2,y2}, graphic]    : Graphics in a box.\n\
Polygon[{{x1,y1} .. {x2,y2}}, options]  : Polygon.\n\
Text[{string, {x,y}}, options]          : Text-string at {x,y}.\n\n\
Possible options and their defaults values of Graphics are:\n\n\
option           default         optional values\n\
------------------------------------------------\n\
AspectRatio      GoldenRatio     any positive number\n\
DisplayFunction  $DisplayFunction  Identity or Null to suppress display\n\
Detach           False           True to run tdr asynchronously\n\
Epilog           {}              List of primitives\n\
Frame            True            False to erase outline, ticks, ticklabels.\n\
FrameClick       True            to allow click on frame to change options.\n\
FrameLabel       {\"\",\"\",\"\",\"\"}   List of strings\n\
FrameTicks       {Both,Both,Ticks,Ticks}\n\
                                 None to turn off ticks and labels\n\
                                 Both to turn on ticks and labels\n\
                                 Ticks to turn on ticks only\n\
                                 << For bottom tick >>\n\
                                 False is same as Ticks\n\
                                 True is same as Both\n\
                                 << For top tick >>\n\
                                 False is same as None\n\
                                 True is same as Ticks\n\
                                 << For left & right ticks >>\n\
                                 False is same as None\n\
                                 True is same as Both\n\
                                 If a form {___, _List} is given where\n\
                                 the List is a list of {coord, label, opt___}\n\
                                 label is displayed at coord with option opt.\n\
                                 If a form {___, fun} is given and \n\
                                 fun[coord,exp,org] returns a list of options\n\
                                 for Canvas[Create$Text], it is displayed at major\n\
                                 ticks at coord. exp is the exponent and org is the\n\
                                 original label.\n\
GridLines        Automatic       Automatic to draw grid lines at major ticks\n\
                                 {Automatic,None} for only x\n\
                                 {None,Automatic} for only y\n\
                                 Both, Minor, and Major can be also used.\n\
PlotLabel        \"\"              string\n\
PlotRange        Automatic       {ymin,ymax} or {{xmin,xmax},{ymin,ymax}}\n\
Prolog           {}              List of promitives\n\
Scale            {Linear,Linear} Log, Date\n\
TickSize         1               relative size of ticks.\n\
FrameThickness   Automatic       thickness of the frame line incl. ticks.\n\
Legend           \"\"              shows legend-string.\n\
FontScale        1               Relative size of fonts for FrameLabel, FrameTicks.\n\
FrameFontScale   1               Relative size of fonts for FrameLabel.\n\
                                 If Real, applied to all frames. If List, applied to\n\
                                 bottom, left, top, right, supplemented 1s to the right.\n\
TickFontScale    1               Relative size of fonts for FrameTicks.\n\
                                 If Real, applied to all frames. If List, applied to\n\
                                 bottom, left, top, right, supplemented 1s to the right.\n\
LegendFontScale  1               Relative size of fonts for Legend.\n\n\
Options for primitives:\n\n\
For Text:\n\
option           default         optional values\n\
------------------------------------------------\n\
TextAlign        \"\"              \"CENTER\"\n\
TextCases        \"\"              string to represent CASES of TopDrawer\n\
TextPosition     \"\"              \"DATA\" to represent the position by data\n\
                                 coordinates\n\
TextRotate       0\n\
TextSize         1               relative size of a character\n\
PlotColor        \"Black\"         one of \"White\", \"Black\", \"Red\",\n\
                                 \"Green\",\"Blue\",\"Yellow\",\n\
                                 \"Magenta\",\"Cyan\"\n\n\
For Point\n\
option           default         optional values\n\
------------------------------------------------\n\
PointSize        1               relative size of a point\n\
PointSymbol      \"1O\"            Symbol for PLOT of TopDrawer, or Bar\n\
                                 \"6O\",\"7O\",\"8O\",\"9O\" are triangles\n\
                                 in CanvasDrawer.\n\
PlotColor        \"Black\"         one of \"White\", \"Black\", \"Red\",\n\
                                 \"Green\",\"Blue\",\"Yellow\",\n\
                                 \"Magenta\",\"Cyan\"\n\
ErrorBarTickSize 1               length of error bar ticks.\n\n\
For Line\n\
option           default         optional values\n\
------------------------------------------------\n\
Dashing          \"1\"             character string or a list of numbers to\n\
                                 represent the dashing of the line.\n\
Plot             True            whether plot symbols at data points.\n\
                                 If True, PointSize and PointSymbol are\n\
                                 effective (see above).\n\
PlotColor        \"Black\"         one of \"White\", \"Black\", \"Red\",\n\
                                 \"Green\",\"Blue\",\"Yellow\",\n\
                                 \"Magenta\",\"Cyan\"\n\
ErrorBarTickSize 1               length of error bar ticks.\n\
Thickness        1               thickness of line\n\n\
For Polygon\n\
option           default         optional values\n\
------------------------------------------------\n\
Plot             False           whether plot symbols at data points.\n\
                                 If True, PointSize and PointSymbol are\n\
                                 effective (see above).\n\
PointSize        1               relative size of a point\n\
PointSymbol      \"1O\"            Symbol for PLOT of TopDrawer, or Bar\n\
                                 \"6O\",\"7O\",\"8O\",\"9O\" are triangles\n\
                                 in CanvasDrawer.\n\
PointColor       \"forest green\"  point fill color.\n\
PointBorderColor Automatic       point border color.\n\
                                 Automatic measn PointColor.\n\
PointTags        Null            points tag string or list of tag strings.\n\
PlotJoined       True            whether plot border line of polygon.\n\
Thickness        1               thickness of border line\n\n\
Dashing          \"1\"             character string or a list of numbers to\n\
                                 represent the dashing of the line.\n\
PlotColor        \"black\"         border line color.\n\
LineTags         Null            border line tag string.\n\
FillColor        Null            polygon fill color.\n\
                                 Null means empty polygon.\n\
Tags             False           polygon tag string.\n\n\
   ListPlot accepts options for Graphics, Point, and Line.   Show accepts\n\
options for Graphics.   The output is written to file #9 (fort.9 in OSF1 and\n\
ftn09 in HP-UX) in TopDrawer commands.   If SAD is running on X, the plot is\n\
also done immediately.\n\n\
Examples:\n\
  g1=ListPlot[{{1,2},{10,20}},Scale->Log,PlotJoined->True,\n\
    DisplayFunction->Identity];\n\
  g2=ListPlot[{{1,15},{10,3}},Scale->Log,PlotJoined->True,Dashing->\"1 0.3\",\n\
    DisplayFunction->Identity,Plot->False];\n\
  g3=ListPlot[{{1,2.5},{5,10},{10,12}},Scale->Log,\n\
    DisplayFunction->Identity];\n\
  Show[g1,g2,g3,FrameLabel->{\"X (mm)\",\"Log(Y)\"},PlotLabel->\"Test Plot\",\n\
      AspectRatio->1];",
      "",
      Sort[{{"ListPlot",
        "\
Usage: ListPlot[{{x1,y1},..,{xn,yn}}, options]\n\n\
makes a graphic with points.\n\
ListPlot[{y1,..,yn}, options] assumes 1,..n for the x-xoordinate.\n\
ListPlot[{{x,y,dy}, ..}, options ] plots error bars of length dy in y.\n\
ListPlot[{{x,y,dx,dy}, ..}, options ] plots error bars in x and y.\n\n\
option           default         optional values\n\
------------------------------------------------\n\
PlotJoined       False           True\n\
                                 Step\n\
StepRatio        1               ratio of stepping position\n\
                                 between two data points\n\n\
Type ? to see other options for Graphics.\n\n\
Example:\n\
  data1={{1,2},{3,5},{4,-1}};\n\
  data2={{1,4},{2,-2},{3.5,3},{5,3}};\n\
  g1=ListPlot[data1, PointColor->\"dark slate blue\",PlotJoined->True, Thickness->2, PlotColor->\"dark slate blue\", FrameLabel->{\"x\",\"y\"}, Legend->\"data1\", DisplayFunction->Identity];\n\
  g2=ListPlot[data2, PointColor->\"tomato\", Legend->\"data2\", DisplayFunction->Identity];\n\
  Show[g1,g2];\n\
  Update[];\n\n\
<ListPlot.png",
        "Graphics Plot",
        {}},

       {"ColumnPlot",
        "\
Usage:  ColumnPlot[data, options, ...]\n\n\
plots a column plot.\n\
1) If data is a 1D vector, it makes a simple column plot.\n\
2) If data is a 2D matrix, it makes a multiple-column plot.\n\
3) If data is a 3D list, it makes a stacked, multiple-column plot.\n\n\
Besides options common for all plotting functions, ColumnPlot has its own\n\
options:\n\n\
Option           Value          Default             Action\n\
---------------------------------------------------------------------------\n\
ColumnOffset    0 < number < 1  0.15            Ratio of spacing of columns\n\
Reference        number         0               Where column starts\n\
Orientation     Vertical        Vertical        Orientation of columns\n\
                Horizontal\n\
ColumnLabel     List of Str.    Automatic       Labels for each column\n\
                Function                        Scale for column number\n\
                None                            No labels\n\
FillColor       color                           Colors to fill columns\n\
                list of colors\n\
MeshStyle       bitmap                          Bitmap to fill columns\n\
                list of bitmaps                 to distinguish stacking\n\
TextSize        positive number 1               relative label size\n\
PlotNull        True or False   False           plot a minimal rect for 0 occurrence\n\n\
Example:\n\
  g=ColumnPlot[{{{1,1,2},{2,2,3}}, {{1,4,2},{2,2,3}}, {{1,3,2},{2,2,3}}}, Orientation->Horizontal];\n\
  Update[];\n\n\
<ColumnPlot.png",
        "Graphics",
        {}},

       {"HistoPlot",
        "\
Usage:  HistoPlot[data, options, ...]\n\n\
plots a histogram using ColumnPlot(default) or ListPlot.\n\
Data can be a single list, or list of lists, which results in a multi-column histogram on a common axis.\n\
Besides options common for all plotting functions and ColumnPlot, it has its own options:\n\n\
Option           Value          Default             Action\n\
---------------------------------------------------------------------------\n\
Bins            number          Automatic           number of bins\n\
BinRange        {min,max}       Automatic           Range of bins\n\
PlotStyle       ColumnPlot      ColumnPlot          plot function\n\
                ListPlot\n\
                FitPlot\n\
Orientation     Vertical        Vertical            orientation of columns\n\
                Horizontal\n\
FitParameters   args for FitPlot in a list",
        "Graphics ColumnPlot ListPlot FitPlot",
        {}},

       {"ListContourPlot",
        "\
Usage:  ListContourPlot[list, options, ...]\n\n\
plots a contour plot by list which is a 2D List of Real data.\n\n\
Option           Value            Default         Action\n\
---------------------------------------------------------------------------\n\
Contours         Real             10              number of contours\n\
PlotRange        {min,max}, {prxy, prz}, or {prx, pry, prz}\n\
                                  Automatic       depth of contours (prz) and PlotRange for x-y (prxy)\n\
AspectRatio      Real             1\n\
MeshRange        ({x1,xn},{y1,yn}} or {{x1,..,xn},{y1,..,y1n}}\n\
                                  Automatic       Range of x and y axes\n\
ColorFunction    Color scheme (Blue, Purple, Pink, Yellow, Green, Cyan),Function, or String\n\
                                  Blue            Null or None means \"white\"\n\
ContourColorFunction\n\
                 Function or String\n\
                                  Automatic       Null or None to hide\n\
ColorScale       True or False    True            displays a color scale on the right\n\
Smoothing        integer >= 0     1               number of linear interpolations\n\n\
Example:\n\
 xr0=0;xr=Table[xr0+=Sin[i*Pi/21],{i,20}];xr-=(xr[[1]]+xr[[-1]])/2;\n\
 yr=xr;\n\
 table=Outer[Cos[Sqrt[(#^2+#2^2)/2]]&,xr,yr];\n\n\
 gc=Graphics[MapThread[\n\
  Rectangle[#2,#3,\n\
    ListContourPlot[table, MeshRange->{xr, yr}, AspectRatio->1,\n\
      DisplayFunction->Identity, ColorFunction->#,\n\
      FrameLabel->{\"x\", \"y\", ToString[#]}]]&,\n\
   {{ Blue,        Pink,       Green,      Purple,      Yellow,     Cyan},\n\
     {{-0.15,0.65},{0.25,0.65},{0.65,0.65},{-0.15,0   },{0.25,0   },{0.65,0}},\n\
     {{ 0.2, 1.1 },{0.6, 1.1 },{1,   1.1 },{ 0.2, 0.45},{0.6 ,0.45},{1.0, 0.45}}}]];\n\
 Show[gc];Update[];\n\
<ListContourPlot.png",
        "Graphics ListPlot ListDensityPlot",
        {}},

       {"ListDensityPlot",
        "\
Usage:  ListDensityPlot[list, options, ...]\n\n\
plots a density plot by list which is a 2D List of Real data.\n\n\
Option           Value            Default         Action\n\
---------------------------------------------------------------------------\n\
PlotRange        {min,max}, {prxy, prz}, or {prx, pry, prz}\n\
                                  Automatic       depth of contours (prz) and PlotRange for x-y (prxy)\n\
AspectRatio      Real             1\n\
MeshRange        ({x1,xn},{y1,yn}} or {{x1,..,xn},{y1,..,y1n}}\n\
                                  Automatic       Range of x and y axes\n\
ColorFunction    Color scheme (Blue, Purple, Pink, Yellow, Green, Cyan),Function, or String\n\
                                  Blue            Null or None means \"white\"\n\
Mesh             True or False    False           True to draw mesh\n\
MeshColor        Function or String\n\
                                  Automatic       Null or None to hide\n\
ColorScale       True or False    True            displays a color scale on the right\n\
Smoothing        integer >= 0     1               number of linear interpolations\n\n\
Example:\n\
   data = Table[Sin[x]/Cos[x^2 + y^2], {x, -2, 2, 0.1}, {y, -2, 2, 0.1}];\n\
   ListDensityPlot[data,PlotRange->{-5,5}, MeshRange->{{-2,2},{-2,2}}, FrameLabel->{\"x\",\"y\"}];\n\
   Update[];\n\n\
<ListDensityPlot.png",
        "Graphics ListPlot ListContourPlot",
        {}},

        {"GeometryPlot",
	  "\
Usage: GeometryPlot[options]\n\n\
plots a geometry of beam line.\n\n\
options       defaults\n\
-----------------------------------------\n\
Region        {1,LINE[\"LENGTH\"]}  {begin, end}, begin and end can be strings.\n\
                                  Both begin and end point of drawing region\n\
                                  could be given by \"S\" unit by using S[begin|end] form.\n\
Names         \"*\"                 A pattern of component names to be plotted.",
	  "Graphics OpticsPlot",
	  {}},

        {"BeamPlot",
          "\
Usage: BeamPlot[loc, axes, options]\n\n\
plots a beam ellipse at a location loc, for axes. Axes are given by a list \n\
{ax, ay}, where ax and ay are one of \"X\", \"PX\", \"Y\", \"PY\", \"Z\", \"DP\".\n\
The beam envelope should be calculated by (CODPLOT;EMIT) or BEAM commands before\n\
BeamPlot.\n\n\
options       defaults\n\
-----------------------------------------\n\
Orbit         True                Uses Twiss[\"DX\",loc], etc. as the center of\n\
                                  ellipse.\n\
SizeFunction  \"SIZE\"              If \"SIG\", LINE[\"SIG\"] is used.\n\
                                  LINE[\"SIZE\"] is the default.\n\
AspectRatio   1\n\
DataRange     Default             If Default, PlotRange becomes square for\n\
                                  axes = {\"X\", \"Y\"} or {\"PX\", \"PY\"}",
          "BEAMSIZE(BEAM) EMITTANCE(EMIT) CODPLOT",
          {}},

        {"OpticsPlot",
          "\
Usage: OpticsPlot[fun_list, options]\n\n\
makes a plot of built-in optical functions, user-defined functions, or\n\
list of data at components on the beam line.   The parameters are:\t\n\n\
fun_list: a list of objects to be plotted in a window. The number of windows in a plot is the length of fun_list object plotted in a window MUST have same dimensions. An element of fun_list is one of fun_label, fun, list_data or a list as {object, options}, where\n\
fun_label: one of \"AX\", \"BX\", \"GMX\", \"NX\", \"EX\", \"EPX\", \"DX\", \"DPX\", \"AY\", \"BY\", \"GMY\", \"NY\", \"EY\", \"EPY\", \"DY\", \"DPY\", \"R1\", \"R2\", \"R3\", \"R4\", \"DETR\", \"AZ\", \"BZ\", \"GMZ\", \"NZ\", \"ZX\", \"ZPX\", \"ZY\", \"ZPY\", \"DZ\",\"DDP\",\"PEX\", \"PEPX\", \"PEY\", \"PEPY\", \"GAMMA\", \"GAMMABETA\",\"SIGab\", where a and b in \"SIGab\" are one of X, PX, Y, PY, Z, DP. \"R\"//fun_label refers the reference optics. \"D\"//fun_label refers the difference between the current and reference optics.\n\
            fun: Any function of the component number.   A fractional number may be used to obtain the intermediate value.\n\
            list_data: a list of {{pos1, val1}..{posn,valn}}.\t\n\n\
options       defaults\n\
-----------------------------------------\n\
Region        {1,LINE[\"LENGTH\"]}  {begin, end}, begin and end can be strings.\n\
                                  Both begin and end point of drawing region\n\
                                  could be given by \"S\" unit by using S[begin|end] form.\n\
Lattice       True                False to turn of drawing lattice\n\
LatticeRegion Automatic           {low,high}, the region where lattice is drawn\n\
FrameHeight   Automatic           List of relative heights of each frame\n\
InfoLabel     False               If True, pressing Button shows Twiss, etc.\n\
Names         \"*\"                 A pattern of component names to be plotted.\n\
RemoveOverlap \"L$NAME\"            If not \"L$NAME\", overlapping of lattice names\n\
                                  remain untouched.\n\
Tags          False               True to attach tags \"C$\"//(component name)\n\
                                  to each rectangle for the lattice, and\n\
                                  \"L$\"//(component name) to the component \n\
                                  label (CanvasDrawer only).\n\
Legend        False               If Automatic, Legend is composed from FrameLabel\n\
                                  Automatically.\n\n\
options in a fun_list element:\n\
options       defaults\n\
-----------------------------------------\n\
Unit          1                  Unit of the object. \"Meter\", \"InvMeter\",etc.\n\
FrameLabel    \"\"                 Left frame label.\n\
Legend        False               If Automatic, Legend is composed from FrameLabel\n\
                                  Automatically.\n\n\
Example:\n\
   p2=OpticsPlot[{{\"BX\",\"BY\"}, {\"DX\",{{{10,0.001},{20,0.002}}, FrameLabel->\"DX meas.\", Unit->Meter, Thickness->2, Names->\"Q*\"}}}];\n\
   Update[];\n\n\
<OpticsPlot.png",
         "Graphics ListPlot Twiss reference-optics",
         {}},

        {"FitPlot",
          "\
Usage: FitPlot[data, fun, var, {par1,ini1}, .. , {parn, inin}, opt].",
          "Fit",
          {}},

        {"Plot",
          "\
Usage: Plot[fun, range, options] or Plot[{fun1, .. }, range, options],\n\n\
where fun is a function and range is a list given as {x, xmin, xmax}.\n\n\
options        defaults\n\
-----------------------------------------\n\
MaxBend        0.04\n\
PlotPoints     25\n\
PlotDivision   250\n\
Dashing        {\"1\",\"0.8 0.24\",\"0.4 0.12\",\"0.2 0.08\",\"0.1 0.08\",\n\
                  \"0.8 0.08 0.08 0.08\",\"0.4 0.08 0.08 0.08\"}\n\
Options for ListPlot and Graphics are also available\n\n\
The independent variable should have been cleared (i.e., no value should\n\
not be set) when Plot is called. \n\n\
Example:\n\
  ff[x_]:=Sin[x]/x;\n\
  ff[0]=1;\n\
  Plot[{Cos[x],ff[x]}, {x,0,10}, Thickness->2];\n\
  Update[];\n\n\
<Plot.png",
          "Graphics ListPlot",
          {}}
     }]},

       {"DownhillSimplex",
         "\
Usage: DownhillSimplex[initial, f, options]\n\n\
minimizes a function f by the downhill simplex method, starting from an initial simplex initial.  Suppose f is a function of n variables.   Then  initial is a list of n+1 elements, each of which is a list of the form\n\n\
   {f[vi], vi} ,\n\n\
where vi is a list of n values corresponding to each variable. The initial must be sorted in ascending order of f, i.e.,\n\n\
   initial=Sort[Map[{f[#],#}&,vlist]]\n\n\
generates initial from a list of variables vlist.\n\
   DownhillSimplex returns the final simplex in the same form as initial.\n\n\
Options:\n\
   VariableRange -> {{min1 .. minn}, {max1 .. maxn}} gives the range of n\n\
      variables.   The default is -Infinity to Infinity for all variables.\n\
   MaxIteration -> maxi gives the limit of number of iterations.   The\n\
      default is Max[100, 10*(n+1)].\n\
   Output -> lfn sets the output file number for the intermediate results.\n\
      the default is 6 (stdout).\n\
   Tolerance -> tol sets the tolerance to judge the local minimum.\n\
      If (fmax-fmin)/(abs(fmax)+abs(fmin)) becomes less than tol, the \n\
      iteration loop terminates.   The default is 10^-6.\n\n\
Examples:\n\
  f:=Apply[Function[{x,y},((x^2+y^2)-1)*(x^2+y^2)-(x-.5)/3.],#]&;\n\
  v={{1.,1.},{0.,-1.},{0.,1.}};\n\
  limit={{-0.5,-1.5},{0.65,1.5}};\n\
  p=Sort[Map[{f[#],#}&,v]]\n\
  DownhillSimplex[p,f,MaxIteration->100,\n\
     Tolerance->1e-4,VariableRange->limit]",
      "FFS-dedicated-functions:OptimizeOptics",
      {}},

     {"FFS-dedicated-functions",
      "\
Functions dedicated to the optics calculations and simulations in FFS.",
      "",
      Sort[{
        {"OptimizeOptics",
        "\
Usage: OptimizeOptics[options]\n\n\
optimizes (1 + MatchingResidual) or any function using DownhillSimplex with variables specified by FREE. Unlike GO, any keyword of any element can be a variable.\n\
   OptimizeOptics returns the final simplex. The variables are set to the values which give the minimum of the function so far at the end.\n\n\
Options:\n\
   All options for DownhillSimplex are valid.\n\
   OptimizeFunction -> fun is the function to be minimized. The default is\n\
      ((FFS[\"CALC\"];1+MatchingResidual)&).\n\
   InitialSimplex -> initial sets the initial simplex to initial. The\n\
      default is Null, which mean to create initial from the current value\n\
      of the variables. Its format is same as for initial of \n\
      DownhillSimplex\n\
   SimplexSize -> size is the initial size of the simplex. Each variable\n\
      is relatively shifted by this amount from the current value.\n\n\
Example:\n\
   free Q* Q* L\n\
   fit nx .3 ny .2\n\
   OptimizeOptics[]\n\n\
optimizes the optics by changing the lengths of quads which are not allowed by GO, as well as K1 of quads.",
        "DownhillSimplex",
        {}},

       {"FFS",
        "\
FFS[command-string] executes command-string as FFS commands. Any commands can be used. Some commands CALCULATE(CAL), GO, VARIABLES(VAR), SHOW returns their result, otherwise Null is returned. All outputs of the commands are suppressed.\n\
   FFS[command-string,lo] directs the output of the commands to file-number lo. The file-number lo may be given by OpenWrite or OpenAppend.\n\
   The IF structure and REPEAT(REP) loop must complete within a single FFS.",
        "Input/Output OpenWrite OpenAppend",
        {}},

       {"FFS$SHOW",
         SHOW$message,
         "SHOW",
         {}},

       {"ExternalMap",
        "\
With MAP elements, ExternalMap defines a user-defined map of particles. It also allows a user to do anything (doing statistics, etc.) at any point of a beam line during a tracking. \n\n\
Usage: First define a MAP element at MAIN level:\n\n\
     MAP    name=(L=leng);\n\n\
Right now L is the only keyword. Insert it at the location(s) \n\
where you want to use it.\n\n\
1) Tracking\n\
In FFS, define the function ExternalMap as\n\n\
    ExternalMap[\"TRACK\",n,nt_,x_]:=body;\n\n\
The second argument n is the position of MAP counting from the beginning, which can be obtained using LINE[\"POSITION\",\"name.m\"]. The third argument nt_ is used to receive the number of turns which is incremented by the tracking. The last argument x_ is used to receive the coordinates of particles. It is a (7, np) list of real numbers. The elements  (1..6, i) are (x, px ,y ,py ,z ,dp/p0) of the i-th particle. The (7, i)  element is True(==1) if the i-th particle has been survived, and False(==0) if it has been lost.\n\n\
 You can define ExternalMap to change the coordinates of each particle as you like by returning a new x in the same format as above. If you do not return it or you return in a different format, the tracking routine does not change the particle coordinates. You can neither rebirth a lost particle nor kill a surviving particle.\n\n\
After defined ExternalMap, tracking calls it in every turn.\n\n\
Example:\n\n\
   MAP P1=();\n\
   ....\n\
   LINE A=(... P1 ... P1 ...);\n\
   ....\n\
   FFS USE=A;\n\
     ExternalMap[\"TRACK\",LINE[\"POSITION\",\"P1.2\"],nt_,x_]:=\n\
	(Print[x];x*2);\n\
   ....\n\n\
   TRACK USE=A ....;\n\n\
This example defines ExternalMap to print out the coordinates of all\n\
particles at the second P1 in the line A. It also makes all coordinates\n\
of all particles twice in every turn.\n\n\
2) Emittance\n\
In FFS, define the function ExternalMap as\n\n\
    ExternalMap[\"EMIT\",n,cod_]:=body;\n\n\
The second argument n is the position of MAP counting from the beginning, which can be obtained using LINE[\"POSITION\",\"name.m\"]. The last argument cod_ is used to receive the orbit at the entrance of the element, as a list of 6 real numbers. ExternalMap must return a list, either {cod1, trans} or  {cod1, trans, dtrans, dbeam}, where cod1 is the orbit at the exit, trans is the 6 by 6 transfer matrix of this element, dtrans is the radiation damping part of the transfer matrix (6 by 6), and dbeam is the radiation excitation of the beam matrix (6 by 6). Only j >= i parts of dbeam[[i, j]] are taken into account.\n\n\
Example:\n\n\
    ExternalMap[\"EMIT\",LINE[\"POSITION\",\"P1\"],cod_]:=(\n\
      Print[cod];\n\
      {cod+{0,0.001,0,0,0,0},IdentityMatrix[6]});\n\n\
3) Optics\n\
In FFS, define the function ExternalMap as\n\n\
    ExternalMap[\"OPTICS\",n,cod_]:=body;\n\n\
The second argument n is the position of MAP counting from the beginning, which can be obtained using LINE[\"POSITION\",\"name.m\"]. The last argument cod_ is used to receive the orbit at the entrance of the element, as a list of 6 real numbers. ExternalMap must return a list {cod1, trans}, where cod1 is the orbit at the exit and trans is the 6 by 6 transfer matrix of this element. In the case of CACL4D (== ~CALC6D), only the 4 by 5 transfer matrix is effective.\n\n\
Example:\n\n\
    ExternalMap[\"OPTICS\",LINE[\"POSITION\",\"P1\"],cod_]:=(\n\
      Print[cod];\n\
      {cod+{0,0.001,0,0,0,0},IdentityMatrix[6]});\n\n\
4) Geometry\n\
In FFS, define the function ExternalMap as\n\n\
    ExternalMap[\"GEO\",n,geo_,pos_]:=body;\n\n\
The second argument n is the position of MAP counting from the beginning, which can be obtained using LINE[\"POSITION\",\"name.m\"]. The argument geo_ receives the geometry of the beam line at the MAP element, in the same format as LINE[\"GEO\",n], i.e., {{GX,GY,GZ},{CHI1,CHI2,CHI3}}. The last argument pos_ receives the orbit length S at the element. ExternalMap must return an updated list {geo1, pos1}, as { {{GX,GY,GZ},{CHI1,CHI2,CHI3}}, S} as the values at the exit of the element.\n\
Example:\n\n\
    ExternalMap[\"GEO\",LINE[\"POSITION\",\"P1\"],geo_,pos_]:=(\n\
      Print[cod];\n\
      { {geo[[1]]+{1,0,0}, geo[[2]]}, pos+0.1})",
        "MAP CALC4D",
        {}},

       {"Element",
        "\
Element[key-string, {element-pattern-string | element-position}] returns values for key-string of elements which match element-pattern-string or located at element-position. It returns a list if more than one elements match. The key-string and element-pattern-string can be symbols, unless values are not assigned to them.\n\
   If the second argument is omitted, it means all elements.\n\
   The element-position can be known by Element[\"POSITION\"].\n\
   Key-strings \"VALUE\" and element-keywords allows to be set (i.e., Element[a,b] = v) when element-pattern-string chooses only one element. If a value is set to Element, it is automatically distributed to all components those belong to the element. If the keyword is the default variable, the error given by machine-error-command DK is applied.\n\
   The arguments of Element can be lists. It automatically maps as\n\n\
   Element[{a,b,c..},y]  means {Element[a,y],Element[b,y],Element[c,y]..}\n\
   Element[x,{a,b,c..}]  means {Element[x,a],Element[x,b],Element[x,c]..},\n\n\
where both x and y can be also a list.\n\n\
   If an option Saved->True is given, Element refers the save-buffer which can be transferred to other beam lines. Otherwise values set by Element are not saved when FFS is stopped, unless they are the default-keyword or keywords once used in matching.",
        "elements wildcards components LINE SetElement",
        {{"key-strings:Element",
          "\
The key-string is not case-sensitive. Available key-strings are:\t\n\n\
\"LENGTH\"       Number of elements in the beam line. No second argument.\n\
\"POSITION\"     Position of the element in the element-list.\n\
\"NAME\"         Name of the element.\n\
\"VALUE\"        Current value of the default keyword of the element.\n\
\"KEYWORDS\"     List of available keywords of the element.\n\
\"DEFAULT\"      The default keyword of the element\n\
\"TYPE\"         The internal code-number of the type of the element.\n\
\"TYPENAME\"     The name of the type of the element.\n\
keyword        If keyword is the default keyword, it means the current value. If not, it means the saved value. Changing the non-default keyword by Element does not affects the current setting of the components.\n\
\"EXPAND\"       Distribute the value of the default-keywords and the keywords used in the matching to all components in the beam line. No second argument.\t\n\n\
Setting by Element[\"VALUE\",..] or Element[keyword,..] to the DEFAULT  keyword or a matching-variable keyword changes the current value, and  distributed to the components in the succeeding calculation.",
          "set-value-of-element elements keywords default-keyword components",
          {}}}},

       {"LINE",
        "\
LINE[key-string, {component-pattern-string | component-position}]\n\n\
returns values for key-string of components which match component-pattern-string or located at component-position. It returns a list if more than one components match. The key-string and component-pattern-string can be symbols, unless values are not assigned to them. The second arg can be a fractional number to denote an intermediate value of two components.\n\
   If the second argument is omitted, it means all components.\n\
   The component-position can be known by LINE[\"POSITION\"].\n\
   Key-strings \"DIR\" and component-keywords allows to be set (i.e.,\n\
LINE[a,b] = v) when component-pattern-string chooses only one component.\n\
   The arguments of LINE can be lists. It automatically maps as\n\n\
   LINE[{a,b,c..},y]  means {LINE[a,y],LINE[b,y],LINE[c,y]..}\n\
   LINE[x,{a,b,c..}]  means {LINE[x,a],LINE[x,b],LINE[x,c]..},\n\n\
where both x and y can be also a list.",
        "components wildcards elements Element",
        {{"key-strings:LINE",
          "\
The key-string is not case-sensitive. Available key-strings are:\t\n\n\
\"LENGTH\"       Number of components in the beam line. No second argument.\n\
\"POSITION\"     Position of the component in the beam line.\n\
\"NAME\"         Name of the component.\n\
\"TYPE\"         The internal code-number of the type of the component.\n\
\"TYPENAME\"     The name of the type of the component.\n\
\"ELEMENT\"      The name of the corresponding element.\n\
\"DIR\"          The orientation of the component, +-1.\n\
\"S\"            The orbit length to the entrance from the beginning of the beam line.\n\
\"LENG\"         Same as \"S\".\n\
\"GEO\"          Geometric-functions at the entrance of the component, {{GX, GY, GZ}, {GCHI1, GCHI2, GCHI3}}.\n\
\"OGEO\"         Geometric-functions of the orbit at the entrance of the component, {{OGX, OGY, OGZ}, {OCHI1, OCHI2, OCHI3}}.\n\
\"GAMMA\"        Lorentz factor gamma.\n\
\"GAMMABETA\"    Lorentz factor gamma*beta = Sqrt[gamma^2 - 1].\n\
\"SIGab\"        Beam matrix component, where a and b are one of X, PX, Y, PY, Z, DP. If b is omitted it returns Sqrt[SIGaa] is returned. Just \"SIG\" returns the entire 6 by 6 beam matrix.\n\
\"SIZEab\"       Beam matrix component calculated by (CODPLOT;EMIT), where a and b are one of X, PX, Y, PY, Z, DP. If b is omitted it returns Sqrt[SIZEaa] is returned.- \"SIZE\" returns the entire 6 by 6 beam matrix.\n\
\"MULT\"         The ordered number of each component belonging to the- same element, starting from 1.\n\
keyword        The value of the keyword of the component (see below).\n\
\"EXPAND\"       Distribute the value of the default-keywords and the keywords used in the matching to all components in the beam line. No second argument.\t\n\
\"GX\", \"GY\", \"GZ\"  Geometric functions for the coordinate GX, GY, GZ.\n\
\"GCHI1\", \"GCHI2\", \"GCHI3\"  Geometric functions for the coordinate CHI1, CHI2, CHI3\n\
\"OGX\", \"OGY\", \"OGZ\", \"OCHI1\", \"OCHI2\", \"OCHI3\"  Geometrical functions for the orbit.\n\
 Setting by LINE[keyword,..] to the DEFAULT keyword for the FIRST component changes the current value of the corresponding element, because the value of an element is stored in the first component.",
          "components geometric-functions elements keywords default-keyword Element",
          {}}}},

       {"Twiss",
        "\
 Twiss[optical-function, component] returns the value of the optical-function at the entrance of component. The values are those calculated by the last CALCULATE(CALC) or GO commands, or CalculateOptics function.\n\
 The second argument, component can be a name of component, a component number, or a list of them. If the number has a fraction, the intermediate value in the component is calculated.\n\
 Twiss[\"ALL\",component] or Twiss[\"*\",component] returns all 28 optical-functions at the entrance of component as a list:\n\n\
{AX, BX, GMX, NX, AY, BY, GMY, NY, EX, EPX, EY, EPY, R1, R2, R3, R4, DETR, DX, DPX, DY, DPY, DZ, DDP, AZ, BZ, GMZ, NZ, ZX, ZPX, ZY, ZPY},\n\n\
which can be directly used in CalculateOptics. In the current version, however, parameters after AZ are uninteresting, because it always returns 1 for BZ and zeros for the others. \"R\"//optical-function refers the reference optics. \"D\"//optical-function refers the difference between the current and the referece optics. \"RALL\" and \"DAL\" mean the all optical functions for the reference optics and the differences, respectively.\n\
   Keywords \"PEX\", \"PEPX\", \"PEY\", \"PEPY\", \"PZX\", \"PZPX\", \"PZY\", \"PZPY\" return dispersions in the physical coordinate.\n\
   Keywords \"LENGTH\", \"GAMMA\", \"GAMMABETA\", \"S\", \"SIGab\" return the same results as for the function LINE.\n\
   The units of NX, NY, NZ are in radian.",
        "DRAW optical-functions extended-Twiss-parameters CalculateOptics LINE reference-optics",
          {}},

       {"FitValue",
        "\
Usage:\n\n\
(1) FitValue[component, function, {id_,dp_}, goal_, now_] := body\n\n\
modifies the goal of the matching of function at component. The argument id_ is the orbit id for MatchingAmplitude or InitialOrbits. The argument dp_ receives the value of dp/p0. The argument goal_ is the value of the goal of the matching set by matching-function-commands. The argument now_ is the current value of function.\n\n\
Example: FitValue[\"$$$\", \"NX\", {_,dp_}, goal_, now_] := goal + dp * xix * 2 * Pi\n\n\
sets the tune NX to have chromaticity xix.\n\n\
(2) FitValue[component1, component2, function, {id_,dp_}, goal_, now1_, now2_] := body\n\n\
modifies the value of the function at component1 for a two-component matching. Component1 is assumed upstream in the beam line. The value of body is used in place of the current value, now1. The argument id_ is the orbit id for MatchingAmplitude or InitialOrbits. The argument dp_ receives the value of dp/p0. The argument goal_ is the value of the goal of the matching set by matching-function-commands. The argument now1 and now2 are the current values of the function at component1 and component2, respectively.\n\n\
Example: FitValue[\"QF1\", \"QF2\", \"NX\", _, goal_, now1_, now2_] := \n\
   If[Abs[now2-(now1+goal)] < 0.01*2*Pi , Null, now1]\n\n\
sets the tune difference between QF1 and QF2 gaol +- 0.01.\n\n\
   During the matching process the matching routine calls FitValue with arguments, then if body returns a number, it overrides the goal give by matching-function-commands. If body returns Null, the matching of function is ignored.\n\
   The matching-function-command is necessary besides FitValue to perform the matching. Only defining FitValue does not do the matching.\n\
   FitValue is cleared by USE. It is hidden by VISIT and restored by BYE",
        "matching-function-commands off-momentum-matching",
        {}},

       {"VariableRange",
        "\
Usage:   VariableRange[element, keyword ,v_] := expression\n\n\
where the current value of the element:keyword is passed in v_, and expression should give False when the value is out of range.\n\n\
Example: VariableRange[\"QF\",\"ROTATE\",v_]:= -0.1 < v < 0.1;\n\n\
This restricts the range of the rotation angle of QF within +-100 mrad.\n\n\
         VariableRange[_,\"ROTATE\",v_]:= -0.1 < v < 0.1;\n\n\
This specifies the same for all elements.\n\
   The expression can also return the range as a list {vmin, vmax}, which may give more chance of solution-finding for the matching routine.\n\
   VariableRange only acts for variables used in the matching with the FREE command.",
        "FREE set-value-of-element",
        {}},

       {"VariableWeight",
        "\
Usage:   VariableWeight[element, keyword ,v_] := expression\n\n\
where the default weight for matching with element:keyword is passed in v_, and expression should return a modified value of weight. If non-real is returned, the default weight is used.\n\n\
Example: VariableWeight[\"QF\",\"K1\",v_]:= 0.1*v;\n\n\
reduces the weight of QF1:K1 to 1/10 of the default value.\n\n\
   The weight also affects the step size of the numerical derivative of the response. A smaller weight makes the step size larger.\n\n\
   VariableWeight only acts for variables used in the matching with the FREE command.",
        "FREE set-value-of-element",
        {}},

       {"FitWeight",
        "\
 A defined function to modify the weight of matching of particular function at particular component with particular momentum offset.\n\n\
Usage:   FitWeight[component, function, {id_,dp_}, default_] := weight;\n\n\
where\t\n\n\
component  is the name of the location of the fit, like \"QF.2\", etc.\n\
function   is the name of the matching-function, like \"BX\", \"LENG\", etc.\n\
id_        is the id number of the orbit for MatchingAmplitude or InitialOrbits.\n\
dp_        is a variable to receive the momentum deviation of the fit.\n\
default_   is a variable to receive the default fit weight.\n\
weight     is an expression which returns the desired weight.\t\n\n\
Example: FitWeight[\"$$$\",\"LENG\",{_,dp_},ws_]:=ws*10;\n\n\
makes the weight of LENG at $$$ 10 times (100 times in MatchingResidual) bigger than the default.",
        "matching-function-commands special-variables MatchingResidual",
        {}},

       {"Emittance",
        "\
Emittance[option] returns a set of rules as \n\n\
   {keyword1->value1, keyword2->value2, ..} .\n\n\
Its options and default values are Matrix(False), Orbit(False), OneTurnInformation(False), Emittance(True), ExpandElementValues(True), SaveEMIT(False), InitialOrbit(Null), InitialBeamMatrix(Null), Region({1,-1}), and Output(0).\n\n\
If Emittance->False is specified, the resulting keywords are:\t\n\n\
Stable                  True if all modes are stable and the closed orbit is found.\n\
Region                  The region {begin, end} to calculate.\n\
Tunes                   {nux, nuy, nuz} .\n\
EnergyLossU0            One turn energy loss in eV.\n\
RfVoltageVc             The effective RF voltage (V).\n\
EquilibriumPosition     dz in meter.\n\
MomentumCompaction      -dz/dp\n\
OrbitDilation           ds in meter.\n\
BucketHeight            dV/E0\n\
HarmonicNumber          The effective harmonic number\n\
OrbitAtExit             physical c.o.d. at the end of line.\t\n\n\
If None of the options is given, the following keywords are added:\t\n\n\
DampingRate             {T0/taux, T0/tauy, T0/tauz}\n\
Emittances              {emitx, emity, emitz} *1)\n\
MomentumSpread          sigma p/p0\n\
BunchLength             sigma_z\n\
Polarization            equilibrium polarization, if POL is on\n\
Polarization2           equilibrium polarization by up to 2nd order calculation\n\
Polarization4           equilibrium polarization by up to 4th order calculation\n\
Polarization6           equilibrium polarization by up to 6th order calculation\n\
PolarizationVector      direction of polarization AppendTo the entrance of the beam line\n\
SpinTune                spin tune on the closed orbit\n\
NominalSpinTune         spin tune calculated by MOMENTUM and electron g-2\n\
TuneShiftByRadiation    {dnux, dnuy, dnuz}\t\n\n\
If OneTurnInformation->True, or Orbit->True, or Matrix->True, the followings are added.\t\n\n\
OrbitAtEntrance         physical c.o.d. at the entrance of the ring.\n\
OneTurnTransferMatrix   symplectic part of the one-turn transfer matrix.\n\
OneTurnDampingMatrix    deviation of transfer matrix due to radiation.\n\
NormalCoordinates       conversion matrix from physical to normal coords.\n\
OneTurnExcitation       excitation matrix by radiation and intrabeam scattering (with INTRA).\n\
EquilibriumBeamMatrix   equilibrium beam matrix.\n\
ExtendedTwissParameters list of rules giving the extended Twiss parameters at the entrance of the ring.\t\n\n\
If Orbit->True or Matrix->True, the following is added:\t\n\n\
ClosedOrbit             List of physical closed orbit at every element in the ring.\t\n\n\
If Matrix->True, the followings are added:\t\n\n\
TransferMatrices        List of physical transfer matrix from the beginning of the beam line to all elements.\n\
IntrabeamExcitation     List of the change of the 6 x 6 beam matrix due to the intrabeam scattering (only when INTRA), converted to the beginning of the beam line.\t\n\n\
   If the flag TRPT or NORING is set, the calculation assumes a transport line so that several quantities such as damping rate, eigen modes, equilibrium beam matrix, etc. are meaningless. Use RING or NOTRPT for such calculation. In the case of TRPT or NORING, the incoming beam envelope must be given by the option InitialBeamMatrix with a 6 x 6 symmetric matrix. TRPT is useful for calculation of space charge and intrabeam in a transport line.\n\
   Please do not forget to put semicolon at the end of Emittance[] function, otherwise the output will be huge especially when Orbit or Matrix is True.\n If ExpandElementValues->False, calculation is made using the present values of each component (i.e., including machine errors).\n\n\
If SaveEMIT->True, the calculated values of emittances are stored in variables EMITX, EMITY, EMITZ, SIGE, SIGZ. The default is SaveEMIT->False.\n\n\
InitialOrbit->{x0,px0,y0,py0,z0,dp0/p0} specifies the incoming orbit which is valid when NOCOD is set. The option Output->filenum enables the print out of EMITTANCE(EMIT) to filnum.\n\n\
If Region is not the entire ring, parameters such as Emittances and DampingRate, etc., are not calculated, and return NaNs.\n\n\
*1) The values of Emittances with INTRA and MINCOUP correspond to the equilibrium with intrabeam scattering weakened by MINCOUP.",
        "EMITTANCE(EMIT) SymplecticJ COD EMITX EMITY EMITZ SIGZ SIGE POL MINCOUP equilibrium-beam-envelope",
        {}},

       {"TrackParticles",
        "\
TrackParticles[beam, destination-component, nbegin, nend]\n\n\
returns a beam after the tracking at the entrance of the destination- component. The destination can be specified by the name of the component or by a number obtained by LINE[\"POSITION\", component]. If destination is omitted, the end of the line is assumed.\n\n\
The argument nbegin is the initial turn number to be passed to tracking to indicate it is in the n-th turn. The number is increased by 1 when it passes the end of beam line. If nbegin is omitted, 1 is assumed.\n\n\
The argument nend is the last turn number. The default is nbegin.\n\n\
   The variable beam and also the result of TrackParticles are lists of the form \n\n\
   {location, coordinates}\n\n\
where location is the position-number of the starting point. If location is same as or in the downstream of destination, the tracking is done by folding across the beginning of the beam line. The coordinates are in a list of {7, np} form, where np is the number of particles. The first 6 elements of coordinates specifies\n\n\
   {x, px/p0, y, py/p0, z, dp/p0}\n\n\
in this order. The {7, i} is the flag which is True(==1) when the particle is alive, and False(==0) when lost.\n\n\
   If the flag POL is on, TrackParticles performs spin tracking. Then the coordinates has two more components sy and phis, which correspond to the y-component of the classical spin vector and the angle ArcTan[sx, sz], respectively. If POL is on, another flag RADPOL turns on the Sokolov-Ternov effect.\n\n\
   When a flag RADLIGHT is on, TrackParticles returns the trajectories of particles which are used to calculate the radiation fields. See RadiationField and RadiationSpectrum.\n\n\
When PHOTONS is ON (default is OFF), TrackParticles generates a list of all photons radiated through the tracking. The list is assigned to a symbol PhotonList.\n\n\
When LOSSMAP is ON (default is OFF), TrackParticles returns the component and the turn where the loss of each particle is detected.",
        "components LINE PHOTONS PhotonList RADLIGHT TouschekLifetime WakeFunction SurvivedParticles LOSSMAP POL RADPOL",
        {}},

       {"SurvivedParticles",
"SurvivedParticles[x]\n\n\
returns the list of 6 coordinates and the flag of the survived particles in x. The form of x is {x, px/p0, y, py/p0, z, dp/p0, flag}, where each is a list of length of the number of particles. If all particles are lost, it is a list of seven null lists.",
         "TrackParticles",
         {}},

       {"TouschekLifetime",
"TouschekLifetime interpolates the data calculated by EMIT or Emittance[]. There are three ways of usage:\n\n\
   TouschekLifetime[Infinity, Infinity, nz]: Touschek lifetime in seconds\n\
     with momentum aperture nz * SIGE.\n\n\
   TouschekLifetime[nx, Infinity, nz]: Touschek lifetime in seconds\n\
     with acceptance 2Jx/(nx * (EMITX+EMITY)) + 2Jz/(nz * EMITZ) < 1.\n\n\
   TouschekLifetime[Infinity, ny, nz]: Touschek lifetime in seconds\n\
     with acceptance 2Jy/(ny * (EMITX+EMITY)) + 2Jz/(nz * EMITZ) < 1.\n\n\
EMIT or Emittance[] with INTRA must precede TouschekLifetime.",
         "EMITTANCE(EMIT) Emittance INTRA MINCOUP equilibrium-beam-envelope",
         {}},

       {"GaussianCoulomb",
         EquAlign["Text[\
{\\tt GaussianCoulomb[x, y, sigx, sigy]} returns the electromagnetic force $f_x+if_y$ at the coordinates $(x,y)$, generated by a Gaussian bunch with sizes {\\tt (sigx,sigy)}=$(\\sigma_x,\\sigma_y)$. Its derivative at the origin is\n\
\\begin{align} \
\\frac{\\partial f_x}{\\partial x}&=-2 \\frac{x}{\\sigma_x(\\sigma_x+\\sigma_y)}\\ ,\\\\\
\\frac{\\partial f_y}{\\partial y}&=-2 \\frac{y}{\\sigma_y(\\sigma_x+\\sigma_y)}\\ .\
\\end{align}\
;;;12]",""],
         "",{}},

       {"SynchroBetaEmittance",
        "\
SynchroBetaEmittance calculates equilibrium emittance under influence of synchrotron motion and chromaticity.\n\n\
Usage:\n\n\
   SynchroBetaEmittance[{nus0, nus1, dnus},options]\n\n\
or\n\n\
   SynchroBetaEmittance[nus0,options]\n\n\
where nus0, nus1, and dnus are the starting, ending and step size of synchrotron tune, respectively. If only nus0 is given, calculation is done only for nus0. The returned value is a list:\n\n\
   {{nus, emitx, emity, emitxp, emityp, conv}, ... }\n\n\
where nus, emitx, emity, emitxp, emityp, conv are the synchrotron tune, equilibrium horizontal and vertical emittances, horizontal and vertical projected emittances, and the convergence, respectively. When conv is negative, calculation failed to converge, and the returned emittances are not reliable.\n\n\
Options               Type        Default     Meaning\n\
-----------------------------------------------------------\n\
AzimuthalModes        Real        9           Number of azimuthal modes",
         "SYNCHTOBETA(SYNCHROB) equilibrium-beam-envelope",
         {}},

       {"AccelerateParticles",
        "\
AccelerateParticles does TrackParticles with acceleration in a ring for a given number of turns. The adiabatic damping is automatically taken cared.\n\n\
Usage:    AccelerateParticles[beam_,mom_,{n_Symbol,nturn_},opt___]\n\n\
where beam is a list of beam coordinates in the same format for TrackParticles. mom is an expression to determine MOMENTUM in each turn as a function of turn number n. nturn is the total number of turns. An option Synchronize specifies a routine to be executed at every turn of the tracking (e.g. changing voltages and magnet settings, or storing the results.)\n\n\
Example:\n\
  AccelerateParticles[\n\
    beam,\n\
    Which[\n\
      n < 100,  1e9,\n\
      n <= 200, 1e9 + (n - 100) * 1e7,\n\
      True, 2e9],\n\
    {n, 300},\n\
    Synchronize :> ((\n\
      d = {d, MOMENTUM/1e9 * (1 + #2[[2,6,1]])})&)];",
         "TrackParticles",
           {}},

       {"OrbitGeo",
        "\
OrbitGeo[location] returns the geometry {GX, GY, GZ} of the current (not design) orbit.",
        "GEO GeoBase",
         {}},

       {"GeoBase",
        "\
GeoBase[{chi1, chi2, chi3}] converts the rotation angles of the coordinate base vectors to a transformation matrix {{x_gx,x_gy,x_gz}, {y_gx,y_gy,y_gz}, {z_gx,z_gy,z_gz}}",
         "GEO OrbitGeo",
         {}},

       RADLIGHT$Message="\
To calculate the field of the synchrotron radiation from particles, first record trajectories of particles. This is done by the function TrackParticles with a new flag RADLIGHT on. When RADLIGHT is on, TrackParticles returns a list\n\n\
   {beam, trajectory} ,\n\n\
where beam is a list as {location, coordinates}, and trajectory is a list\n\n\
   { {t1 .. tm}, {x1 ..xm}, {y1 .. ym}, {z1 .. zm} }, ..\n\n\
where {t,x,y,z}_i is the coordinates of the particle at i-th point in the trajectory. The origin and the direction of the spatial coordinates are the same as GEO coordinate {GX, GY, GZ}. One can track many particles at the same time by TrackParticles, so the trajectory has the dimensions {np, m}, where np is the number of particles.\n\n\
   After the trajectory is obtained, one can calculate the field in time domain\n\
at any observation point. This is done by the function RadiationFiled as\n\n\
   field = RadiationField[ trajectory[[i]], obs];\n\n\
where trajectory[[i]] is the trajectory of the i-th particle, and obs is the spatial coordinate of the observation point in the GEO coordinate. The output field is a list\n\n\
   { {tau1 .. taum},\n\
     {Ex1 .. Exm}, {Ey1 .. Eym}, {Ez1 .. Ezm},\n\
     {Hx1 .. Hxm}, {Hy1 .. Hym}, {Hz1 .. Hzm},\n\
     {Sx1 .. Sxm}, {Sy1 .. Sym}, {Sz1 .. Hzm} }\n\n\
where H = (n x E)/(c mu0) and S = E x H , and tau is the observation time.\n\
   RadiationField uses the Feynmann-Heviside formula\n\n\
   E = (mu0 e*CHARGE/4pi) (c^2n/R^2 + R/c d(c^2n/R^2)/dt + d^2n/dt^2) ,\n where n and R are the direction vector and the distance from the electron at the retarded time to an observation point. \n\
   The derivatives in the above formula is calculated using the spline\n\
interpolation.\n\n\
   Next one can calculate the spectrum of the field by RadiationSpectrum as\n\n\
   spect = RadiationSpectrum[ {field[[1]], field[[k]]},\n\
        {lambda1, lambda2, dlambda} ] ,\n\n\
where filed[[k]] is one of the fields calculated by RadiationField. The range of the wavelength is given as a list above. The output spectrum spect is a list as\n\n\
   { {k1 .. kk}, {c1 .. ck}, {s1 .. sk} } ,\n\n\
where k1 .. kk is the wave number k = omega/c, c1 .. ck and s1 .. sk are the cosine and sine integrals of the field in tau1 .. taum , i.e.,\n\n\
   ck + I sk = Integrate[ field[tau] Exp[I c k tau] dtau] .\n\n\
   An example is seen in $(SAD_ROOTPATH)/sad/examples.sad .";

       {"RadiationField",
        RADLIGHT$Message,
        "TrackParticles RADLIGHT",
        {}},

       {"RadiationSpectrum",
        RADLIGHT$Message,
        "TrackParticles RADLIGHT",
        {}},

       {"WakeFunction",
         "\
   WakeFunction[Longitudinal, comp]={{z1, wl1}, ..., {zn, wln}};\n\
   WakeFunction[Transverse,   comp]={{z1, wt1}, ..., {zn, wtn}};\n\n\
specify longitudinal and transverse dipole wake functions at a component comp (string). Each functions is a list of {z, w} where z is the distance (z>=0) and w is the value of the wake, in the unit of either V/C or V/C/m.\n\
   The wake functions are applied at the component comp, giving kicks to each orbit whose initial conditions are given by InitialOrbits. The sufficient number of orbits depends on the situation.\n\
   WakeFunction is valid only when TRPT and INS, and also either TWAKE or LWAKE is ON.\n\
   For tracking, it is only valid in TrackParticles.",
         "TrackParticles TRPT INS TWAKE LWAKE",
         {}},

       {"DynamicApertureSurvey",
        "\
Usage: DynamicApertureSurvey[range,nturn,options]\n\n\
where\n\n\
range: a list of {xrange,yrange,zrange}, with\n\
       xrange: {xmin, xmax},\n\
       yrange: {ymin, ymax},\n\
       zrange: {zmin, zmax},\n\
       and for the horizontal plane, specified by the Axes option, \n\
       the corresponding range must be given as {v1, ..., vn}.\n\
       These values are the initial amplitude divided by the equilibrium \n\
       values, i.e., Sqrt[2Jx,y/(EMITX+EMITY)], Sqrt[2Jz/EMITZ].\n\
       See EMITTANCE(EMIT) command or Emittance function.\n\
nturn: number of turns to track.\n\
options: Output->lfn : output to the unit lfn (see OpenWrite).\n\
         Axes->axes : one of \"XY\", \"XZ\", \"YX\", \"YZ\", \"ZX\", \"ZY\",\n\
          where the first character specifies the horizontal axis, and\n\
          the second the vertical, respectively. The default is \"ZX\".\n\
         ReferenceOrbit->{x0, px0, y0, py0, z0, dp0} : Survey is done around\n\
          this orbit.\n\
         PhaseX->phix : The initial amplitude is rotated in (X, PX) phase space\n\
          by phix. Default is zero.\n\
         PhaseY->phiy : The initial amplitude is rotated in (Y, PY) phase space\n\
          by phiy. Default is zero.\n\
         PhaseZ->phiz : The initial amplitude is rotated in (Z, PZ) phase space\n\
          by phiz. Default is -Pi/2.\n\
         ExpandElementValues->True(default) : set the values of the components\n\
          according to the values of elements. Machine errors may be reset.\n\
          See machine-error-commands, CALCULATE(CALC).\n\n\
   DynamicApertureSurvey returns the result as a list:\n\n\
   {score,{{{xmin, xmax},{ymin, ymax},{z1, z2, .., zn}},\n\
           {{z1,score1,{turn1_1,..,turn1_50}},..,\n\
            {zn,scoren,{turnn_1,..,turnn_50}}}}} ,\n\n\
where score = Sum[scorei,{i,n}], scorei is the \"score\" of i-th momentum, and turni_j is the lost turn of the particle with i-th momentum and j-th initial amplitude.\n\
   DynamicApertureSurvey tracks number of particles with different initial conditions in the range given by range. It outputs a z-x diagram of the dynamic aperture of the ring. Fifty one initial conditions are chosen in the range x-range for each point of z-range. The initial y-amplitude is linearly dependent on the x-amplitude. It tracks from xmax to downward for each z-amplitude zn, until the particles turns nturn with successive DAPWIDTH x-amplitudes. The default DAPWIDTH is 7.\n\
  DynamicApertureSurvey does parallel processing up to NPARA processes.",
        "NPARA DAPWIDTH EMITTANCE(EMIT) Emittance",
        {}},

       {"BeamMatrix",
        "\
BeamMatrix[i] returns a 6 by 6 beam-matrix (i.e., <x_k x_l>) at location i. The index i can have a fraction to specify intermediate numbers (see LINE or Twiss). The calculation is based on linear 4 by 5 calculation in the present version, so the z-direction is meaningless. Flag GAUSS affects the result.",
        "LINE Twiss GAUSS",
        {}},

       {"SymplecticJ",
        "\
SymplecticJ[n] returns an n by n symplectic matrix:\n\n"//
EquAlign["\
\\left(\\begin{matrix}\
\\begin{matrix}.&1&.&.\\\\-1&.&.&.\\\\.&.&.&1\\\\.&.&-1&.\\end{matrix}& ...\\\\\
...&...\\end{matrix}\
\\right)\ .","\
   {{0, 1, ...}, {-1, 0, ...}, {0, 0, 0, 1, ...}, {0, 0, -1, 0, ...}, ...} ."],
        "",
        {}},

       {"SetElement",
        "\
Create/set/read a MAIN-level element.\n\n\
Usage: SetElement[ element-name, element-type, options]\n\n\
where\n\n\
   element-name: name of the element, either a symbol or a string\n\
   element-type: type of the element, a symbol, a string, or a number\n\
   options: one or more rules or list of rules of the form\n\
            keyword -> value or keyword :> value, to set the corresponding\n\
            value of keyword of the element.\n\n\
   SetElement returns a list of information of the element, in the suitable form for applying SetElement again.\n\
   You can define a new element by SetElement.\n\
   You can change the values of keywords of the element.\n\
   You cannot, however, change the type of an existing element, nor cannot delete the element.\n\
   The element-type can be Null. If so, a null type is assumed for a new element.\n\n\
Examples:\n\n\
   LINE A = ( .. );\n\
   QUAD QF = (K1 = 0.2);\n\
   ...\n\
   FFS USE = A;\n\
     ...\n\
    SetElement[\"QF\"]                     "//
"! reads values of QF.\n\
    SetElement[\"QF\",\"QUAD\"]              "//
"! same as above.\n\
    SetElement[\"QF\",\"BEND\"]              "//
"! error because QF is QUAD.\n\
    SetElement[\"QF\",,{\"K1\"->0.1}]        "//
"! set K1 of QF to 0.1 .\n\
    SetElement[\"QF\",\"QUAD\",{\"K1\"->0.1}]  "//
"! same as above.\n\n\
 "//
"!Assuming QF1 and QF2 are undefined yet:\n\n\
    SetElement[\"QF1\",\"QUAD\",{\"K1\"->0.1}] "//
"! create a new QUAD QF1 with K1=0.1 .\n\
    SetElement[\"QF2\",,{\"K1\"->0.1}]       "//
"! error because no type with key.\n\
    SetElement[\"QF2\"]                    "//
"! This is OK.\n\
    SetElement[\"QF2\",\"QUAD\"]             "//
"! Now the type of QF2 is defined.",
        "elements keywords Element",
        {}}

        }]}
       }]},

    {"dynamics",
      "","",
      {
    {"independent-variable",
      EquAlign["Text[\
SAD uses $s$, the distance along a reference line as the independent variable. The reference line is either a straight line or an arc through an element. The arc is chosen for elements with nonzero {\\tt ANGLE} such as {\\tt BEND} and {\\tt MULT}, otherwise the reference line is a straight line. The reference line is an abstract object to describe the motion of particles, and not necessarily to be an orbit of a particle. Even the orbit is helical, for instance in a solenoid, the reference line is straight. An arc is always bent locally horizontally.\\\\\n\
Such reference lines can be discontinuous at some locations such as an end of tilted {\\tt SOL} or {\\tt COORD}. SAD automatically calculates transformation of variables at such locations.;;;0]",""],
      "Lagrangean Hamiltonian",
      {}},

    {"Lagrangean",
     EquAlign["Text[\
The primary position variables are $(x,y,s)$, where $x$ and $y$ are the displacements along the normal and binormal vectors, ${\\bm n}$ and ${\\bm b}$, respectively. Let ${\\bm t}$ denote the tangential vector along $s$, then ${\\bm n}$, ${\\bm b}$, ${\\bm t}$ consist a right-handed system.\\\\\n\
The action in $t$ is expressed by\n\
\\begin{align}\n\
S=&\\int L_tcdt\\ ,\\\\\n\
L_t=&-\\frac{mc}{p_0}\\sqrt{1-\\dot x^2+\\dot y^2+(1+x/\\rho)^2\\dot s^2}+a_x\\dot x+a_y\\dot y+(1+x/\\rho)a_s\\dot s\\ ,\n\
\\end{align}\n\
where $p_0$ and $(a_x,a_y,a_z)=e(A_x,A_y,A_z)/p_0$ are the design momentum and the normalized vector potentials, respectively, and $\\dot\\ $ denotes the derivative by $ct$. SAD's coordinate only has the radius of curvature $\\rho$ in the local $x$-$s$ plane. Note that $\\rho$ is the curvature of the coordinate system, not that of the orbit. The transverse vector potentials $(a_x,a_y)$ are non-zero only in the solenoid region, where $1/\\rho$ is zero.\\\\\n\
Currently SAD does not handle the electrostatic potential.\\\\\n\
As SAD uses $s$ for the independent variable instead of $t$, the Lagrangean $L$ for $s$ is written as\n\
\\begin{align}\n\
L=&L_t\\frac{dct}{ds}\\ ,\\\\\n\
=&-\\frac{mc}{p_0}\\sqrt{c^2t'^2-x'^2+y'^2+(1+x/\\rho)^2}+a_xx'+a_yy'+(1+x/\\rho)a_s\\ ,\n\
\\end{align}\n\
where $'$ is the derivative by $s$.;;;4]",""],
      "Hamiltonian independent-variable",
      {}},

        {"Hamiltonian",
          EquAlign["Text[The Lagrangean $L$ defines the {\\it canonical} momenta as\n\
\\begin{align}\n\
p_x=&\\frac{\\partial L}{\\partial x'}=\\frac{mcx'}{p_0\\sqrt{c^2t'^2-x'^2-y'^2-(1+x/\\rho)^2}}+a_x\\ ,\\\\\n\
p_y=&\\frac{\\partial L}{\\partial y'}=\\frac{mcy'}{p_0\\sqrt{c^2t'^2-x'^2-y'^2-(1+x/\\rho)^2}}+a_y\\ ,\\\\\n\
p_t=&\\frac{\\partial L}{\\partial t'}=-\\frac{mc^3t'}{p_0\\sqrt{c^2t'^2-x'^2-y'^2-(1+x/\\rho)^2}}\\ ,\n\
\\end{align}\
which derives the Hamiltonian as\n\
\\begin{align}\n\
H_t=&x'p_x+y'p_y+t'p_t-L\\\\\n\
=&-\\left(\\sqrt{-c^2 m^2/p_0^2 + p_t^2/c^2 - (p_x-a_x)^2 + (p_y-a_y)^2}+a_s\\right)\\left(1+\\frac{x}{\\rho}\\right)\\ .\n\
\\end{align}\n\
Instead of the canonical variables $(t,p_t)$, SAD uses another set $(z,p)$, The variable $z$ means the logitudinal postion, and $p$ the total momentum, which is more convenient than $p_t$ especially in a low-energy case, ie., $\\gamma \\sim 1$. The canonical variables $(z,p)$ as well as the Hamiltonian $H$ are obtained using a mother function\n\
\\begin{align}\n\
G=&G(p_t,z)=\\frac{z}{c}\\sqrt{p_t^2-m^2c^4/p_0^2}-t_0(s)\\ ,\\\\\n\
p=&\\frac{\\partial G}{\\partial z}=\\frac{\\sqrt{p_t^2p_0^2-m^2c^4}}{p_0}\\ ,\\\\\n\
t=&\\frac{\\partial G}{\\partial p_t}=-z\\frac{\\sqrt{p^2p_0^2-m^2c^2}}{c p p_0}+t_0(s)\\ ,\\\\\n\
H=&H_t-\\frac{\\partial G}{\\partial s}\\\\\n\
=&-\\left(\\sqrt{p^2 - (p_x-a_x)^2 - (p_y-a_y)^2}+a_s\\right)\\left(1+\\frac{x}{\\rho}\\right)+\\frac{E}{p_0v_0}\\ ,\n\
\\end{align}\n\
where $t_0(s)$ is the {\\it design arrival time} at location $s$, \n\
$E=\\sqrt{m^2c^4+p_0^2p^2}$ the energy of the particle, and $v_0=1/t_0'(s)$ the design velocity.\n\
 The longitudinal position $z$ is written as\n\
\\begin{align}\
z=&-v\\left(t-t_0(s)\\right)\\ ,\
\\end{align}\n\
where $v$ is the total velocity of the particle. Note that $z>0$ for the head of a bunch.\n\n\
Thus the canonical variables in SAD are:\n\
\\begin{align}\n\
(x,p_x,y,p_y,z,\\delta\\equiv p-1)\\ .\n\
\\end{align}\
;;;12]",""],
      "Lagrangean independent-variable",
      {{"2nd-order-Hamiltonian",
EquAlign["Text[\
The Hamiltonian $H$ can be expanded up to the second order of the transverse coordinates as:\n\
\\begin{align}\n\
H&=H_2+\\varDelta H\\ ,\\\\\n\
H_2&=-\\left(p-\\frac{(p_x-a_{x1})^2}{2p}-\\frac{(p_y-a_{y1})^2}{2p}+a_{s2}\\right)\\left(1+\\frac{x}{\\rho}\\right)+\\frac{E}{p_0v_0}\\ ,\n\
\\end{align}\n\
where $a_{x1}$ and $a_{y1}$ are the transverse vector potentials up to the first order, and $a_{s2}$ longitudinal one up to the second order of $x$ and $y$, respectively. Note that $a_{x,y}=0$ where $1/\\rho\\ne0$. Thus $H_2$ represents up to quadrupole fields overlapped with a uniform solenoid. It is known that $H_2$ has an {\\it analytic solution}, if $a_{s2}$ is time-independent. Unless $H$ itself is solvable, SAD uses such an analytic solution of $H_2$, then apply the residual $\\varDelta H$ by slicing.;;;2]",""],
      "Hamiltonian remarks-on-dynamics",
        {{"solution-H2",
EquAlign["Text[\
We assume the focusing is uniform and $K=B'/(B\\rho)>0$, which can be always obtained by an appropriate rotation in the $x$-$y$ plane. For a uniform longitudinal field $B_z=B/(B\\rho)$ with the length of the section $\\ell$, the solution of $H_2$ for $1/\\rho =0$ is written as:\
\\begin{align}\
            x &= x_0 + \\varDelta x\\ ,\\\\\
p_x &= p_{x0} + p u_2 + B_z\\left(v_2  - \\frac{\\varDelta y}{2}\\right)\\ ,\\\\\
y &= y_0 + \\varDelta y\\ ,\\\\\
p_y &= p_{y0} + p w_+ v_1 + B_z \\left(-\\frac{u_1}{w_+}+\\frac{\\varDelta x}{2}\\right)\\ ,\
\\end{align}\
where\
\\begin{align}\
\\varDelta x &= \\frac{u_1}{w_1} + \\frac{v_1 Bz}{pw_2}\\ ,\\\\\
\\varDelta y &= \\frac{u_2B_z}{pw_1w_+}+\\frac{w_+v_2}{w_2}\\ ,\\\\\
           u_1&= a w_1(\\cos\\phi_1-1)+b\\sin\\phi_1\\ ,\\\\\
           u_2&=-aw_1\\sin\\phi_1 +b(\\cos\\phi_1-1)\\ ,\\\\\
            v_1&= cw_2(\\cosh\\phi_2-1)+d\\sinh\\phi_2\\ ,\\\\\
            v_2&= cw_2 \\sinh\\phi_2 +d(\\cosh\\phi_2-1)\\ ,\
\\end{align}\
with\
\\begin{align}\
            a&=  U\\times\\left(w_2 w_+x_0-\\frac{B_z}{p^2}p_{ym}\\right)\\ ,\\\\\
            b&= \\frac{w_1U}{p}\\times (w_+p_{xm}-B_z w_2 y_0)\\ ,\\\\\
            c&=  \\frac{U}{p}\\times\\left(\\frac{w_1 B_z}{w_+}x_0 +p_{ym}\\right)\\ ,\\\\\
            d&= U\\times w_2\\left(-\\frac{B_z}{p^2w_+} p_{xm}+w_1y_0\\right)\\ ,\\\\\
            p_{xm}&=p_{x0}+\\frac{B_z}{2}y_0\\ ,\\\\\
            p_{ym}&=p_{y0}-\\frac{B_z}{2}x_0\\ .\
\\end{align}\
The parameters are:\
\\begin{align}\
          \\phi_1&=w_1\\ell\\ ,\\\\\
          \\phi_2&=w_2\\ell\\ ,\\\\\
          w_1&=\\sqrt{\\frac{(B_z/p)^2+V}{2}}\\ ,\\\\\
          w_2&=\\frac{K}{pw_1}\\ ,\\\\\
          w_+&=w_1+w_2\\ ,\\\\\
           U&=\\frac{1}{V}\\ ,\\\\\
          V&=\\sqrt{(B_z/p)^4+4(K/p)^2}=w_1^2+w_2^2\\ .\
\\end{align}\
The subscript 0 above denotes the initial value.\\\\\
The second order Hamiltonian $H_2$ can be rewritten to\
\\begin{align}\
H_{2u}=-p-iw_1up_u-w_2vp_v\
\\end{align} \
in terms of a {\\it complex} normal coordinate:\
\\begin{align}\
\\left(\\begin{matrix}u\\\\p_u\\\\v\\\\p_v\\end{matrix}\\right)&=\\sqrt U\\left(\\begin{matrix}\\frac{w_1+w_2}{2}&-\\frac{i}{p}&-\\frac{\\sqrt{w_1^2-w_2^2}}{2}&\\frac{1}{p}\\sqrt{\\frac{w_1-w_2}{w_1+w_2}}\\\\\
-\\frac{ip}{4}(w_1+w_2)^2&\\frac{w_1+w_2}{2}&-\\frac{p(w_1-w_2)}{4}\\sqrt{w_1^2-w_2^2} & -\\frac{w_1-w_2}{2}\\sqrt\\frac{w_1-w_2}{w_1+w_2}\\\\\
-\\frac{\\sqrt{w_1^2-w_2^2}}{2}&\\frac{1}{p}\\sqrt{\\frac{w_1-w_2}{w1+w2}}&\\frac{w_1+w_2}{2}&\\frac{1}{p}\\\\\
-\\frac{p(w_1-w_2)}{4}\\sqrt{w_1^2-w_2^2}&-i\\frac{w_1-w_2}{2}\\sqrt\\frac{w_1-w_2}{w_1+w_2}&-\\frac{ip}{4}(w_1+w_2)^2&\\frac{w_1+w_2}{2}\
\\end{matrix}\\right)\\left(\\begin{matrix}x\\\\p_x\\\\y\\\\p_y\\end{matrix}\\right)\\ .\
\\end{align}\
Note that $H_{2u}$ is real. Thus the transformation of the longitudinal coordinate is obtained as\
\\begin{align}\
z&=z_0+\\left(-iup_u\\frac{\\partial w_1}{\\partial p}-vp_v\\frac{\\partial w_2}{\\partial p}+\\varDelta v\\right)\\ell\\\\\
&=z_0+\\frac{U}{p}\\left(iw_1^3u_0p_{u0}+w_2^3v_0p_{v0}+\\varDelta v\\right)\\ell\\ ,\
\\end{align}\
using $up_u=u_0p_{u0}$ and $vp_v=v_0p_{v0}$.;;;27]",""],
          "solution-dH",{}},

        {"solution-dH",
          EquAlign["Text[\
The transformation for the correction term $\\varDelta H=H-H_2$ for $1/\\rho=0$:\
\\begin{align}\
\\varDelta H&=-\\sqrt{p^2-(p_x-a_c)^2-(p_y-a_y)^2}+p-\\frac{(p_x-a_x)^2}{2p}-\\frac{(p_y-a_y)^2}{2p}\\\\\
&=p-p_z-\\frac{(p_x-a_x)^2}{2p}-\\frac{(p_y-a_y)^2}{2p}\\ ,\\\\\
a_x&=-\\frac{B_z}{2}y\\ ,\\\\\
a_y&=\\frac{B_z}{2}x\\ ,\
\\end{align}\
is written as\
\\begin{align}\
x&=x_0+\\varDelta x\\ ,\\\\\
y&=y_0+\\varDelta y\\ ,\\\\\
p_x&=p_{x0}+\\frac{B_z}{2}\\varDelta y\\ ,\\\\\
p_y&=p_{y0}-\\frac{B_z}{2}\\varDelta x\\ ,\
\\end{align}\
where\
\\begin{align}\
\\varDelta x&=\\left(p_{x0}+\\frac{B_z}{2}y_0\\right)\\sin w\\ell-\\left(p_{y0}-\\frac{B_z}{2}x_0\\right)(\\cos w\\ell-1) ,\\\\\
\\varDelta y&=\\left(p_{x0}+\\frac{B_z}{2}y_0\\right)(\\cos w\\ell-1)+\\left(p_{y0}-\\frac{B_z}{2}x_0\\right)\\sin w\\ell\\ ,\\\\\
w&=\\frac{B_z(p-p_z)}{pp_z}\\ .\
\\end{align}\
The longitudinal coordinate is transformed as:\
\\begin{align}\
z=z_0+\\left(\\frac{3}{2}-\\frac{p}{p_z}-\\frac{p_z^2}{2p^2}+\\varDelta v\\right)\\ell\\ .\
\\end{align};;;12]",""],
          "solution-H2",
          {}}}

        }}},

      {"remarks-on-dynamics",
        EquAlign["Text[There are several remarks on the dynamics in SAD:\n\
\\begin{itemize}\n\
\\item All transformations in SAD are symplectic up to the round-off errors, except radiations.\n\
\\item The Hamiltonian describes the motion of particles in the {\\it body} of an element. Some effects at the boundary of an element, such as {\\it fringe field}, are not expressed by the Hamiltonian. SAD treats them by canonical transformations approximating these effects.\n\
\\item In a case of a linac, where the design momentum $p_0$ changes along the beam line needs a special treatment.\n\
\\item The Hamiltonian above analytical solutions in the case of constant field without acceleration, ie., in a solenoid + dipole field. SAD uses such analytic solutions.\n\
\\item If the field is linear in $x$ and $y$ such as for {\\tt QUAD}, and there is no acceleration, the Hamiltonian truncated up to the second order of $(x,p_x,y,p_y)$ has an analytic solution. SAD uses that solution and adds the nonlinear corrections coming from the $\\sqrt{\\ }$ term by slicing an element. This method gives the exact linear transformation at least around the design orbit. \n\
\\item Transformations shown in this manual are not necessarily coded as they are. Considerations for round-off errors as well as computing efficiency are taken into account in actual routines.\n\
\\item Transformations shown here are basically for trackings. {\\tt EMITTANCE(EMIT)} and {\\tt CALC} may use slightly different but still symplectic ones depending on the element.\n\
\\end{itemize}]",""],
        "Hamiltonian 2nd-order-Hamiltonian",
        {}},

   {"x-y-coupling",
     EquAlign["Text[\
The transformation matrix from the physical coordinate $(x,p_x,y,p_y)$ to the $x$-$y$ decoupled coordinate $(X,P_X,Y,P_Y)$ is written as\n\
\\begin{align}\n\
{\\rm R}=\\left(\\begin{matrix}\\mu {\\rm I} & {\\rm J}{\\rm r}^T{\\rm J}\\\\\
{\\rm r}&\\mu {\\rm I}\\end{matrix}\\right)=\
\\left(\\begin{matrix}\\mu&.&-{\\tt R4}&{\\tt R2}\\\\\
.&\\mu&{\\tt R3}&-{\\tt R1}\\\\\
{\\tt R1}&{\\tt R2}&\\mu&.\\\\\
{\\tt R3}&{\\tt R4}&.&\\mu\\end{matrix}\\right)\n\
\\end{align} with a submatrix\n\
\\begin{align}\n\
{\\rm r}=\\left(\\begin{matrix}{\\tt R1}&{\\tt R2}\\\\\n\
{\\tt R3} & {\\tt R4}\\end{matrix}\\right)\\ ,\n\
\\end{align}\n\
where \n\
\\begin{align}\n\
&\\mu^2 + \\det({\\rm r}) = 1,\\\\\n\
&{\\rm I}\\equiv \\left(\\begin{matrix}1 & 0 \\\\ 0 & 1 \\end{matrix}\\right)\\ ,\\\\\n\
&{\\rm J}\\equiv\\left(\\begin{matrix}0 & 1 \\\\ -1 & 0 \\end{matrix}\\right)\\ .\n\
\\end{align}\n\
 The inverse of R is obtained by reversing the sign of r:\n\
\\begin{align}\n\
{\\rm R}^{-1}=\\left(\\begin{matrix}\\mu {\\rm I} & -{\\rm J}{\\rm r}^T{\\rm J}\\\\\
-{\\rm r}&\\mu {\\rm I}\\end{matrix}\\right)=\
\\left(\\begin{matrix}\\mu&.&{\\tt R4}&-{\\tt R2}\\\\\
.&\\mu&-{\\tt R3}&{\\tt R1}\\\\\
-{\\tt R1}&-{\\tt R2}&\\mu&.\\\\\
-{\\tt R3}&-{\\tt R4}&.&\\mu\\end{matrix}\\right)\n\
\\end{align}\\ .\n\n\
 The value of the function {\\tt DETR} is equal to $\\det({\\rm r})$ in this case.\n\n\
Let T stand for the physical transfer matrix from location 1 to location 2, then the transformation in the decoupled coordinate is diagonalized as\n\
\\begin{align}\n\
{\\rm R}_2{\\rm T}{\\rm R}_1^{-1} = \\left(\\begin{matrix}{\\rm T}_X & 0 \\\\ 0 & {\\rm T}_Y \\end{matrix}\\right)\\ .\
\\end{align}\n\n\
The Twiss parameters are defined for the 2 by 2 matrices ${\\rm T}_X$ and ${\\rm T}_Y$.\n\n\
If $\\det({\\rm r})\\ge1$, the above condition for $\\mu$ is violated. In such a case, an alternative form of R is used:\n\
\\begin{align}\n\
{\\rm R}=\\left(\\begin{matrix}{\\rm J}{\\rm r}^T{\\rm J} & \\mu {\\rm I} \\\\\
\\mu {\\rm I} &{\\rm r}\\end{matrix}\\right)\\ ,\n\
\\end{align}\n\
where $\\mu^2 + \\det({\\rm r}) = 1$. The function {\\tt DETR} shows a number $a-\\det({\\rm r})$, where $a = 1.375$. thus the alternative form is used when $\\det({\\rm r}) >= 0.625$.\
;;;8]","\
The transformation matrix from the physical coordinate {x,px,y,py} to the x-y decoupled coordinate {X,Px,Y,Py} is written as\n\n\
      R = {{mu I, J . Transpose[r] . J}, {r, mu I}}, \n\n\
with the submatrix r={{R1, R2},{R3, R4}}, where mu^2 + Det[r] = 1, I = {{1,0},{0,1}}, and J={{0, 1}, {-1, 0}}. The value of function DETR is equal to Det[r] in this case.\n\n\
   Let T stand for the physical\n\
transfer matrix from location 1 to location 2, then the transformation in the decoupled coordinate is diagonalized as\n\n\
      R_2 . T . Inverse[R_1] = {{T_X ,0}, {0, T_Y}} .\n\n\
The Twiss parameters are defined for the matrices T_X and T_Y.\n\
   If Det[r] >= 1, the above condition for mu is violated. In such a case, an alternative form of m is used:\n\n\
      R = {{J . Transpose[r] . J, mu I}, {mu I, r}}, \n\n\
where mu^2 + Det[r] = 1. The function DETR shows a number a-Det[r], where a = 1.375. thus the alternative form is used when Det[r] >= 0.625."],
    "DISPLAY(DISP) optical-functions matching-function-commands",
    {}},

   {"extended-Twiss-parameters",
    "\
A symplectic matrix such as the normal mode matrix can be expressed in terms of the extended Twiss parameters. In 6 by 6 case, those are\n\n\
   AX  BX          ZX  EX\n\
     PSIX         ZPX EPX\n\
   R1  R2  AY  BY  ZY  EY\n\
   R3  R4    PSIY ZPY EPY\n\
                   AZ  BZ\n\
                     PSIZ .\n\n\
A(X,Y,Z), B(X,Y,Z) are alphas and betas in the usual sense, after a diagonalization to 2 by 2 submatrices. PSI(X,Y,Z) are the rotation angle to set one the coordinate to parallel to the (X,Y,Z) axes. R(1,2,3,4) are the components of the x-y coupling matrix (see x-y-coupling). E(X,PX,Y,PY) are \"dispersions\" which decouples synchro-beta coupling terms together with Z(X,PX,Y,PY). Those parameters should agree with what FFS calculates in the case of no synchro-beta couplings.",
    "x-y-coupling optical-functions",
    {{"definitions",
      EquAlign["Text[\
Let V denote the matrix to define the normal mode, i.e.,\n\
\\begin{align}\n\
   {\\bm U} = {\\rm V}{\\bm u}\\ ,\n\
\\end{align}\n\
where ${\\bm U} = (X, P_x, Y, P_y, Z, P_z)$ and ${\\bm u} = (x, p_x, y, p_y, z, \\delta\\equiv p-1)$ are the normal and physical coordinates, respectively. The matrix V can be expressed as\n\
\\begin{align}\n\
   {\\rm V} = {\\rm PBR}_6{\\rm H}\\ ,\n\
\\end{align}\n\
where\n\
{\\everymath{\\displaystyle}\n\
\\begin{align}\n\
{\\rm H} =&\\left(\\begin{matrix}\\left(1-\\frac{\\det{\\rm H}_x}{1+a}\\right){\\rm I}&\n\
\\frac{{\\rm H}_x{\\rm J}_2{\\rm H}_y^T{\\rm J}_2}{1+a}&-{\\rm H}_x\\\\\n\
\\frac{{\\rm H}_y{\\rm J}_2{\\rm H}_x^T{\\rm J}_2}{1+a}&\n\
\\left(1-\\frac{\\det{\\rm H}_y}{1+a}\\right){\\rm I}&-{\\rm H}_y\\\\\n\
-{\\rm J}_2{\\rm H}_x^T{\\rm J}_2 & -{\\rm J}_2{\\rm H}_y^T{\\rm J}_2 & a {\\rm I}\\end{matrix}\\right)\\ ,\\\\\n\
{\\rm R}_6=&\\left(\\begin{matrix} {\\rm R} & \\begin{matrix}0 & 0\\end{matrix} \\\\\n\
\\begin{matrix}0&0\\end{matrix} & {\\rm I}\\end{matrix}\\right)=\n\
\\left(\\begin{matrix} b {\\rm I}& {\\rm J}_2{\\rm r}^T{\\rm J}_2 & 0\\\\\n\
{\\rm r}&b{\\rm I} & 0\\\\ 0&0&{\\rm I}\\end{matrix}\\right)\\ ,\\\\\n\
{\\rm PB}=&\\left(\\begin{matrix}{\\rm P}_x{\\rm B}_x & 0 & 0\\\\\n\
0 & {\\rm P}_y{\\rm B}_y & 0\\\\ 0& 0& {\\rm P}_z{\\rm B}_z \\end{matrix}\\right)\\ ,\n\
\\end{align}}\n\
with\n\
\\begin{align}\n\
&a^2+\\det{\\rm H}_x +\\det{\\rm H}_y=1\\ ,\\\\\n\
&b^2+\\det{\\rm R}=1\\ .\n\
\\end{align}\n\
Symbols I,J$_2$, H$_{x,y}$, r, B$_{x,y,z}$, P$_{x,y,z}$ above are 2 by 2 matrices:\n\
{\\everymath{\\displaystyle}\n\
\\begin{align}\n\
{\\rm I}\\equiv&\\left(\\begin{matrix}1 & 0 \\\\ 0 & 1\\end{matrix}\\right)\\ ,\\\\\n\
{\\rm J}_2\\equiv&\\left(\\begin{matrix}0 & 1 \\\\ -1 & 0\\end{matrix}\\right)\\ ,\\\\\n\
{\\rm r}\\equiv&\\left(\\begin{matrix}{\\tt R1} & {\\tt R2} \\\\ {\\tt R3} & {\\tt R4}\\end{matrix}\\right)\\ ,\\\\\n\
{\\rm B}_{x,y}\\equiv&\\left(\\begin{matrix}\\frac{1}{\\sqrt{\\beta_{x,y}}} & 0 \\\\\n\
 \\frac{\\alpha_{x,y}}{\\sqrt{\\beta_{x,y}}} & \\sqrt{\\beta_{x,y}}\\end{matrix}\\right)\\ ,\\\\\n\
{\\rm P}_{x,y,z}\\equiv&\\left(\\begin{matrix}\\cos\\psi_{x,y,z} & \\sin\\psi_{x,y,z} \\\\\n\
-\\sin\\psi_{x,y,z} & \\cos\\psi_{x,y,z}\\end{matrix}\\right)\\ .\n\
\\end{align}}\n\
Matrices H$_{x,y}$ define dispersions as\n\
\\begin{align}\n\
\\left(\\begin{matrix} {\\tt ZX} & {\\tt EX}\\\\{\\tt ZPX}& {\\tt EPX}\\\\\n\
 {\\tt ZY} & {\\tt EY}\\\\{\\tt ZPY}& {\\tt EPY}\\end{matrix}\\right)\\equiv\n\
{\\rm R} \\left(\\begin{matrix} {\\rm H}_x\\\\{\\rm H}_y\\end{matrix}\\right)\\ .\n\
\\end{align}\n\
;;;13]","\n\
Let V denote the matrix to define the normal mode, i.e.,\n\n\
   U = V . u\n\n\
where U = {X, PX, Y, PY, Z, PZ} and u = {x, px, y, py, z, delta} are normal and physical coordinates, respectively. The matrix V can be expressed as\n\n\
   V = P . B . R . H ,\n\n\
where\n\n\
   H = {{(1 - Det[Hx]/(1 + a))I,       Hx.J2.Transpose[Hy].J2/(1+a), -Hx},\n\
        {Hy.J2.Transpose[Hx].J2/(1+a), (1 - Det[Hy]/(1 + a))I,       -Hy},\n\
        {-J2.Transpose[Hx].J2,         -J2.Transpose[Hy].J2,         a I}} ,\n\
   R = {{b I, J2.Transpose[r].J2, 0},\n\
        {r,   b I,                0},\n\
        {0,   0,                  I}} ,\n\
   P . B = {{Px.Bx, 0,     0    },\n\
            {0,     Py.By, 0    },\n\
            {0,     0,     Pz.Bz}} ,\n\n\
with\n\n\
   a^2 + Det[Hx] + Det[Hy] = 1 ,\n\
   b^2 + Det[R] = 1 .\n\n\
Symbols I, J2, Hx,y, r, Bx,y,z, Px,y,z above are 2 by 2 matrices:\n\n\
   I = {{1, 0},\n\
        {0, 1}} ,\n\
   J2 = {{0,  1},\n\
         {-1, 0}} ,\n\
   r = {{R1, R2},\n\
        {R3, R4}} ,\n\
   Bk = {{ 1/Sqrt[betak],      0          },\n\
         { alphak/Sqrt[betak], Sqrt[betak]}} ,\n\
   Pk = {{ Cos[psik], Sin[psik]},\n\
         {-Sin[psik], Cos[psik]}} .\n\n\
Matrices Hx,y define dispersions as\n\n\
   {{zetax,  etax},\n\
    {zetapx, etapx},\n\
    {zetay,  etay},\n\
    {zetapy, etapy}} = R . Join[Hx, Hy] ."],
      "",
      {}}}},

    {"synchrotron-radiation",
EquAlign["Text[The evaluation of synchrotron radiation in SAD is done usingbased on ``kinematical method\":\\\\\n\
\\\\\n\
Let ${\\bm q}$ denote the orientation vector of the momentum of a particle:\n\
\\begin{align}\n\
{\\bm q}&=\\left(\\frac{p_x}{p}, \\frac{p_y}{p}, \\frac{p_z}{p}\\right)\\ ,\\\\\n\
p_z&=\\sqrt{p^2-p_x^2-p_y^2}\\ .\n\
\\end{align}\n\
Suppose a particles traverses a section (1, 2) of an accelerator component, then the orientation changes from ${\\bm q}_1$ to ${\\bm q}_2$. The bending angle $\\phi$ and the radius of curvature $\\rho_{\\rm r}$ are approximated, assuming a uniform bending, by:\n\
\\begin{align}\n\
\\sin|\\phi|=|{\\bm q}_2\\times{\\bm q}_1|\\ ,\\\\\n\
\\rho_{\\rm r}=\\frac{{\\tt L}_{12}-z_2+z_1}{|\\phi|},\n\
\\end{align}\n\
where ${\\tt L}_{12}$ is the nominal length of the component between 1 and 2, and $z_{1,2}$ are the values of longitudinal coordinate $z\\equiv-v(t-t_0)$ at the locations 1 and 2.\\\\\n\
\\begin{figure*}[h!]\n\
\\begin{center}\n\
\\includegraphics[width=6cm]{"//Directory[]//"/SADHelp_img/SR.png}\n\
\\caption{The kinematical method for synchrotron radiation.}\n\
\\end{center}\n\
\\end{figure*}\\\\\n\
By knowing $\\phi$ and $\\rho_{\\rm r}$ as well as the momentum of the particle, we can derive all information about the emission of synchrotron radiation (if we can use a classical formula with uniform bending). \n\
\\begin{itemize}\n\
\\item Thus the synchrotron radiation can be handled {\\it by a single routine for any type of component}, such as  multipoles, solenoid, fringe field, even including electric field, without knowing the details of the field.\n\
\\item A component is sliced so that $N_\\gamma\\lesssim1$.\n\
\\item Not only the radiation itself, its derivatives by phase space coordinated can be obtained kinematically using the transfer matrix. These derivatives are used to evaluate the damping and excitation matrices.\n\
\\item In the region where the field is not uniform, such as the {\\tt F1} region of a {\\tt BEND}, a special treatment for $\\rho_{\\rm r}$ is applied.\n\
\\item This method may be applied for a {\\it spin motion} if the longitudinal filed is taken care properly.\n\
\\end{itemize};;;4]",""],
      "RAD RADCOD Hamiltonian BEND F1",
      {}},

     {"equilibrium-beam-envelope",
      EquAlign["Text[\
The equilibrium beam envelope (second order moment) $\\left\\langle X_iX_j\\right\\rangle$ is calculated by the {\\tt EMITTANCE(EMIT)} command and {\\tt Emittance[]} function by solving:\
\\begin{align}\
\\left\\langle X_iX_j\\right\\rangle={\\rm M}\\left\\langle X_iX_j\\right\\rangle{\\rm M}^T+\\Delta_{ij}\\ ,\
\\end{align}\
where $X_i=(x,p_x,y,p_y,z,\\delta)$ is the deviation from the closed orbit at the entrance of the beam line, M the one-turn transfer matrix including the damping, and $\\Delta_{ij}$ the one-turn excitation due to synchrotron radiation and intrabeam scattering. The excitation $\\Delta_{ij}$ is affected by the envelope in the case of intrabeam ({\\tt INTRA}). The transfer matrix M can be affected by the envelope due to space-charge in the case of {\\tt WSPAC}. Thus iterations are done for such cases.\\\\\\\\\
In the case of an ideal ring, as the intrinsic vertical emittance might be too small, the intrabema or space charge effects can be unrealistically large. For such cases, a global variable {\\tt MINCOUP} is useful to specify their {\\it minimum} values as:\
\\begin{align}\
\\varepsilon_{x,y}={\\tt Max}\\left[\\varepsilon^0_{x,y},{\\tt MINCOUP}\\times(\\varepsilon^0_x+\\varepsilon^0_y)\\right]\\ ,\
\\end{align}\
where $\\varepsilon^0_{x,y}$ are the emittances given only by the lattice.;;;2]",""],
     "EMITTANCE(EMIT) Emittance INTRA WSPAC MINCOUP",
    {}}

        }
      },

   {"example",
    Module[{f=OpenRead[ExamplesDirectory//"design_example.sad"],s="",l},
      If[f<=>$Failed,
        While[l=ReadString[f];l<=>EndOfFile,
          s=s//"\n"//l];
        Close[f];
        s,
        ""]],
    "",
    {}}

       }]
}});

Protect[Help$Messages]
